# Tasks: 010 Exploit Chain Memory (Cross-Iteration Intelligence)

**Input**: spec.md + plan.md
**Target File**: `kali-executor/open-interpreter/dynamic_agent.py`

## Phase 1: Arsenal Infrastructure (MVP)

- [ ] T001 [US-1] Add `ARTIFACT_PATTERNS` constant at module level (near line ~80):
  - Dict with categories: `credentials`, `tokens`, `api_keys`, `sessions`, `secrets`
  - Each category maps to a list of compiled regex patterns
  - Credentials: JSON cred pairs, colon-separated, HTTP Basic, shadow/passwd entries
  - Tokens: JWT (`eyJ...`), Bearer, generic auth tokens
  - API keys: AWS `AKIA...`, generic `api_key=`, Stripe `sk_live_`/`sk_test_`
  - Sessions: `Set-Cookie`, PHPSESSID, JSESSIONID, connect.sid
  - Secrets: DB connection strings, config passwords (DB_PASSWORD, SECRET_KEY, JWT_SECRET)

- [ ] T002 [US-1] Add state variables to `__init__` (near line ~460):
  - `self.arsenal: Dict[str, List[Dict]]` â€” initialized with empty lists per category
  - `self.arsenal_path = os.path.join(self.log_dir, "arsenal.json")`
  - `self.max_arsenal_entries = int(os.getenv("MAX_ARSENAL_ENTRIES", "100"))`
  - `self.exploit_chains: List[Dict] = []`
  - `self.exploit_chains_path = os.path.join(self.log_dir, "exploit_chains.json")`
  - Load persisted arsenal and chains from disk if files exist
  - Wrap loads in try/except (never crash on corrupt files)

- [ ] T003 [US-1] Add `_save_arsenal(self)` and `_save_chains(self)` methods:
  - Write `self.arsenal` to `self.arsenal_path` as JSON
  - Write `self.exploit_chains` to `self.exploit_chains_path` as JSON
  - Both wrapped in try/except (never crash on save failure)

- [ ] T004 Test: Verify arsenal initializes correctly, save/load round-trips work

**Checkpoint**: Arsenal storage infrastructure in place

## Phase 2: Artifact Extraction Engine

- [ ] T005 [US-2] Add `_extract_artifacts(self, command: str, stdout: str, stderr: str) -> List[Tuple[str, Dict]]` method:
  - Combine stdout + stderr into single search text
  - For each category in `ARTIFACT_PATTERNS`, run all regex patterns against text
  - For each match, create artifact dict:
    - `value`: the matched string(s) (for creds: `user:pass` combined)
    - `source_command`: command[:200]
    - `source_iteration`: self.iteration
    - `source_vuln`: self.current_vuln_focus_id or ""
    - `used_in`: [] (filled later when artifact is used)
    - `extracted_at`: ISO timestamp
  - Deduplicate: skip if `value` already exists in that arsenal category
  - Return list of `(category_name, artifact_dict)` tuples
  - Performance target: <50ms per call (regex only, no LLM)

- [ ] T006 [US-2] Add `_add_to_arsenal(self, artifact_type: str, artifact: Dict)` method:
  - Append artifact to `self.arsenal[artifact_type]`
  - Count total entries across all categories
  - If total > `max_arsenal_entries`:
    - Prune oldest `sessions` first (least valuable, most ephemeral)
    - Then oldest `access_levels`
    - NEVER prune `credentials` or `tokens` (highest value)
  - Call `self._save_arsenal()`
  - Log: `"ðŸ”‘ ARSENAL: Found {artifact_type} from iteration {N}"`

- [ ] T007 [US-2] Integrate artifact extraction into post-execution path:
  - In main loop, after command execution captures stdout/stderr
  - Before `_build_feedback()` or equivalent feedback step
  - Call `self._extract_artifacts(command, stdout, stderr)`
  - For each returned `(type, artifact)`, call `self._add_to_arsenal(type, artifact)`
  - Wrap in try/except (never crash the main loop on extraction failure)

- [ ] T008 Test: Run a command that produces creds in output, verify they appear in arsenal.json

**Checkpoint**: Artifacts automatically extracted from every command output

## Phase 3: Arsenal-Powered Exploit Suggestions

- [ ] T009 [US-3] Add `_get_relevant_arsenal_items(self, vuln_type: str, target: str) -> List[Dict]` method:
  - Iterate all arsenal categories
  - Relevance matching rules:
    - `credentials`: relevant if target in source_command OR service type matches vuln (DB creds for DB vulns)
    - `tokens`: always relevant for API/web targets (JWT can access any endpoint)
    - `api_keys`: relevant for API endpoint vulns
    - `sessions`: relevant if same target domain/IP
    - `secrets`: DB connection strings for data access; JWT secrets for token forging
  - Return list of `{"type", "value", "source", "suggestion"}` dicts
  - `suggestion` = concrete command using the artifact:
    - credential â†’ `curl -u user:pass http://target/admin`
    - JWT â†’ `curl -H 'Authorization: Bearer {token}' http://target/api/endpoint`
    - session â†’ `curl -b '{cookie}' http://target/dashboard`
    - DB string â†’ `mysql -u user -ppass -h host dbname -e 'SELECT * FROM users'`
  - Return max 5 items, sorted by relevance

- [ ] T010 [US-3] Add `_build_arsenal_suggestions(self, vuln_type: str, target: str) -> str` method:
  - Call `_get_relevant_arsenal_items(vuln_type, target)`
  - If none, return empty string
  - Build formatted section:
    ```
    ðŸ’° **FROM YOUR ARSENAL** (previously obtained):
    - credential: admin:password123 (from: SQLi at /rest/user/login)
      â†’ Try: `curl -u admin:password123 http://target/admin`
    ```
  - Cap at 3 items to avoid message bloat
  - Return the formatted string

- [ ] T011 [US-3] Add `_build_arsenal_summary(self) -> str` method:
  - Build a compact summary of ALL arsenal items (for context injection)
  - Format: category headers with bullet points
  - Cap at 1000 chars total
  - Used in reset/resume context injection

- [ ] T012 [US-3] Integrate arsenal suggestions into `_get_exploit_push_message()`:
  - At end of method, get current focus vuln's type and target
  - Call `_build_arsenal_suggestions(vuln_type, target)`
  - Append to push message if non-empty

- [ ] T013 [US-3] Integrate arsenal suggestions into exploit-only hard gate reprompt (near line ~2900):
  - In the reprompt message builder, append arsenal suggestions
  - Uses same `_build_arsenal_suggestions()` with focus vuln type/target

- [ ] T014 Test: Obtain creds via one vuln, verify they appear in exploit push for next vuln

**Checkpoint**: Arsenal items suggested during exploitation attempts

## Phase 4: Chain Tracking

- [ ] T015 [US-4] Add `_record_chain_link(self, from_vuln: str, artifact_type: str, to_vuln: str)` method:
  - Create chain entry: `{from_vuln, artifact_type, to_vuln, iteration, timestamp}`
  - Append to `self.exploit_chains`
  - Call `self._save_chains()`
  - Log: `"ðŸ”— CHAIN: {from_vuln} â†’ [{artifact_type}] â†’ {to_vuln}"`

- [ ] T016 [US-4] Detect chain usage in `_mark_vuln_proven()`:
  - When a vuln is proven, check if the proof command used an arsenal item
  - Check: does the proof command text contain any arsenal `value` from a DIFFERENT source_vuln?
  - If match found: call `_record_chain_link(source_vuln, artifact_type, proven_vuln)`
  - Also mark the arsenal item's `used_in` list with the proven vuln id

- [ ] T017 [US-4] Add chain summary to context:
  - In `_build_arsenal_summary()`, append chain section if chains exist:
    ```
    ðŸ”— EXPLOIT CHAINS:
    - SQLi â†’ [credential] â†’ Admin Panel Access
    - LFI â†’ [secret] â†’ Database Dump
    ```
  - Include in context digest (Spec 008 CREDENTIALS section)

- [ ] T018 Test: Exploit vuln A â†’ get creds â†’ use creds to exploit vuln B â†’ verify chain recorded

**Checkpoint**: Exploit chains tracked and visible

## Phase 5: Persistence & Context Integration

- [ ] T019 [US-5] Integrate arsenal into Spec 008 context digest (`_merge_digest`):
  - In the CREDENTIALS & TOKENS section of digest, include arsenal state
  - Arsenal data is authoritative (replaces, not supplements, the LLM-generated cred summary)
  - Credentials: full `user:pass @ service` for all entries (never truncate creds)
  - Tokens: first 50 chars + `...` (truncated for space)
  - API keys: first 30 chars + `...`
  - Cap arsenal section at 1000 chars in digest

- [ ] T020 [US-5] Inject arsenal into `_reset_conversation()` (line ~597):
  - After system prompt and digest (if Spec 008 active), inject arsenal summary
  - Message: `"**OBTAINED ARTIFACTS (preserved through reset)**\n\n{arsenal_summary}"`
  - Insert at position 2 (after system prompt + digest)

- [ ] T021 [US-5] Inject arsenal into session resume (lines 2624-2660):
  - After trimmed conversation is built, inject arsenal summary
  - Message: `"**OBTAINED ARTIFACTS (from previous session)**\n\n{arsenal_summary}"`
  - Insert at position 2

- [ ] T022 Test: Context trim â†’ verify arsenal survives in digest; reset â†’ verify arsenal injected; resume â†’ verify arsenal loaded from disk

**Checkpoint**: Arsenal persists through ALL context management events

## Phase 6: Spec 009 Integration & Polish

- [ ] T023 Integrate arsenal into Spec 009's `_auto_pivot_after_proof()`:
  - When building pivot message for next vuln, append arsenal suggestions
  - Call `_build_arsenal_suggestions(next_vuln_type, next_target)`
  - Include chain hint: "Check if credentials/tokens from {proven_vuln} work against {next_target}"

- [ ] T024 Integrate arsenal into immediate exploit trigger (Spec 009's `_process_immediate_exploit_queue()`):
  - When building trigger message for new vuln, check arsenal for relevant items
  - If found, include: "ðŸ’° You already have artifacts that may help exploit this"

- [ ] T025 Run full Juice Shop job end-to-end:
  - Verify arsenal populates with creds/tokens during exploitation
  - Verify arsenal suggestions appear in exploit push messages
  - Verify at least 1 exploit chain is recorded
  - Verify arsenal survives context trims
  - Measure improvement: target â‰¥1 additional proven exploit from chains vs baseline

- [ ] T026 Document changes in commit message referencing spec 010

## Dependencies

- T001, T002, T003 â†’ T005 (infrastructure before extraction)
- T005, T006 â†’ T007 (extraction methods before integration)
- T009, T010, T011 â†’ T012, T013 (suggestion methods before push integration)
- T015 â†’ T016 â†’ T017 (chain tracking pipeline)
- T019, T020, T021 depend on Spec 008 being implemented (soft dep â€” degrade gracefully)
- T023, T024 depend on Spec 009 being implemented (soft dep â€” skip if not available)
- Phase 6 depends on all above
- Spec 006 (`_get_exploit_templates_for_vuln()`) complements but is not required
