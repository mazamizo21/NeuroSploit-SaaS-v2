# Spec 010: Exploit Chain Memory (Cross-Iteration Intelligence)

**Feature Branch**: `010-exploit-chain-memory`
**Created**: 2026-02-08
**Status**: Draft
**Dependencies**: Builds on Spec 008 (context digest persistence), Spec 009 (auto-pivot with chain hints)

## Problem Statement

The Dynamic Agent discovers reusable artifacts (credentials, JWT tokens, API keys, session cookies, access levels) during exploitation but doesn't systematically use them to chain attacks. These artifacts are either:

1. **Lost in context trims**: Credentials found at iteration 15 are trimmed at iteration 60 and rediscovered at iteration 80
2. **Never applied cross-vuln**: JWT from SQLi is never used to access admin endpoints; DB passwords from config files are never used to login to databases
3. **Not tracked structurally**: Artifacts exist only in free-form conversation text, not in a searchable structure
4. **No chain reasoning**: The agent doesn't connect "creds from vuln A" â†’ "access to service B" â†’ "new vuln C"

### Examples of Missed Chains

1. **SQLi â†’ Token â†’ Admin Access**: Agent dumps JWT tokens via SQL injection but never uses them to authenticate to admin API endpoints
2. **LFI â†’ Config â†’ DB Access**: Agent reads `/etc/app/config.yml` via path traversal, sees DB password, but never connects to the database
3. **IDOR â†’ User List â†’ Credential Stuffing**: Agent dumps usernames via IDOR but never tries them against login forms
4. **Directory Listing â†’ Source Code â†’ Hardcoded Secrets**: Agent finds `.env` file but never uses the API keys found within

### Impact

From observed runs:
- Agent found admin credentials via SQLi at iteration 20, never used them for admin panel access
- Agent discovered JWT signing key at iteration 45, never forged tokens
- Estimated **3-5 additional proven exploits per run** possible if chains were followed

## Goals

1. **Arsenal tracking**: Maintain a structured store of all obtained artifacts (creds, tokens, keys, sessions)
2. **Automatic extraction**: Parse exploit output for reusable artifacts after each successful command
3. **Chain suggestion**: When pivoting to next vuln, suggest how arsenal items could help
4. **Arsenal persistence**: Survives context trims via Spec 008 digest integration
5. **Chain visualization**: Track which artifact came from which exploit and enabled which next step

## User Stories

### US-1: Arsenal â€” Structured Artifact Store

**As a** Dynamic Agent accumulating exploit results,
**I want** a structured store of all obtained credentials, tokens, and access levels,
**So that** I can reference them when attempting new exploits.

**Acceptance Criteria:**
- [ ] `self.arsenal` dict with categories: `credentials`, `tokens`, `api_keys`, `sessions`, `access_levels`, `endpoints`, `secrets`
- [ ] Each artifact has: `value`, `source_vuln`, `source_iteration`, `used_in`, `artifact_type`
- [ ] Arsenal persisted to `{log_dir}/arsenal.json` for crash recovery
- [ ] Arsenal loaded on session resume
- [ ] Arsenal state included in context digest (Spec 008)
- [ ] Arsenal capped at 100 entries (prune oldest low-value items)

### US-2: Automatic Artifact Extraction

**As a** Dynamic Agent that just ran a successful exploit command,
**I want** reusable artifacts to be automatically extracted from the output,
**So that** I don't have to rely on the LLM to remember and re-use them.

**Acceptance Criteria:**
- [ ] After each command execution, scan stdout for artifact patterns
- [ ] Extract credentials: `username:password` pairs, `user=X&pass=Y` patterns, JSON `{"username":"X","password":"Y"}`
- [ ] Extract tokens: JWT tokens (`eyJ...`), Bearer tokens, API keys (`sk-`, `ak-`, `AKIA`)
- [ ] Extract sessions: cookies (`Set-Cookie:`), session IDs
- [ ] Extract secrets: database connection strings, config file contents with passwords
- [ ] Each extracted artifact logged: `"ðŸ”‘ ARSENAL: Found {type} from {command}"`
- [ ] Extraction is regex-based (no LLM call â€” must be fast and reliable)
- [ ] False positive rate acceptable (better to capture too much than miss creds)

### US-3: Chain-Aware Exploit Suggestions

**As a** Dynamic Agent pivoting to a new vulnerability,
**I want** to know which arsenal items are relevant to the next target,
**So that** I can chain attacks using previously obtained access.

**Acceptance Criteria:**
- [ ] When `_auto_pivot_after_proof()` (Spec 009) generates a pivot message, it includes relevant arsenal items
- [ ] Relevance matching: credential for same target/service, token type matching endpoint requirements, DB creds for DB vulns
- [ ] Suggestion format: "ðŸ’° FROM YOUR ARSENAL: You have admin JWT token (from SQLi). Try: `curl -H 'Authorization: Bearer {token}' http://target/api/admin`"
- [ ] When exploit gate fires, include relevant arsenal items in the push message
- [ ] Arsenal items are referenced by type and source, not just raw values

### US-4: Chain Tracking

**As a** security analyst reviewing the pentest,
**I want** to see how exploits were chained (artifact from A enabled B, which revealed C),
**So that** the report shows attack path depth.

**Acceptance Criteria:**
- [ ] `self.exploit_chains` list tracks: `{from_vuln, artifact, to_vuln, iteration}`
- [ ] When an arsenal item is used in a successful exploit, the chain link is recorded
- [ ] Chain data saved to `{log_dir}/exploit_chains.json`
- [ ] Chain data included in the comprehensive report
- [ ] Chain summary in context digest: "CHAINS: SQLiâ†’JWTâ†’AdminAccessâ†’DataDump"

### US-5: Arsenal Persistence Across Trims

**As a** Dynamic Agent experiencing context trims,
**I want** my arsenal to survive all trims and resets,
**So that** I never lose track of obtained credentials and tokens.

**Acceptance Criteria:**
- [ ] Arsenal is saved to disk after every artifact addition
- [ ] Arsenal is loaded from disk on startup and session resume
- [ ] Arsenal summary included in Spec 008 context digest (CREDENTIALS & TOKENS section)
- [ ] On context reset (`_reset_conversation`), arsenal is injected as context
- [ ] Arsenal entries are never pruned from digest (highest priority data)

## Requirements

### Functional Requirements

- **FR-001**: System MUST maintain an arsenal of extracted artifacts
- **FR-002**: System MUST auto-extract artifacts from command output after each execution
- **FR-003**: System MUST include relevant arsenal items in exploit push/pivot messages
- **FR-004**: System MUST track exploit chains (artifact provenance)
- **FR-005**: Arsenal MUST persist across context trims, resets, and session resumes
- **FR-006**: Arsenal MUST be saved to disk for crash recovery
- **FR-007**: System MUST match arsenal items to target vulns by relevance
- **FR-008**: Arsenal extraction MUST be regex-based (no LLM calls)

### Non-Functional Requirements

- **NFR-001**: Artifact extraction MUST complete within 100ms per command output
- **NFR-002**: Arsenal storage MUST not exceed 50KB on disk
- **NFR-003**: Arsenal summary in digest MUST not exceed 1000 chars
- **NFR-004**: Must work with ANY LLM provider

## Success Criteria

- **SC-001**: Agent uses credentials from vuln A to exploit vuln B in â‰¥1 chain per run
- **SC-002**: Arsenal contains â‰¥5 artifacts after a Juice Shop run (baseline: 0 structured artifacts)
- **SC-003**: No credential is ever "lost" â€” once found, always available
- **SC-004**: At least 1 additional proven exploit per run from chain exploitation (vs baseline)
- **SC-005**: Chain data appears in comprehensive report

## Constraints

- ALL changes in `kali-executor/open-interpreter/dynamic_agent.py` only
- Artifact extraction MUST be regex-based (no extra LLM calls)
- Must integrate with Spec 008 digest (arsenal â†’ digest CREDENTIALS section)
- Must integrate with Spec 009 pivot messages (arsenal â†’ chain suggestions)
- Must work with weak LLMs â€” chain suggestions must be explicit commands, not hints
- Must handle credential redaction properly â€” full creds in arsenal, redacted in logs/UI
