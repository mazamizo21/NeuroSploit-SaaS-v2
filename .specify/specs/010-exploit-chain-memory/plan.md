# Plan: 010 Exploit Chain Memory (Cross-Iteration Intelligence)

**Branch**: `010-exploit-chain-memory` | **Date**: 2026-02-08 | **Spec**: spec.md

## Summary

Implement an "arsenal" system that automatically extracts reusable artifacts (credentials, tokens, keys) from command output, stores them structurally, suggests them during exploit pivots, and tracks exploit chains across the entire run. Arsenal persists through context trims via integration with Spec 008's digest.

## Technical Context

**Language/Version**: Python 3.11+
**Primary File**: `kali-executor/open-interpreter/dynamic_agent.py` (~4673 lines)
**Key Code Locations**:
- Lines 83-120: `_summarize_evidence()` â€” reads evidence JSON files (arsenal complements this)
- Lines 345-460: `__init__` â€” state variables
- Lines 597-640: `_reset_conversation()` â€” needs arsenal injection
- Lines 2710-2760: Context pack â€” arsenal feeds into digest
- Lines 3605-3675: `_track_vuln_found()` / `_mark_vuln_proven()` â€” chain tracking hooks
- Post-execution code (after command runs) â€” artifact extraction hook
**Dependencies**: Spec 008 (digest), Spec 009 (auto-pivot)

## Constitution Check

- âœ… Evidence-First Exploitation â€” arsenal provides evidence-backed artifacts, not guesses
- âœ… No Hardcoded Exploits â€” chain suggestions are artifact-driven, not hardcoded paths
- âœ… Separation of Concerns â€” changes limited to Kali Plane
- âœ… Defense-in-Depth Redaction â€” arsenal values follow existing redaction rules for logs/UI

## Changes Required

All changes in `kali-executor/open-interpreter/dynamic_agent.py`:

### 1. New State Variables in `__init__` (line ~380)

```python
# Exploit chain memory / Arsenal (Spec 010)
self.arsenal: Dict[str, List[Dict]] = {
    "credentials": [],
    "tokens": [],
    "api_keys": [],
    "sessions": [],
    "access_levels": [],
    "secrets": [],
}
self.arsenal_path = os.path.join(self.log_dir, "arsenal.json")
self.max_arsenal_entries = int(os.getenv("MAX_ARSENAL_ENTRIES", "100"))
self.exploit_chains: List[Dict] = []
self.exploit_chains_path = os.path.join(self.log_dir, "exploit_chains.json")
# Load persisted arsenal on startup
if os.path.exists(self.arsenal_path):
    try:
        self.arsenal = json.load(open(self.arsenal_path))
    except Exception:
        pass
if os.path.exists(self.exploit_chains_path):
    try:
        self.exploit_chains = json.load(open(self.exploit_chains_path))
    except Exception:
        pass
```

### 2. Artifact Extraction Patterns (module-level constant)

```python
ARTIFACT_PATTERNS = {
    "credentials": [
        # JSON credentials: {"username":"X","password":"Y"}
        r'"(?:user(?:name)?|login|email)":\s*"([^"]+)".*?"(?:pass(?:word)?|pwd)":\s*"([^"]+)"',
        # Colon-separated: admin:password123
        r'(?:username|user|login|email)[=:]\s*(\S+)[\s,;]+(?:password|pass|pwd)[=:]\s*(\S+)',
        # HTTP basic auth decoded
        r'Authorization:\s*Basic\s+(\S+)',
        # /etc/shadow or /etc/passwd entries
        r'(\w+):(\$\d+\$[^:]+):\d+:\d+',
    ],
    "tokens": [
        # JWT tokens
        r'(eyJ[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,}\.[A-Za-z0-9_-]{10,})',
        # Bearer tokens
        r'Bearer\s+([A-Za-z0-9_.-]{20,})',
        # Generic auth tokens
        r'(?:auth|access|refresh)[_-]?token["\s:=]+([A-Za-z0-9_.-]{20,})',
    ],
    "api_keys": [
        # AWS access keys
        r'(AKIA[A-Z0-9]{16})',
        # Generic API keys
        r'(?:api[_-]?key|apikey|secret[_-]?key)["\s:=]+([A-Za-z0-9_.-]{16,})',
        # Stripe keys
        r'(sk_(?:live|test)_[A-Za-z0-9]{24,})',
    ],
    "sessions": [
        # Set-Cookie with session
        r'Set-Cookie:\s*(\w+=[A-Za-z0-9%._-]{16,})',
        # PHPSESSID, JSESSIONID
        r'((?:PHPSESSID|JSESSIONID|session_id|sid|connect\.sid)=[A-Za-z0-9%._-]{16,})',
    ],
    "secrets": [
        # Database connection strings
        r'(?:mysql|postgres|mongodb)://(\S+:\S+@\S+)',
        # Config file passwords
        r'(?:DB_PASS(?:WORD)?|SECRET_KEY|JWT_SECRET|ENCRYPTION_KEY)["\s:=]+([^\s"]{8,})',
    ],
}
```

### 3. New Method: `_extract_artifacts(self, command: str, stdout: str, stderr: str) -> List[Dict]`

**Purpose**: Scan command output for reusable artifacts using regex patterns.

```python
def _extract_artifacts(self, command: str, stdout: str, stderr: str) -> List[Dict]:
    """Extract reusable artifacts (creds, tokens, keys) from command output."""
```

**Algorithm**:
1. Combine stdout + stderr into search text
2. For each category in `ARTIFACT_PATTERNS`, run all regex patterns
3. For each match, create artifact dict:
   ```python
   {
       "value": matched_value,
       "source_command": command[:200],
       "source_iteration": self.iteration,
       "source_vuln": self.current_vuln_focus_id or "",
       "used_in": [],
       "extracted_at": datetime.now().isoformat(),
   }
   ```
4. Deduplicate: skip if same value already in arsenal category
5. Return list of new artifacts

**Performance**: Regex-only, no LLM calls. Expected <50ms per command output.

### 4. New Method: `_add_to_arsenal(self, artifact_type: str, artifact: Dict)`

```python
def _add_to_arsenal(self, artifact_type: str, artifact: Dict):
    """Add artifact to arsenal, persist, and log."""
```

- Append to `self.arsenal[artifact_type]`
- If total entries > `max_arsenal_entries`, prune oldest `sessions` first, then `access_levels`
- Never prune `credentials` or `tokens`
- Call `self._save_arsenal()`
- Log: `"ðŸ”‘ ARSENAL: Found {type} from iteration {N}"`

### 5. New Method: `_save_arsenal(self)` and `_save_chains(self)`

```python
def _save_arsenal(self):
    """Persist arsenal to disk."""
    try:
        with open(self.arsenal_path, "w") as f:
            json.dump(self.arsenal, f, indent=2, default=str)
    except Exception:
        pass

def _save_chains(self):
    """Persist exploit chains to disk."""
    try:
        with open(self.exploit_chains_path, "w") as f:
            json.dump(self.exploit_chains, f, indent=2, default=str)
    except Exception:
        pass
```

### 6. Integration: Post-Execution Artifact Extraction

**Location**: In the main loop, after command execution and output capture, before feedback building.

```python
# After command execution, before _build_feedback:
try:
    new_artifacts = self._extract_artifacts(command, stdout, stderr)
    for artifact_type, artifact in new_artifacts:
        self._add_to_arsenal(artifact_type, artifact)
except Exception:
    pass
```

### 7. New Method: `_get_relevant_arsenal_items(self, vuln_type: str, target: str) -> List[Dict]`

**Purpose**: Find arsenal items relevant to a specific vuln/target for chain suggestions.

```python
def _get_relevant_arsenal_items(self, vuln_type: str, target: str) -> List[Dict]:
    """Find arsenal items that could help exploit a specific vuln at a target."""
```

**Relevance matching**:
- Credentials: match if target overlaps OR if service type matches (e.g., DB creds for DB-related vulns)
- Tokens: always relevant for API/web targets (JWT, Bearer)
- API keys: relevant for API endpoints
- Sessions: relevant for same target
- Secrets: DB connection strings relevant for data access vulns

Returns list of `{"type": str, "value": str, "source": str, "suggestion": str}` where `suggestion` is a concrete command using the artifact.

### 8. New Method: `_build_arsenal_suggestions(self, vuln_type: str, target: str) -> str`

**Purpose**: Build a human-readable arsenal section for exploit push messages.

```python
def _build_arsenal_suggestions(self, vuln_type: str, target: str) -> str:
    """Build arsenal-based exploit suggestions for a vuln."""
    relevant = self._get_relevant_arsenal_items(vuln_type, target)
    if not relevant:
        return ""
    
    msg = "ðŸ’° **FROM YOUR ARSENAL** (previously obtained):\n"
    for item in relevant[:3]:
        msg += f"- {item['type']}: {item['value'][:50]}... (from: {item['source']})\n"
        if item.get('suggestion'):
            msg += f"  â†’ Try: `{item['suggestion']}`\n"
    return msg
```

### 9. Integration: Exploit Push & Pivot Messages

**Modify `_get_exploit_push_message()`**: Append arsenal suggestions.
```python
arsenal_section = self._build_arsenal_suggestions(vuln_type, target)
if arsenal_section:
    push_msg += f"\n\n{arsenal_section}"
```

**Modify `_auto_pivot_after_proof()` (Spec 009)**: Include arsenal items relevant to the NEXT vuln.
```python
arsenal_section = self._build_arsenal_suggestions(next_type, next_target)
if arsenal_section:
    pivot_msg += f"\n\n{arsenal_section}"
```

**Modify exploit-only hard gate reprompt (line ~2900)**: Include arsenal items.

### 10. New Method: `_record_chain_link(self, from_vuln: str, artifact_type: str, to_vuln: str)`

```python
def _record_chain_link(self, from_vuln: str, artifact_type: str, to_vuln: str):
    """Record an exploit chain link: artifact from one vuln used in another."""
    self.exploit_chains.append({
        "from_vuln": from_vuln,
        "artifact_type": artifact_type,
        "to_vuln": to_vuln,
        "iteration": self.iteration,
        "timestamp": datetime.now().isoformat(),
    })
    self._save_chains()
    self._log(f"ðŸ”— CHAIN: {from_vuln} â†’ [{artifact_type}] â†’ {to_vuln}", "INFO")
```

**Chain detection**: In `_mark_vuln_proven()`, if `current_vuln_focus_id` was exploited using an arsenal item that came from a different vuln, record the chain.

### 11. Arsenal in Context Digest (Spec 008 Integration)

In `_merge_digest()` (Spec 008), always include arsenal state in the CREDENTIALS & TOKENS section:

```python
# In _merge_digest, after section merge:
arsenal_lines = []
for cred in self.arsenal.get("credentials", [])[:10]:
    arsenal_lines.append(f"- credential: {cred['value']} (from iter {cred['source_iteration']})")
for token in self.arsenal.get("tokens", [])[:5]:
    arsenal_lines.append(f"- token: {token['value'][:50]}... (from iter {token['source_iteration']})")
for key in self.arsenal.get("api_keys", [])[:5]:
    arsenal_lines.append(f"- api_key: {key['value'][:30]}... (from iter {key['source_iteration']})")
# Replace CREDENTIALS section with arsenal data (authoritative)
```

### 12. Arsenal in Reset & Resume

In `_reset_conversation()` and session resume, inject arsenal summary alongside digest:

```python
arsenal_summary = self._build_arsenal_summary()
if arsenal_summary:
    self.conversation.insert(2, {  # After system prompt and digest
        "role": "user",
        "content": f"**OBTAINED ARTIFACTS (from previous exploitation)**\n\n{arsenal_summary}"
    })
```

## Method Signatures

```python
# New methods
def _extract_artifacts(self, command: str, stdout: str, stderr: str) -> List[Tuple[str, Dict]]:
def _add_to_arsenal(self, artifact_type: str, artifact: Dict) -> None:
def _save_arsenal(self) -> None:
def _save_chains(self) -> None:
def _get_relevant_arsenal_items(self, vuln_type: str, target: str) -> List[Dict]:
def _build_arsenal_suggestions(self, vuln_type: str, target: str) -> str:
def _build_arsenal_summary(self) -> str:
def _record_chain_link(self, from_vuln: str, artifact_type: str, to_vuln: str) -> None:

# Modified methods
def _get_exploit_push_message(self)  # Add arsenal suggestions
def _auto_pivot_after_proof(self)  # Add arsenal suggestions (Spec 009)
def _reset_conversation(self, ...)  # Add arsenal injection
def _merge_digest(self, ...)  # Add arsenal to CREDENTIALS section (Spec 008)
# Exploit-only hard gate reprompt  # Add arsenal suggestions
# Post-execution code  # Add artifact extraction
```

## Risk Assessment

| Risk | Mitigation |
|------|-----------|
| Regex false positives (random strings matched as tokens) | Accept over-capture; agent will ignore irrelevant items |
| Arsenal too large for context | Summary capped at 1000 chars; only relevant items injected per vuln |
| Sensitive data in arsenal file on disk | Same security as existing evidence files; redacted in logs |
| Chain detection inaccurate | Chains are best-effort; recorded when arsenal item matches context |
| Performance impact of regex scanning | Patterns compiled once; scanning <50ms per output |
| Arsenal stale after target change | Arsenal tagged with source_vuln; relevance matching filters by target |
