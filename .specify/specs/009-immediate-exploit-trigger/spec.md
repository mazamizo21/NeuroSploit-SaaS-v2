# Spec 009: Immediate Exploit Trigger (Findâ†’Exploitâ†’Next)

**Feature Branch**: `009-immediate-exploit-trigger`
**Created**: 2026-02-08
**Status**: Draft
**Dependencies**: Complements Spec 004 (scan loop escape), Spec 006 (exploit templates), Spec 010 (chain memory)

## Problem Statement

The Dynamic Agent has a **reactive** exploit gate â€” it checks every `EXPLOITATION_GATE_COOLDOWN_ITERS` (default 5) iterations for unproven vulnerabilities. When the agent discovers a critical vulnerability, it continues scanning for 5-10 more iterations before being pushed to exploit.

### Current Exploit Gate Flow (lines 2770-2800)

```python
# Periodic check â€” NOT immediate
if pending and (self.iteration - self.exploit_gate_last_push_iter) >= self.exploit_gate_cooldown_iters:
    push_msg = self._get_exploit_push_message()
    self.exploit_gate_last_push_iter = self.iteration
    self.force_exploit_next = True
    self.conversation.append({"role": "user", "content": push_msg})
```

### What Goes Wrong

1. **Momentum loss**: Agent finds SQLi at iteration 12, but exploit gate doesn't fire until iteration 17. By then, context has shifted to other recon tasks.
2. **Context dilution**: 5 iterations of unrelated scanning push the SQLi discovery out of the LLM's attention window.
3. **Iteration waste**: Each wasted iteration costs ~15-60 seconds of LLM time + command execution.
4. **No findâ†’exploit pipeline**: After successful exploitation, agent doesn't automatically pivot to the next unproven vuln. It might go back to scanning.
5. **No chain awareness**: Credentials from vuln A aren't automatically applied to exploit vuln B.

### Key Insight from Taz

> "Once it finds a critical finding, it should have started exploiting it then move to the next finding."

This spec implements exactly that: find â†’ exploit â†’ prove â†’ chain â†’ next.

## Goals

1. **Immediate reaction**: When a NEW HIGH/CRITICAL vuln is tracked, inject an exploit directive on the SAME iteration
2. **Findâ†’Exploitâ†’Next pipeline**: After proof obtained, auto-pivot to next unproven vuln
3. **Interrupt-based, not periodic**: This is a trigger, not a cooldown-based check
4. **Chain-aware pivoting**: After exploit success, check if obtained creds/access enable new attacks before moving to next vuln
5. **Smart resume**: Only resume broad recon when ALL known vulns are either proven or marked not_exploitable

## User Stories

### US-1: Immediate Exploit Trigger on Vuln Discovery

**As a** Dynamic Agent that just discovered a vulnerability,
**I want** to immediately receive an exploit directive for that specific vuln,
**So that** I exploit it while it's fresh in context and I have momentum.

**Acceptance Criteria:**
- [ ] After `_track_vuln_found()` registers a NEW vuln (not a duplicate), an exploit trigger fires
- [ ] Trigger only fires for new entries (not when an existing vuln is re-detected)
- [ ] Trigger injects a user message: "ðŸŽ¯ NEW VULN FOUND: {type} at {target}. EXPLOIT IT NOW."
- [ ] Trigger includes specific command templates for the vuln type (from Spec 006's `_get_exploit_templates_for_vuln()`)
- [ ] Trigger sets `force_exploit_next = True` to engage the exploit-only hard gate
- [ ] Trigger does NOT respect the cooldown timer â€” it's an interrupt
- [ ] Trigger only fires for HIGH/CRITICAL severity (not informational/low findings)

### US-2: Auto-Pivot After Successful Exploitation

**As a** Dynamic Agent that just proved a vulnerability,
**I want** to automatically pivot to the next unproven vulnerability,
**So that** I maintain exploit momentum instead of reverting to scanning.

**Acceptance Criteria:**
- [ ] After `_mark_vuln_proven()` succeeds, system checks for remaining unproven vulns
- [ ] If unproven vulns exist, inject a pivot directive: "âœ… PROVEN: {vuln}. NEXT TARGET: {next_vuln}. Exploit it now."
- [ ] Pivot directive includes command templates for the next vuln
- [ ] If NO unproven vulns remain, inject: "All known vulns exploited. Resume reconnaissance for new attack vectors."
- [ ] Pivot includes any relevant chain artifacts (creds from just-proven vuln that apply to next target)

### US-3: Not-Exploitable Escalation and Resume

**As a** Dynamic Agent stuck on an unexploitable vuln,
**I want** to mark it as not-exploitable after exhausting techniques and move on,
**So that** I don't waste iterations on a dead end.

**Acceptance Criteria:**
- [ ] After `EXPLOITATION_PROOF_MAX_ATTEMPTS_PER_VULN` (default 5) failed attempts with â‰¥3 unique techniques, mark as not_exploitable
- [ ] Auto-pivot to next unproven vuln if one exists
- [ ] If all vulns are either proven or not_exploitable, resume broad recon
- [ ] Log clearly: "VULN EXHAUSTED: {vuln} after {N} attempts with {techniques}. Moving on."

### US-4: Severity-Based Priority

**As a** Dynamic Agent with multiple unproven vulns,
**I want** to exploit the highest-severity one first,
**So that** I maximize impact per iteration.

**Acceptance Criteria:**
- [ ] `_pick_next_unproven_vuln_id()` prioritizes: CRITICAL > HIGH > MEDIUM > LOW
- [ ] Within same severity, prefer vulns with fewer attempts (fresh targets)
- [ ] Within same severity + attempts, prefer vulns found more recently (fresher context)

## Requirements

### Functional Requirements

- **FR-001**: System MUST inject exploit directive immediately when a NEW HIGH/CRITICAL vuln is tracked
- **FR-002**: Immediate trigger MUST bypass the `exploit_gate_cooldown_iters` timer
- **FR-003**: After proof obtained, system MUST auto-pivot to next unproven vuln
- **FR-004**: After all vulns proven/exhausted, system MUST signal recon resume
- **FR-005**: Vuln priority MUST be severity-based (CRITICAL > HIGH > MEDIUM > LOW)
- **FR-006**: Immediate trigger MUST set `force_exploit_next = True` and `current_vuln_focus_id`
- **FR-007**: Immediate trigger MUST include vuln-type-specific command templates
- **FR-008**: System MUST track the trigger state to avoid re-triggering for the same vuln

### Non-Functional Requirements

- **NFR-001**: Trigger MUST fire within the same iteration as vuln discovery (no delay)
- **NFR-002**: Trigger MUST NOT add LLM calls (it's just a message injection)
- **NFR-003**: Must work with existing exploit-only hard gate (complement, not conflict)

## Success Criteria

- **SC-001**: Time from vuln discovery to first exploit attempt â‰¤2 iterations (vs 5-10 baseline)
- **SC-002**: Agent achieves â‰¥4 proven exploits per Juice Shop run (vs 0-1 baseline)
- **SC-003**: Zero "idle" iterations between vuln proof and next vuln attempt
- **SC-004**: Agent tries all known vulns before resuming broad recon
- **SC-005**: Agent exploits CRITICAL/HIGH vulns before MEDIUM/LOW

## Constraints

- ALL changes in `kali-executor/open-interpreter/dynamic_agent.py` only
- Must coexist with existing exploit gate (periodic check still runs as safety net)
- Must not conflict with scan loop detection (Spec 004)
- Must work with weak LLMs â€” trigger messages must be clear and direct
- Must handle edge case: vuln discovered during an already-forced exploit phase
