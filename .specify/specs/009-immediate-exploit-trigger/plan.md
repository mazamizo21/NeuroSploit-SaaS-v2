# Plan: 009 Immediate Exploit Trigger (Findâ†’Exploitâ†’Next)

**Branch**: `009-immediate-exploit-trigger` | **Date**: 2026-02-08 | **Spec**: spec.md

## Summary

Replace the periodic exploit gate cooldown with an interrupt-based trigger that fires immediately when a new vulnerability is discovered. Implement a findâ†’exploitâ†’proveâ†’pivotâ†’next pipeline so the agent exploits each vuln at discovery time and chains through all known vulns before resuming recon.

## Technical Context

**Language/Version**: Python 3.11+
**Primary File**: `kali-executor/open-interpreter/dynamic_agent.py` (~4673 lines)
**Key Code Locations**:
- Lines 2770-2800: Periodic exploit gate (cooldown-based) â€” complement, not replace
- Lines 2875-2960: Exploit-only hard gate (blocks non-exploit commands)
- Lines 3545-3600: `_scan_loop_detected()` â€” existing scan loop detection
- Lines 3605-3675: `_track_vuln_found()` â€” where new vulns are registered â†’ trigger point
- Lines 3660-3700: `_mark_vuln_exploited()` / `_mark_vuln_proven()` â†’ pivot point
- Lines 345-460: `__init__` â€” state vars for exploit gate

## Constitution Check

- âœ… Evidence-First Exploitation â€” accelerates exploitation, does not weaken proof gate
- âœ… No Hardcoded Exploits â€” trigger uses template suggestions, not hardcoded paths
- âœ… Separation of Concerns â€” changes limited to Kali Plane
- âœ… Supervisor Independence â€” complements supervisor, doesn't replace it

## Changes Required

All changes in `kali-executor/open-interpreter/dynamic_agent.py`:

### 1. New State Variables in `__init__` (line ~380)

```python
# Immediate exploit trigger (Spec 009)
self.immediate_exploit_queue: List[str] = []  # vuln_ids pending immediate exploitation
self.triggered_vuln_ids: set = set()  # vulns that have already triggered (no re-trigger)
self.last_proof_iteration: int = 0  # iteration of last successful proof
self.exploit_pipeline_active: bool = False  # True when in findâ†’exploitâ†’next pipeline
self.all_vulns_resolved: bool = False  # True when all vulns proven or not_exploitable
```

### 2. Modified: `_track_vuln_found()` (line ~3605)

**Change**: After a NEW vuln is registered (not a duplicate), queue it for immediate exploitation.

```python
# At the end of _track_vuln_found, after self._save_vuln_tracker():
# NEW: Queue for immediate exploitation (Spec 009)
if vuln_id not in self.triggered_vuln_ids:
    severity = self._estimate_vuln_severity(vuln_type)
    if severity in ("critical", "high"):
        self.immediate_exploit_queue.append(vuln_id)
        self.triggered_vuln_ids.add(vuln_id)
        self._log(f"ðŸŽ¯ IMMEDIATE EXPLOIT QUEUED: {vuln_type} at {target} ({severity})", "INFO")
```

### 3. New Method: `_estimate_vuln_severity(self, vuln_type: str) -> str`

**Purpose**: Estimate severity from vuln type string for prioritization.

```python
def _estimate_vuln_severity(self, vuln_type: str) -> str:
    """Estimate vuln severity from type. Returns: critical, high, medium, low."""
    vt = vuln_type.lower()
    critical = ["rce", "command injection", "remote code execution", "deserialization", "ssrf"]
    high = ["sql injection", "sqli", "authentication bypass", "auth bypass", "file upload",
            "path traversal", "lfi", "rfi", "xxe", "ssti", "prototype pollution"]
    medium = ["xss", "cross-site scripting", "idor", "information disclosure",
              "directory listing", "mass assignment", "csrf"]
    for pattern in critical:
        if pattern in vt:
            return "critical"
    for pattern in high:
        if pattern in vt:
            return "high"
    for pattern in medium:
        if pattern in vt:
            return "medium"
    return "low"
```

### 4. New Method: `_process_immediate_exploit_queue(self) -> Optional[str]`

**Purpose**: Check the immediate exploit queue and return a trigger message if pending.

```python
def _process_immediate_exploit_queue(self) -> Optional[str]:
    """Process queued immediate exploit triggers. Returns directive message or None."""
    if not self.immediate_exploit_queue:
        return None

    vuln_id = self.immediate_exploit_queue.pop(0)  # FIFO, but we'll re-sort by severity
    vuln = self.vulns_found.get(vuln_id)
    if not vuln or vuln.get("proof") or vuln.get("not_exploitable_reason"):
        return None  # Already proven or exhausted

    vuln_type = vuln.get("type", "unknown")
    target = vuln.get("target", self.target or "unknown")

    msg = f"ðŸŽ¯ **NEW VULNERABILITY FOUND â€” EXPLOIT IMMEDIATELY**\n\n"
    msg += f"Type: **{vuln_type}**\nTarget: {target}\n"
    if vuln.get("details"):
        msg += f"Details: {vuln['details'][:200]}\n"
    msg += "\nDo NOT continue scanning. Exploit this vulnerability RIGHT NOW.\n\n"

    # Include templates if available
    templates = self._get_exploit_templates_for_vuln(vuln_type, target) if hasattr(self, '_get_exploit_templates_for_vuln') else []
    if templates:
        msg += "Recommended exploitation commands:\n"
        for i, tmpl in enumerate(templates[:3], 1):
            msg += f"{i}. ```bash\n{tmpl}\n```\n"
    else:
        msg += "Attempt exploitation with appropriate tools (sqlmap --batch --dump, curl payloads, msfconsole, etc.)\n"

    msg += "\nProvide ONE exploitation command that produces concrete proof output."

    # Set exploit state
    self.force_exploit_next = True
    self.current_vuln_focus_id = vuln_id
    self.exploit_pipeline_active = True

    return msg
```

### 5. Integration: Main Loop â€” Immediate Trigger Check (before periodic gate)

**Location**: In main loop, BEFORE the existing periodic exploit gate check (line ~2770).

```python
# NEW: Immediate exploit trigger (Spec 009) â€” fires BEFORE periodic gate
try:
    immediate_trigger = self._process_immediate_exploit_queue()
    if immediate_trigger:
        self.conversation.append({"role": "user", "content": immediate_trigger})
        self._log(f"IMMEDIATE EXPLOIT TRIGGER fired for {self.current_vuln_focus_id}", "INFO")
except Exception:
    pass
```

**Ordering**: immediate trigger â†’ periodic gate â†’ scan loop detection. The immediate trigger takes priority because it fires for specific new vulns, while the periodic gate is a safety net.

### 6. New Method: `_auto_pivot_after_proof(self) -> Optional[str]`

**Purpose**: After a vuln is proven, auto-pivot to the next unproven vuln.

```python
def _auto_pivot_after_proof(self) -> Optional[str]:
    """Generate pivot message after successful exploitation proof. Called from _mark_vuln_proven."""
    proven_vuln = self.vulns_found.get(self.current_vuln_focus_id, {})
    proven_type = proven_vuln.get("type", "unknown")
    proven_target = proven_vuln.get("target", "unknown")

    pending = self._get_unproven_vulns()
    if not pending:
        self.exploit_pipeline_active = False
        self.all_vulns_resolved = True
        self.force_exploit_next = False
        return (
            f"âœ… ALL KNOWN VULNERABILITIES RESOLVED.\n\n"
            f"Last proven: {proven_type} at {proven_target}\n\n"
            f"Resume reconnaissance to discover new attack vectors. "
            f"Try deeper enumeration, different tools, or unexplored services."
        )

    # Pick next by severity priority
    next_vuln = self._pick_next_unproven_vuln_by_severity()
    next_id = next_vuln.get("_id", "")
    next_type = next_vuln.get("type", "unknown")
    next_target = next_vuln.get("target", "unknown")

    msg = f"âœ… **PROVEN: {proven_type} at {proven_target}** â€” Good work!\n\n"
    msg += f"ðŸŽ¯ **NEXT TARGET: {next_type} at {next_target}**\n\n"

    # Check for chain artifacts (creds from proven vuln applicable to next)
    # Spec 010 will enrich this further
    proof_text = proven_vuln.get("proof", "")
    if any(kw in proof_text.lower() for kw in ["password", "credential", "token", "jwt", "admin"]):
        msg += f"ðŸ’¡ Check if credentials/tokens from {proven_type} can be used against {next_target}.\n\n"

    templates = self._get_exploit_templates_for_vuln(next_type, next_target) if hasattr(self, '_get_exploit_templates_for_vuln') else []
    if templates:
        msg += "Recommended commands:\n"
        for i, tmpl in enumerate(templates[:2], 1):
            msg += f"{i}. ```bash\n{tmpl}\n```\n"

    msg += "\nExploit this vulnerability NOW. Provide proof output."

    self.current_vuln_focus_id = next_id
    self.force_exploit_next = True

    return msg
```

### 7. Modified: `_mark_vuln_proven()` â€” Add Auto-Pivot

**Location**: End of `_mark_vuln_proven()` method.

```python
# At end of _mark_vuln_proven, after saving tracker:
# NEW: Auto-pivot to next vuln (Spec 009)
self.last_proof_iteration = self.iteration
pivot_msg = self._auto_pivot_after_proof()
if pivot_msg:
    self.conversation.append({"role": "user", "content": pivot_msg})
```

### 8. New Method: `_pick_next_unproven_vuln_by_severity(self) -> dict`

**Purpose**: Pick the highest-priority unproven vuln for targeting.

```python
def _pick_next_unproven_vuln_by_severity(self) -> dict:
    """Pick highest-priority unproven vuln. CRITICAL > HIGH > MEDIUM > LOW."""
    severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
    pending = []
    for vid, v in self.vulns_found.items():
        if not isinstance(v, dict):
            continue
        if v.get("proof") or v.get("not_exploitable_reason"):
            continue
        severity = self._estimate_vuln_severity(v.get("type", ""))
        pending.append((severity_order.get(severity, 4), v.get("attempt_count", 0), vid, v))

    if not pending:
        return {}
    pending.sort(key=lambda x: (x[0], x[1]))  # Highest severity first, fewest attempts first
    _, _, vid, vuln = pending[0]
    vuln["_id"] = vid
    return vuln
```

### 9. Modified: Not-Exploitable Auto-Pivot

**Location**: In the existing not_exploitable marking logic.

When a vuln is marked not_exploitable (after max attempts with â‰¥3 techniques), call `_auto_pivot_after_proof()` to move to the next vuln. Same logic, just triggered from exhaustion instead of proof.

### 10. Interaction with Existing Code

**Periodic exploit gate (lines 2770-2800)**: Still runs as a safety net. If the immediate trigger was already processed, `force_exploit_next` is already True and the periodic gate's push is redundant but harmless. The cooldown prevents double-pushing.

**Exploit-only hard gate (lines 2875-2960)**: Works perfectly with immediate trigger â€” once `force_exploit_next = True`, it blocks non-exploit commands regardless of how the flag was set.

**Scan loop detection (line 3545)**: The immediate trigger preempts scan loops â€” vulns get exploited before enum ratio can reach 70%. `_scan_loop_detected()` serves as a fallback for edge cases.

## Method Signatures

```python
# New methods
def _estimate_vuln_severity(self, vuln_type: str) -> str:
def _process_immediate_exploit_queue(self) -> Optional[str]:
def _auto_pivot_after_proof(self) -> Optional[str]:
def _pick_next_unproven_vuln_by_severity(self) -> dict:

# Modified methods
def _track_vuln_found(self, vuln_type, target, details)  # Add queue-on-new
def _mark_vuln_proven(self, ...)  # Add auto-pivot call
```

## Risk Assessment

| Risk | Mitigation |
|------|-----------|
| Trigger interrupts deep recon too early | Only fires for HIGH/CRITICAL, not LOW/INFO findings |
| Queue buildup (many vulns found rapidly) | Queue is FIFO with severity re-sort; only one trigger per iteration |
| Auto-pivot conflicts with current vuln focus | Current focus is overwritten by pivot â€” intentional (proof = done with this vuln) |
| Infinite exploit loop (never resumes recon) | `all_vulns_resolved` flag triggers explicit recon resume |
| False vuln detection triggers premature exploit | Already handled by vuln tracker â€” duplicates don't re-trigger |
