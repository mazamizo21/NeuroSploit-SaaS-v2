# Tasks: 009 Immediate Exploit Trigger (Findâ†’Exploitâ†’Next)

**Input**: spec.md + plan.md
**Target File**: `kali-executor/open-interpreter/dynamic_agent.py`

## Phase 1: Immediate Trigger Infrastructure (MVP)

- [ ] T001 [US-1] Add state variables to `__init__` (near line ~460):
  - `self.immediate_exploit_queue: List[str] = []`
  - `self.triggered_vuln_ids: set = set()`
  - `self.last_proof_iteration: int = 0`
  - `self.exploit_pipeline_active: bool = False`
  - `self.all_vulns_resolved: bool = False`

- [ ] T002 [US-4] Add `_estimate_vuln_severity(self, vuln_type: str) -> str` method:
  - Map vuln type strings to severity levels: critical, high, medium, low
  - Critical: rce, command injection, deserialization, ssrf
  - High: sqli, auth bypass, file upload, path traversal, lfi, rfi, xxe, ssti
  - Medium: xss, idor, information disclosure, directory listing, csrf
  - Low: everything else
  - Case-insensitive matching on vuln_type string

- [ ] T003 [US-1] Modify `_track_vuln_found()` to queue new vulns for immediate exploitation:
  - After the existing `self._save_vuln_tracker()` call (only for NEW vulns, not duplicates)
  - Check: `if vuln_id not in self.triggered_vuln_ids`
  - Estimate severity via `_estimate_vuln_severity(vuln_type)`
  - If severity is `critical` or `high`: append `vuln_id` to `self.immediate_exploit_queue`
  - Add to `self.triggered_vuln_ids` to prevent re-triggering
  - Log: `"ðŸŽ¯ IMMEDIATE EXPLOIT QUEUED: {vuln_type} at {target} ({severity})"`

- [ ] T004 Test: Track a new HIGH vuln, verify it appears in `immediate_exploit_queue`

**Checkpoint**: New vulns are queued for immediate exploitation

## Phase 2: Trigger Message & Main Loop Integration

- [ ] T005 [US-1] Add `_process_immediate_exploit_queue(self) -> Optional[str]` method:
  - Pop first item from `self.immediate_exploit_queue` (FIFO)
  - Look up vuln in `self.vulns_found` â€” skip if already proven or not_exploitable
  - Build trigger message with:
    - "ðŸŽ¯ **NEW VULNERABILITY FOUND â€” EXPLOIT IMMEDIATELY**"
    - Vuln type, target, details
    - Command templates from `_get_exploit_templates_for_vuln()` (if available, else generic)
    - "Provide ONE exploitation command that produces concrete proof output."
  - Set `self.force_exploit_next = True`
  - Set `self.current_vuln_focus_id = vuln_id`
  - Set `self.exploit_pipeline_active = True`
  - Return the message string

- [ ] T006 [US-1] Integrate immediate trigger into main loop:
  - Add BEFORE the existing periodic exploit gate (near line ~2770)
  - Call `self._process_immediate_exploit_queue()`
  - If returns a message, append to conversation
  - This ensures immediate trigger fires BEFORE and INSTEAD OF the periodic gate
  - Wrap in try/except (never crash the main loop)

- [ ] T007 Test: Run job, discover a vuln, verify immediate trigger fires on SAME iteration (not 5 iterations later)

**Checkpoint**: Agent immediately pivots to exploit when vuln is found

## Phase 3: Auto-Pivot After Proof

- [ ] T008 [US-2] Add `_pick_next_unproven_vuln_by_severity(self) -> dict` method:
  - Iterate `self.vulns_found`, filter out proven and not_exploitable
  - Sort by: severity (CRITICAL first) â†’ attempt_count (fewest first) â†’ iteration_found (most recent first)
  - Return the top vuln dict with `_id` key added
  - Return empty dict if no pending vulns

- [ ] T009 [US-2] Add `_auto_pivot_after_proof(self) -> Optional[str]` method:
  - Read current proven vuln from `self.current_vuln_focus_id`
  - Get remaining pending vulns via `_get_unproven_vulns()`
  - If no pending vulns:
    - Set `self.exploit_pipeline_active = False`
    - Set `self.all_vulns_resolved = True`
    - Set `self.force_exploit_next = False`
    - Return "âœ… ALL KNOWN VULNERABILITIES RESOLVED. Resume reconnaissance."
  - If pending vulns exist:
    - Pick next via `_pick_next_unproven_vuln_by_severity()`
    - Build pivot message: "âœ… PROVEN: {prev}. NEXT TARGET: {next}. Exploit it now."
    - Include templates for next vuln
    - Check proof text for chain artifacts (creds, tokens) and mention them
    - Set `self.current_vuln_focus_id` to next vuln
    - Set `self.force_exploit_next = True`
    - Return the pivot message

- [ ] T010 [US-2] Hook `_auto_pivot_after_proof()` into `_mark_vuln_proven()`:
  - At the END of `_mark_vuln_proven()`, after saving tracker
  - Call `self._auto_pivot_after_proof()`
  - If returns a message, append to conversation
  - Set `self.last_proof_iteration = self.iteration`

- [ ] T011 Test: Prove a vuln, verify auto-pivot message appears with next vuln target and commands

**Checkpoint**: Agent chains from proven vuln to next unproven vuln automatically

## Phase 4: Not-Exploitable Escalation

- [ ] T012 [US-3] Hook auto-pivot into not_exploitable marking:
  - Find where vulns are marked `not_exploitable` (in exploit gate logic, near line ~2960)
  - After marking, call `_auto_pivot_after_proof()` (same logic â€” move to next vuln)
  - Log: "VULN EXHAUSTED: {vuln} after {N} attempts with {techniques}. Moving on."

- [ ] T013 [US-3] Ensure not_exploitable requires â‰¥3 unique techniques:
  - Before marking not_exploitable, check `len(vuln.get("techniques_tried", []))  >= 3`
  - If fewer than 3 techniques tried, DON'T mark not_exploitable â€” suggest a different technique instead
  - Existing `exploit_proof_max_attempts_per_vuln` (default 5) still applies for total attempts

- [ ] T014 Test: Run 5 failed attempts with only 2 techniques, verify NOT marked as not_exploitable yet

**Checkpoint**: Exhausted vulns auto-pivot correctly

## Phase 5: Recon Resume Signal

- [ ] T015 [US-2] When `self.all_vulns_resolved` is True and new vulns are found:
  - Reset `self.all_vulns_resolved = False`
  - Reset `self.exploit_pipeline_active = True`
  - Queue the new vuln for immediate exploitation (already handled by T003)

- [ ] T016 [US-2] In scan loop detection (`_scan_loop_detected()`):
  - If `self.all_vulns_resolved` is True, do NOT trigger scan loop warning (scanning is appropriate now)
  - Add: `if self.all_vulns_resolved: return None` at the top

- [ ] T017 Test: Prove all vulns â†’ verify recon resume â†’ find new vuln â†’ verify re-enters exploit pipeline

**Checkpoint**: Pipeline correctly cycles between exploit and recon phases

## Phase 6: Polish & Integration

- [ ] T018 Verify coexistence with existing periodic exploit gate:
  - Immediate trigger should preempt periodic gate (fires first in loop)
  - If immediate trigger sets `force_exploit_next`, periodic gate's push is redundant but harmless
  - Verify no double-push (two exploit messages in same iteration)

- [ ] T019 Verify coexistence with scan loop detection (Spec 004):
  - Immediate trigger should prevent scan loops from accumulating
  - If scan loop detects while exploit pipeline is active, it reinforces rather than conflicts

- [ ] T020 Run full Juice Shop job end-to-end:
  - Measure time from vuln discovery to first exploit attempt (target: â‰¤2 iterations)
  - Measure number of proven exploits (target: â‰¥4)
  - Measure idle iterations between proof and next exploit (target: 0)

- [ ] T021 Document changes in commit message referencing spec 009

## Dependencies

- T001 â†’ T002 â†’ T003 (state vars â†’ severity estimation â†’ queue integration)
- T005 â†’ T006 â†’ T007 (trigger method â†’ loop integration â†’ test)
- T008 â†’ T009 â†’ T010 â†’ T011 (severity picker â†’ pivot â†’ hook â†’ test)
- T012, T013 â†’ T014 (not-exploitable logic â†’ test)
- T015, T016 â†’ T017 (recon resume â†’ test)
- Phase 6 depends on all above
- Spec 006 (`_get_exploit_templates_for_vuln()`) is a soft dependency â€” falls back to generic if not available
- Spec 010 (arsenal) will enrich the chain artifact detection in T009
