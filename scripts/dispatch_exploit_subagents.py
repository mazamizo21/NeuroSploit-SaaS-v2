#!/usr/bin/env python3
"""
Dispatch parallel EXPLOIT subagents for unexploited vulnerabilities.

Usage:
  python scripts/dispatch_exploit_subagents.py --job-id <JOB_UUID>
  python scripts/dispatch_exploit_subagents.py --job-id <JOB_UUID> --max-subagents 4
"""

from __future__ import annotations

import argparse
import json
import os
import subprocess
import sys
from typing import Any, Dict, List, Optional, Tuple

POSTGRES_CONTAINER = os.getenv("TAZO_POSTGRES_CONTAINER", "tazosploit-postgres")
REDIS_CONTAINER = os.getenv("TAZO_REDIS_CONTAINER", "tazosploit-redis")

DEFAULT_KALI_CANDIDATES = (
    os.getenv("TAZO_KALI_CONTAINER"),
    "tazosploit-kali-1",
    "tazosploit-kali-2",
)


def _run(cmd: List[str], check: bool = True, input_data: Optional[str] = None) -> Tuple[str, str, int]:
    proc = subprocess.run(cmd, capture_output=True, text=True, input=input_data)
    if check and proc.returncode != 0:
        raise RuntimeError(
            f"command failed ({proc.returncode}): {' '.join(cmd)}\n{proc.stderr.strip()}"
        )
    return proc.stdout.strip(), proc.stderr.strip(), proc.returncode


def _docker_exec(container: str, args: List[str], check: bool = True) -> Tuple[str, str, int]:
    return _run(["docker", "exec", container, *args], check=check)


def _redis_get(key: str) -> Optional[str]:
    out, _, _ = _docker_exec(REDIS_CONTAINER, ["redis-cli", "GET", key], check=False)
    if not out or out.strip() in ("(nil)", "nil"):
        return None
    return out.strip()


def _psql_query(sql: str) -> str:
    # Use unit separator to avoid collisions with JSON.
    sep = "\x1f"
    out, _, _ = _docker_exec(
        POSTGRES_CONTAINER,
        ["psql", "-q", "-U", "tazosploit", "-d", "tazosploit", "-At", "-F", sep, "-c", sql],
        check=True,
    )
    raw = out.strip()
    if not raw:
        return ""
    lines = [line.strip() for line in raw.splitlines() if line.strip()]
    if len(lines) == 1:
        return lines[0]
    # Prefer UUID-like line if present.
    import re
    for line in lines:
        if re.fullmatch(r"[0-9a-fA-F-]{36}", line):
            return line
    return lines[0]


def _escape_sql(value: str) -> str:
    return value.replace("'", "''")


def _sql_optional(value: Optional[str]) -> str:
    if not value:
        return "NULL"
    return f"'{_escape_sql(value)}'"


def _parse_bool(val: str) -> Optional[bool]:
    if val is None:
        return None
    v = str(val).strip().lower()
    if v in ("t", "true", "1", "yes", "y", "on"):
        return True
    if v in ("f", "false", "0", "no", "n", "off"):
        return False
    if v == "":
        return None
    return None


def _get_parent_job(job_id: str) -> Dict[str, Any]:
    sql = (
        "SELECT tenant_id, scope_id, created_by, name, targets::text, target_type, intensity, "
        "timeout_seconds, max_iterations, authorization_confirmed, exploit_mode, llm_provider, "
        "allow_persistence, allow_defense_evasion, allow_scope_expansion, enable_session_handoff, "
        "enable_target_rotation, target_focus_window, target_focus_limit, target_min_commands "
        f"FROM jobs WHERE id = '{_escape_sql(job_id)}';"
    )
    row = _psql_query(sql)
    if not row:
        raise RuntimeError(f"job not found: {job_id}")
    parts = row.split("\x1f")
    if len(parts) < 20:
        raise RuntimeError(f"unexpected job row format ({len(parts)} fields): {row}")
    (
        tenant_id,
        scope_id,
        created_by,
        name,
        targets_text,
        target_type,
        intensity,
        timeout_seconds,
        max_iterations,
        authorization_confirmed,
        exploit_mode,
        llm_provider,
        allow_persistence,
        allow_defense_evasion,
        allow_scope_expansion,
        enable_session_handoff,
        enable_target_rotation,
        target_focus_window,
        target_focus_limit,
        target_min_commands,
    ) = parts[:20]
    try:
        targets = json.loads(targets_text) if targets_text else []
    except Exception:
        targets = []
    return {
        "tenant_id": tenant_id,
        "scope_id": scope_id,
        "created_by": created_by,
        "name": name,
        "targets": targets,
        "target_type": target_type or "lab",
        "intensity": intensity or "medium",
        "timeout_seconds": int(timeout_seconds or 3600),
        "max_iterations": int(max_iterations or 30),
        "authorization_confirmed": _parse_bool(authorization_confirmed) or False,
        "exploit_mode": exploit_mode or "autonomous",
        "llm_provider": llm_provider or None,
        "allow_persistence": _parse_bool(allow_persistence) or False,
        "allow_defense_evasion": _parse_bool(allow_defense_evasion) or False,
        "allow_scope_expansion": _parse_bool(allow_scope_expansion) or False,
        "enable_session_handoff": _parse_bool(enable_session_handoff) or False,
        "enable_target_rotation": _parse_bool(enable_target_rotation) if enable_target_rotation != "" else True,
        "target_focus_window": int(target_focus_window or 6),
        "target_focus_limit": int(target_focus_limit or 30),
        "target_min_commands": int(target_min_commands or 8),
    }


def _find_kali_container(job_id: str) -> Optional[str]:
    preferred = _redis_get(f"job:{job_id}:kali_container_name")
    candidates = []
    if preferred:
        candidates.append(preferred)
    for cand in DEFAULT_KALI_CANDIDATES:
        if cand:
            candidates.append(cand)
    seen = set()
    for name in candidates:
        if name in seen:
            continue
        seen.add(name)
        _, _, code = _docker_exec(
            name,
            ["test", "-f", f"/pentest/output/{job_id}/vuln_tracker.json"],
            check=False,
        )
        if code == 0:
            return name
    return None


def _load_vuln_tracker(container: str, job_id: str) -> Dict[str, Any]:
    out, _, _ = _docker_exec(container, ["cat", f"/pentest/output/{job_id}/vuln_tracker.json"], check=True)
    if not out.strip():
        return {}
    return json.loads(out)


def _severity_from_type(vuln_type: str) -> str:
    critical = {"Remote Code Execution", "Command Injection", "Remote File Inclusion"}
    high = {
        "SQL Injection",
        "Local File Inclusion",
        "File Upload",
        "Directory Traversal",
        "XML External Entity",
        "Server-Side Request Forgery",
        "Default Credentials",
    }
    medium = {"Cross-Site Scripting", "Cross-Site Request Forgery", "Weak Password"}
    if vuln_type in critical:
        return "critical"
    if vuln_type in high:
        return "high"
    if vuln_type in medium:
        return "medium"
    return "info"


def _collect_candidates(vuln_tracker: Dict[str, Any], include_not_exploitable: bool) -> List[Dict[str, Any]]:
    candidates: List[Dict[str, Any]] = []
    for key, val in vuln_tracker.items():
        if not isinstance(val, dict):
            continue
        if val.get("exploited"):
            continue
        reason = (val.get("not_exploitable_reason") or "").strip()
        if reason and not include_not_exploitable:
            continue
        if val.get("not_exploitable") is True:
            continue
        vtype = val.get("type") or val.get("vuln_type") or val.get("title") or key
        target = val.get("target") or val.get("url") or val.get("endpoint") or ""
        severity = (val.get("severity") or _severity_from_type(str(vtype))).lower()
        attempt_count = int(val.get("attempt_count") or 0)
        iteration_found = int(val.get("iteration_found") or 0)
        candidates.append(
            {
                "key": key,
                "vuln_id": f"{vtype}_{target}".lower().replace(" ", "_"),
                "type": str(vtype),
                "target": str(target),
                "severity": severity,
                "attempt_count": attempt_count,
                "iteration_found": iteration_found,
                "not_exploitable_reason": reason,
            }
        )
    return candidates


def _severity_rank(order: List[str], value: str) -> int:
    try:
        return order.index(value)
    except ValueError:
        return len(order)


def _existing_subjob_count(tenant_id: str, vuln_id: str) -> int:
    pattern = f"%[vuln_id={vuln_id}]%"
    sql = (
        "SELECT count(1) FROM jobs "
        f"WHERE tenant_id = '{_escape_sql(tenant_id)}' "
        "AND status IN ('pending','queued','running') "
        f"AND description LIKE '{_escape_sql(pattern)}';"
    )
    out = _psql_query(sql)
    try:
        return int(out.strip() or 0)
    except Exception:
        return 0


def _insert_subjob(parent: Dict[str, Any], vuln: Dict[str, Any], parent_job_id: str, dry_run: bool) -> Optional[str]:
    desc_lines = [
        f"Exploit focus: {vuln['type']} on {vuln['target']}.",
        f"[vuln_id={vuln['vuln_id']}] [parent_job={parent_job_id}]",
        "Do NOT rerun full recon. Use existing evidence and go straight to exploitation.",
        "MANDATORY toolchain when applicable: searchsploit/exploit-db, msfconsole (with -x or -r), msfvenom.",
        "If exploitation is not possible, mark NOT EXPLOITABLE with a concrete reason and last output.",
        "Require proof: data dump, file read, command execution output, or verifiable artifact in /pentest/output.",
    ]
    description = " ".join(desc_lines)
    name = f"Exploit subagent: {vuln['type']}"

    targets_json = json.dumps(parent["targets"])
    sql = (
        "INSERT INTO jobs (tenant_id, scope_id, created_by, name, description, phase, targets, "
        "target_type, intensity, timeout_seconds, auto_run, max_iterations, authorization_confirmed, "
        "exploit_mode, llm_provider, allow_persistence, allow_defense_evasion, allow_scope_expansion, "
        "enable_session_handoff, enable_target_rotation, target_focus_window, target_focus_limit, "
        "target_min_commands, status) VALUES ("
        f"'{_escape_sql(parent['tenant_id'])}', "
        f"{_sql_optional(parent['scope_id'])}, "
        f"{_sql_optional(parent['created_by'])}, "
        f"'{_escape_sql(name)}', "
        f"'{_escape_sql(description)}', "
        "'EXPLOIT', "
        f"'{_escape_sql(targets_json)}'::jsonb, "
        f"'{_escape_sql(parent['target_type'])}', "
        f"'{_escape_sql(parent['intensity'])}', "
        f"{int(parent['timeout_seconds'])}, "
        "false, "
        f"{int(parent['max_iterations'])}, "
        f"{'true' if parent['authorization_confirmed'] else 'false'}, "
        f"'{_escape_sql(parent['exploit_mode'])}', "
        f"{_sql_optional(parent['llm_provider'])}, "
        f"{'true' if parent['allow_persistence'] else 'false'}, "
        f"{'true' if parent['allow_defense_evasion'] else 'false'}, "
        f"{'true' if parent['allow_scope_expansion'] else 'false'}, "
        f"{'true' if parent['enable_session_handoff'] else 'false'}, "
        f"{'true' if parent['enable_target_rotation'] else 'false'}, "
        f"{int(parent['target_focus_window'])}, "
        f"{int(parent['target_focus_limit'])}, "
        f"{int(parent['target_min_commands'])}, "
        "'pending'"
        ") RETURNING id;"
    )

    if dry_run:
        print(f"[dry-run] would create subjob for {vuln['type']} @ {vuln['target']}")
        return None

    job_id = _psql_query(sql)
    job_id = job_id.strip()
    if not job_id:
        raise RuntimeError("failed to create subjob")
    _docker_exec(REDIS_CONTAINER, ["redis-cli", "LPUSH", f"tenant:{parent['tenant_id']}:job_queue", job_id], check=True)
    return job_id


def _write_vuln_tracker(container: str, job_id: str, data: Dict[str, Any]) -> None:
    payload = json.dumps(data, indent=2)
    _run(
        ["docker", "exec", "-i", container, "sh", "-c", f"cat > /pentest/output/{job_id}/vuln_tracker.json"],
        check=True,
        input_data=payload,
    )


def main() -> int:
    parser = argparse.ArgumentParser(description="Dispatch EXPLOIT subagents for a job")
    parser.add_argument("--job-id", required=True, help="Parent job UUID")
    parser.add_argument("--max-subagents", type=int, default=4, help="Max subagents to spawn (default: 4)")
    parser.add_argument("--severity-order", default="critical,high,medium,low,info", help="Severity order")
    parser.add_argument("--force", action="store_true", help="Ignore existing subjobs for a vuln_id")
    parser.add_argument("--include-not-exploitable", action="store_true", help="Include vulns marked not exploitable")
    parser.add_argument("--reset-not-exploitable", action="store_true", help="Clear not_exploitable_reason before dispatch")
    parser.add_argument("--dry-run", action="store_true", help="Show what would be created")
    args = parser.parse_args()

    severity_order = [s.strip().lower() for s in args.severity_order.split(",") if s.strip()]
    parent = _get_parent_job(args.job_id)
    kali = _find_kali_container(args.job_id)
    if not kali:
        raise RuntimeError("could not locate kali container with vuln_tracker.json")

    vuln_tracker = _load_vuln_tracker(kali, args.job_id)
    include_ne = args.include_not_exploitable or args.reset_not_exploitable
    candidates = _collect_candidates(vuln_tracker, include_ne)
    if not candidates:
        print("No unexploited vulnerabilities found in vuln_tracker.json")
        return 0

    candidates.sort(
        key=lambda v: (
            _severity_rank(severity_order, v["severity"]),
            v["attempt_count"],
            v["iteration_found"],
        )
    )

    created: List[str] = []
    if args.reset_not_exploitable:
        changed = False
        for vuln in candidates:
            if vuln.get("not_exploitable_reason"):
                entry = vuln_tracker.get(vuln["key"])
                if isinstance(entry, dict):
                    entry["not_exploitable_reason"] = ""
                    entry["attempted"] = False
                    entry["attempt_count"] = 0
                    changed = True
        if changed and not args.dry_run:
            _write_vuln_tracker(kali, args.job_id, vuln_tracker)
    for vuln in candidates:
        if len(created) >= args.max_subagents:
            break
        if not args.force and _existing_subjob_count(parent["tenant_id"], vuln["vuln_id"]) > 0:
            continue
        sub_id = _insert_subjob(parent, vuln, args.job_id, args.dry_run)
        if sub_id:
            created.append(sub_id)

    if created:
        print("Created subjobs:")
        for jid in created:
            print(f" - {jid}")
    else:
        print("No subjobs created (all candidates already queued/running).")
    return 0


if __name__ == "__main__":
    sys.exit(main())
