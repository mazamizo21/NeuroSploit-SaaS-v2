"use client";
import { useEffect, useState, useRef, useCallback, useMemo } from "react";
import { useParams, useRouter } from "next/navigation";
import AppShell from "../../AppShell";
import { api, wsUrl } from "@/lib/api";
import { Card, Badge } from "@/components/Card";
import { statusColor, formatDate } from "@/lib/utils";
import { getReportArtifactsWarning } from "@/lib/reportArtifacts";
import { Terminal, RefreshCw, StopCircle, ArrowLeft, Shield, Key, Database, Eye, EyeOff, FileDown, PlayCircle, AlertTriangle, Hash, FileCode } from "lucide-react";
import Link from "next/link";
import { DopamineFeed } from "@/components/DopamineFeed";
import { ProgressRing } from "@/components/ProgressRing";

function MaskedPassword({ password }: { password: string }) {
  const [revealed, setRevealed] = useState(false);
  return (
    <span className="inline-flex items-center gap-1">
      <code className="text-xs bg-black/30 px-1.5 py-0.5 rounded">
        {revealed ? password : "‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"}
      </code>
      <button
        onClick={() => setRevealed(!revealed)}
        className="p-0.5 rounded hover:bg-white/10 transition"
        title={revealed ? "Hide password" : "Show password"}
      >
        {revealed ? <EyeOff className="w-3 h-3" /> : <Eye className="w-3 h-3" />}
      </button>
    </span>
  );
}

function SeverityBadge({ severity }: { severity: string }) {
  const colors: Record<string, string> = {
    critical: "bg-red-600/30 text-red-300 border-red-500/40",
    high: "bg-orange-600/30 text-orange-300 border-orange-500/40",
    medium: "bg-yellow-600/30 text-yellow-300 border-yellow-500/40",
    low: "bg-blue-600/30 text-blue-300 border-blue-500/40",
    info: "bg-gray-600/30 text-gray-300 border-gray-500/40",
  };
  return (
    <span className={`text-[10px] font-bold uppercase px-2 py-0.5 rounded border ${colors[severity] || colors.info}`}>
      {severity}
    </span>
  );
}

function redactSecrets(text: string): string {
  if (!text) return text;
  return text
    // OpenAI/Anthropic-style keys
    .replace(/\bsk-[A-Za-z0-9_-]{10,}\b/g, "sk-***REDACTED***")
    // Bearer tokens
    .replace(/\bBearer\s+[A-Za-z0-9._-]{10,}\b/gi, "Bearer ***REDACTED***")
    // Zhipu/GLM key pattern: <32hex>.<token>
    .replace(/\b[a-f0-9]{32}\.[A-Za-z0-9_-]{10,}\b/gi, "***REDACTED_ZHIPU_KEY***")
    // Header-ish prints
    .replace(/(x-api-key\s*[:=]\s*)[^\s]+/gi, "$1***REDACTED***");
}

/** Filter out noisy SDK/debug log lines that clutter the output */
function isNoisyLine(line: string): boolean {
  const noisy = [
    "httpcore.connection",
    "httpcore.http11",
    "httpx - ",
    "anthropic._base_client - DEBUG",
    "send_request_headers",
    "send_request_body",
    "receive_response_headers",
    "receive_response_body",
    "response_closed",
    "connect_tcp",
    "start_tls",
    "close.started",
    "close.complete",
    "Sending HTTP Request:",
    "HTTP Response:",
    "request_id: req_",
    "Request options:",
    "idempotency_key",
  ];
  return noisy.some((n) => line.includes(n));
}

const lootTypeIcons: Record<string, any> = {
  credential: Key,
  hash: Hash,
  token: Key,
  config: FileCode,
  db_sample: Database,
  session: Key,
};

const lootTypeColors: Record<string, string> = {
  credential: "bg-red-500/20 text-red-400",
  hash: "bg-orange-500/20 text-orange-400",
  token: "bg-yellow-500/20 text-yellow-400",
  config: "bg-blue-500/20 text-blue-400",
  db_sample: "bg-purple-500/20 text-purple-400",
  session: "bg-green-500/20 text-green-400",
};

// ‚îÄ‚îÄ‚îÄ Unified discovery item type ‚îÄ‚îÄ‚îÄ
type DiscoveryCategory = "all" | "vulnerability" | "credential" | "attack_chain" | "database" | "loot";

interface DiscoveryItem {
  id: string;
  category: DiscoveryCategory;
  title: string;
  severity: string;
  description: string;
  evidence?: string;
  extraction_command?: string;
  target?: string;
  iteration?: number;
  finding_type?: string;
  // Credential-specific
  username?: string;
  password?: string;
  service?: string;
  extraction_method?: string;
  verified?: boolean;
  // Database-specific
  db_type?: string;
  host?: string;
  databases?: string[];
  tables_dumped?: string[];
  records_count?: number;
  // Loot-specific
  loot_type?: string;
  source?: string;
  created_at?: string;
}

const categoryConfig: Record<DiscoveryCategory, { label: string; icon: string; color: string; border: string }> = {
  all:          { label: "All",            icon: "üéØ", color: "bg-indigo-600",                                                    border: "" },
  vulnerability:{ label: "Vulnerabilities", icon: "üîì", color: "bg-red-500/20 text-red-300 border border-red-500/30",             border: "border-l-red-500" },
  credential:   { label: "Credentials",    icon: "üîë", color: "bg-amber-500/20 text-amber-300 border border-amber-500/30",        border: "border-l-amber-500" },
  attack_chain: { label: "Attack Chains",  icon: "‚õìÔ∏è", color: "bg-purple-500/20 text-purple-300 border border-purple-500/30",     border: "border-l-purple-500" },
  database:     { label: "Database",       icon: "üóÑÔ∏è", color: "bg-blue-500/20 text-blue-300 border border-blue-500/30",           border: "border-l-blue-500" },
  loot:         { label: "Other Loot",     icon: "üèÜ", color: "bg-yellow-500/20 text-yellow-300 border border-yellow-500/30",     border: "border-l-yellow-500" },
};

function UnifiedDiscoveries({
  findings, loot, lootStats, lootFilter, setLootFilter, lootLoading, loadLoot,
  credentials, vulnerabilities, databaseAccess,
}: {
  findings: any[];
  loot: any;
  lootStats: any;
  lootFilter: string;
  setLootFilter: (f: string) => void;
  lootLoading: boolean;
  loadLoot: () => void;
  credentials: any[];
  vulnerabilities: any[];
  databaseAccess: any[];
}) {
  const [activeFilter, setActiveFilter] = useState<DiscoveryCategory>("all");

  // ‚îÄ‚îÄ‚îÄ Merge all sources into one normalized list, deduplicating ‚îÄ‚îÄ‚îÄ
  const allDiscoveries = useMemo(() => {
    const items: DiscoveryItem[] = [];
    const seen = new Set<string>();

    function dedup(key: string): boolean {
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    }

    // 1) Findings from API (attack chains, vulns, credentials, etc.)
    for (const f of (findings || [])) {
      const key = `finding-${f.id || f.title || f.description?.slice(0, 60)}`;
      if (!dedup(key)) continue;

      let cat: DiscoveryCategory = "vulnerability";
      if (f.finding_type === "attack_chain") cat = "attack_chain";
      else if (f.finding_type === "credential") cat = "credential";
      else if (f.finding_type === "database" || f.finding_type === "db_access") cat = "database";

      items.push({
        id: f.id || key,
        category: cat,
        title: f.title || f.name || "Untitled Finding",
        severity: f.severity || "info",
        description: f.description || "",
        evidence: f.evidence || f.proof_of_concept || "",
        extraction_command: f.extraction_command,
        target: f.target || f.location || f.endpoint,
        iteration: f.iteration,
        finding_type: f.finding_type,
        username: f.username,
        password: f.password,
        service: f.service,
        extraction_method: f.extraction_method,
        verified: f.verified,
      });
    }

    // 2) Loot items (credentials, hashes, tokens, db_samples)
    for (const item of (loot?.items || [])) {
      const val = item.value || {};
      const key = `loot-${item.id || item.loot_type + "-" + (val.username || val.hash || item.description?.slice(0, 40))}`;
      if (!dedup(key)) continue;

      // Check if this loot credential already exists from findings
      if (item.loot_type === "credential") {
        const credKey = `cred-${val.username}-${val.service}`;
        if (seen.has(credKey)) continue;
        seen.add(credKey);
        items.push({
          id: item.id || key,
          category: "credential",
          title: `${val.service || "Unknown"} Credential`,
          severity: "high",
          description: item.description || `Captured credential for ${val.service}`,
          username: val.username,
          password: val.password,
          service: val.service,
          extraction_method: val.extraction_method,
          iteration: val.iteration,
          verified: val.verified,
          created_at: item.created_at,
        });
      } else if (item.loot_type === "db_sample") {
        items.push({
          id: item.id || key,
          category: "database",
          title: item.description || "Database Access",
          severity: "high",
          description: item.description || "",
          created_at: item.created_at,
          source: item.source,
        });
      } else {
        items.push({
          id: item.id || key,
          category: "loot",
          title: item.description || `${item.loot_type} captured`,
          severity: "medium",
          description: item.description || "",
          loot_type: item.loot_type,
          source: item.source,
          created_at: item.created_at,
        });
      }
    }

    // 3) comprehensive_findings.credentials (only if not already added)
    for (const cred of (credentials || [])) {
      const credKey = `cred-${cred.username}-${cred.service}`;
      if (!dedup(credKey)) continue;
      items.push({
        id: credKey,
        category: "credential",
        title: `${cred.service || "Unknown"} Credential`,
        severity: "high",
        description: `${cred.username}:*** @ ${cred.service}`,
        username: cred.username,
        password: cred.password,
        service: cred.service,
        extraction_method: cred.extraction_method,
        extraction_command: cred.extraction_command,
        iteration: cred.iteration,
        verified: cred.verified,
        source: cred.source,
      });
    }

    // 4) comprehensive_findings.vulnerabilities
    for (const vuln of (vulnerabilities || [])) {
      const vulnKey = `vuln-${vuln.type}-${vuln.endpoint}-${vuln.service}`;
      if (!dedup(vulnKey)) continue;
      items.push({
        id: vulnKey,
        category: "vulnerability",
        title: vuln.type || "Vulnerability",
        severity: vuln.impact?.includes("critical") ? "critical" : vuln.impact?.includes("high") ? "high" : "medium",
        description: `Service: ${vuln.service} ¬∑ Endpoint: ${vuln.endpoint}`,
        evidence: vuln.evidence,
        service: vuln.service,
        target: vuln.endpoint,
      });
    }

    // 5) comprehensive_findings.database_access
    for (const db of (databaseAccess || [])) {
      const dbKey = `db-${db.db_type}-${db.host}`;
      if (!dedup(dbKey)) continue;
      items.push({
        id: dbKey,
        category: "database",
        title: `${db.db_type} @ ${db.host}`,
        severity: "critical",
        description: `Databases: ${(db.databases || []).join(", ")} ¬∑ Tables: ${(db.tables_dumped || []).length} ¬∑ Records: ~${db.records_count}`,
        db_type: db.db_type,
        host: db.host,
        databases: db.databases,
        tables_dumped: db.tables_dumped,
        records_count: db.records_count,
      });
    }

    // Sort: critical first, then high, medium, low, info
    const sevOrder: Record<string, number> = { critical: 0, high: 1, medium: 2, low: 3, info: 4 };
    items.sort((a, b) => (sevOrder[a.severity] ?? 5) - (sevOrder[b.severity] ?? 5));

    return items;
  }, [findings, loot, credentials, vulnerabilities, databaseAccess]);

  // ‚îÄ‚îÄ‚îÄ Count per category ‚îÄ‚îÄ‚îÄ
  const counts = useMemo(() => {
    const c: Record<DiscoveryCategory, number> = { all: 0, vulnerability: 0, credential: 0, attack_chain: 0, database: 0, loot: 0 };
    for (const d of allDiscoveries) {
      c[d.category]++;
      c.all++;
    }
    return c;
  }, [allDiscoveries]);

  const filtered = activeFilter === "all" ? allDiscoveries : allDiscoveries.filter((d) => d.category === activeFilter);

  const severityBorder: Record<string, string> = {
    critical: "border-l-red-500",
    high: "border-l-orange-500",
    medium: "border-l-yellow-500",
    low: "border-l-blue-500",
    info: "border-l-slate-500",
  };

  return (
    <Card id="discoveries" className="border-indigo-500/20">
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h3 className="text-sm font-medium flex items-center gap-2">
          <span className="text-xl">üéØ</span>
          <span className="bg-gradient-to-r from-indigo-400 to-cyan-300 bg-clip-text text-transparent font-bold text-lg">
            Discoveries
          </span>
          <span className="text-xs text-[var(--text-dim)]">{counts.all} total</span>
        </h3>
        <button
          onClick={loadLoot}
          className="p-2 rounded-lg bg-[var(--surface2)] border border-[var(--border)] hover:bg-white/5"
          title="Refresh"
        >
          <RefreshCw className="w-4 h-4" />
        </button>
      </div>

      {/* Filter tabs */}
      <div className="flex gap-2 flex-wrap mb-4">
        {(Object.keys(categoryConfig) as DiscoveryCategory[]).map((cat) => {
          const cfg = categoryConfig[cat];
          const count = counts[cat];
          if (cat !== "all" && count === 0) return null;
          return (
            <button
              key={cat}
              onClick={() => setActiveFilter(cat)}
              className={`px-3 py-1.5 rounded-lg text-xs transition flex items-center gap-1.5 ${
                activeFilter === cat
                  ? "bg-indigo-600 text-white"
                  : "bg-[var(--surface2)] border border-[var(--border)] hover:bg-white/5"
              }`}
            >
              <span>{cfg.icon}</span>
              <span>{cfg.label}</span>
              <span className="opacity-70">({count})</span>
            </button>
          );
        })}
      </div>

      {/* Content */}
      {lootLoading && filtered.length === 0 ? (
        <p className="text-xs text-[var(--text-dim)] animate-pulse">üîç Scanning...</p>
      ) : filtered.length === 0 ? (
        <div className="text-center py-8">
          <div className="text-4xl mb-2 opacity-50">üéØ</div>
          <p className="text-sm text-[var(--text-dim)]">No discoveries yet...</p>
          <p className="text-xs text-[var(--text-dim)] mt-1">Vulnerabilities, credentials, and loot will appear here as they&apos;re found</p>
        </div>
      ) : (
        <div className="space-y-3">
          {filtered.map((item) => {
            // ‚îÄ‚îÄ‚îÄ Credential card (premium style) ‚îÄ‚îÄ‚îÄ
            if (item.category === "credential" && (item.username || item.password)) {
              return (
                <div key={item.id} className="p-4 rounded-xl bg-gradient-to-r from-amber-950/40 to-yellow-950/30 border border-amber-500/30 shadow-lg shadow-amber-500/10">
                  <div className="flex items-center gap-4">
                    <div className="p-3 rounded-xl bg-amber-500/20 border border-amber-500/40">
                      <Key className="w-6 h-6 text-amber-400" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2 mb-1 flex-wrap">
                        <span className="text-xs px-2 py-0.5 rounded-full bg-amber-500/20 text-amber-300 border border-amber-500/30 font-medium">
                          üîë CREDENTIAL
                        </span>
                        <span className="text-xs px-2 py-0.5 rounded-full bg-purple-500/20 text-purple-300 border border-purple-500/30">
                          {item.service || "Unknown Service"}
                        </span>
                        {item.verified && (
                          <span className="text-xs px-2 py-0.5 rounded-full bg-green-500/20 text-green-300 border border-green-500/30">
                            ‚úì Verified
                          </span>
                        )}
                        {item.iteration != null && item.iteration > 0 && (
                          <span className="text-[10px] text-[var(--text-dim)] ml-auto">Iter #{item.iteration}</span>
                        )}
                      </div>
                      <div className="flex items-center gap-3 mt-2 flex-wrap">
                        <div className="flex items-center gap-2 px-3 py-2 rounded-lg bg-black/40 border border-white/10">
                          <span className="text-xs text-[var(--text-dim)]">USER</span>
                          <span className="font-mono text-lg font-bold text-amber-300">{item.username || "unknown"}</span>
                        </div>
                        <span className="text-2xl text-[var(--text-dim)]">:</span>
                        <div className="flex items-center gap-2 px-3 py-2 rounded-lg bg-black/40 border border-white/10">
                          <span className="text-xs text-[var(--text-dim)]">PASS</span>
                          <MaskedPassword password={item.password || "********"} />
                        </div>
                      </div>
                      {(item.extraction_method || item.extraction_command) && (
                        <div className="mt-2">
                          {item.extraction_method && (
                            <p className="text-xs text-[var(--text-dim)]">
                              üìç Extracted via: <span className="text-indigo-300">{item.extraction_method}</span>
                            </p>
                          )}
                          {item.extraction_command && (
                            <pre className="mt-1 text-[10px] text-cyan-400/80 bg-black/40 p-2 rounded font-mono whitespace-pre-wrap break-all max-h-16 overflow-y-auto">
                              $ {redactSecrets(String(item.extraction_command))}
                            </pre>
                          )}
                        </div>
                      )}
                    </div>
                    <div className="text-4xl opacity-50 hidden sm:block">üèÜ</div>
                  </div>
                </div>
              );
            }

            // ‚îÄ‚îÄ‚îÄ Database access card ‚îÄ‚îÄ‚îÄ
            if (item.category === "database") {
              return (
                <div key={item.id} className="p-4 rounded-xl bg-gradient-to-r from-blue-950/40 to-cyan-950/30 border border-blue-500/30">
                  <div className="flex items-center gap-4">
                    <div className="p-3 rounded-xl bg-blue-500/20 border border-blue-500/40">
                      <Database className="w-6 h-6 text-blue-400" />
                    </div>
                    <div className="flex-1">
                      <div className="flex items-center gap-2 mb-1">
                        <span className="text-xs px-2 py-0.5 rounded-full bg-blue-500/20 text-blue-300 border border-blue-500/30 font-medium">
                          üóÑÔ∏è DATABASE
                        </span>
                        <SeverityBadge severity={item.severity} />
                      </div>
                      <p className="text-sm font-medium mt-1">{item.title}</p>
                      {item.description && <p className="text-xs text-[var(--text-dim)] mt-1">{item.description}</p>}
                      {item.evidence && (
                        <details className="mt-2">
                          <summary className="text-[10px] text-[var(--text-dim)] cursor-pointer hover:text-slate-300 transition">
                            View evidence ‚ñ∏
                          </summary>
                          <pre className="mt-1 text-[10px] text-green-400/70 bg-black/30 p-2 rounded max-h-24 overflow-y-auto whitespace-pre-wrap">
                            {redactSecrets(String(item.evidence)).slice(0, 500)}
                          </pre>
                        </details>
                      )}
                    </div>
                    <div className="text-4xl opacity-50 hidden sm:block">üíæ</div>
                  </div>
                </div>
              );
            }

            // ‚îÄ‚îÄ‚îÄ Attack chain card ‚îÄ‚îÄ‚îÄ
            if (item.category === "attack_chain") {
              return (
                <div key={item.id} className="p-4 rounded-xl bg-gradient-to-r from-purple-950/40 to-fuchsia-950/30 border border-purple-500/30">
                  <div className="flex items-center gap-2 mb-2">
                    <span className="text-lg">‚õìÔ∏è</span>
                    <SeverityBadge severity={item.severity || "critical"} />
                    <span className="font-semibold text-sm">{item.title}</span>
                    {item.iteration != null && item.iteration > 0 && (
                      <span className="text-[10px] text-[var(--text-dim)] ml-auto">Iter #{item.iteration}</span>
                    )}
                  </div>
                  <p className="text-xs text-[var(--text-dim)] mb-2">{redactSecrets(String(item.description))}</p>
                  {item.evidence && (
                    <pre className="text-[10px] text-green-400/70 bg-black/30 p-2 rounded max-h-32 overflow-y-auto whitespace-pre-wrap">
                      {redactSecrets(String(item.evidence)).slice(0, 500)}
                    </pre>
                  )}
                </div>
              );
            }

            // ‚îÄ‚îÄ‚îÄ Other loot (hashes, tokens, configs, sessions) ‚îÄ‚îÄ‚îÄ
            if (item.category === "loot") {
              const Icon = lootTypeIcons[item.loot_type || ""] || Key;
              return (
                <div key={item.id} className="p-3 rounded-lg bg-[var(--surface2)] border border-[var(--border)] border-l-4 border-l-yellow-500">
                  <div className="flex items-start gap-3">
                    <div className={`p-2 rounded-lg ${lootTypeColors[item.loot_type || ""] || "bg-gray-500/20"}`}>
                      <Icon className="w-4 h-4" />
                    </div>
                    <div className="flex-1 min-w-0">
                      <div className="flex items-center gap-2">
                        <Badge className={lootTypeColors[item.loot_type || ""] || "bg-gray-500/20"}>{item.loot_type}</Badge>
                        {item.source && <span className="text-xs text-[var(--text-dim)]">{item.source}</span>}
                      </div>
                      {item.title && <p className="text-xs mt-1">{item.title}</p>}
                      {item.created_at && <p className="text-[10px] text-[var(--text-dim)] mt-1">{formatDate(item.created_at)}</p>}
                    </div>
                  </div>
                </div>
              );
            }

            // ‚îÄ‚îÄ‚îÄ Default: vulnerability / generic finding ‚îÄ‚îÄ‚îÄ
            const desc = redactSecrets(String(item.description || ""));
            const descLines = desc.split("\n").filter(Boolean);
            const proseLine = descLines[0] || "";
            const kvLine = descLines.length > 1 ? descLines[1] : "";
            const kvPairs = kvLine ? kvLine.split(" | ").filter(Boolean) : [];
            const sev = item.severity || "info";

            return (
              <div key={item.id} className={`p-4 rounded-lg bg-[var(--surface2)] border-l-4 ${severityBorder[sev] || severityBorder.info}`}>
                <div className="flex items-center gap-2 mb-2">
                  <SeverityBadge severity={sev} />
                  <span className="font-semibold text-sm">{item.title}</span>
                  {item.finding_type && (
                    <span className="text-[10px] px-2 py-0.5 rounded-full bg-indigo-500/15 text-indigo-300 border border-indigo-500/25">
                      {item.finding_type}
                    </span>
                  )}
                  {item.iteration != null && item.iteration > 0 && (
                    <span className="text-[10px] text-[var(--text-dim)] ml-auto">Iter #{item.iteration}</span>
                  )}
                </div>
                {proseLine && <p className="text-xs text-slate-300 mb-2">{proseLine}</p>}
                {kvPairs.length > 0 && (
                  <div className="flex flex-wrap gap-2 mb-2">
                    {kvPairs.map((kv, j) => {
                      const [label, ...rest] = kv.split(":");
                      const value = rest.join(":").trim();
                      return (
                        <span key={j} className="inline-flex items-center gap-1.5 text-[11px] px-2.5 py-1 rounded-md bg-black/30 border border-white/5">
                          <span className="text-slate-400 font-medium">{label.trim()}</span>
                          {value && <span className="text-slate-200">{value}</span>}
                        </span>
                      );
                    })}
                  </div>
                )}
                {item.target && (
                  <p className="text-[10px] text-[var(--text-dim)] flex items-center gap-1 mb-1">
                    üìç <span className="text-indigo-300">{item.target}</span>
                  </p>
                )}
                {item.extraction_command && (
                  <pre className="mt-2 text-[10px] text-cyan-400/80 bg-black/40 p-2 rounded max-h-16 overflow-y-auto whitespace-pre-wrap break-all font-mono">
                    $ {redactSecrets(String(item.extraction_command))}
                  </pre>
                )}
                {item.evidence && !item.extraction_command && (
                  <details className="mt-2">
                    <summary className="text-[10px] text-[var(--text-dim)] cursor-pointer hover:text-slate-300 transition">
                      View evidence ‚ñ∏
                    </summary>
                    <pre className="mt-1 text-[10px] text-green-400/70 bg-black/30 p-2 rounded max-h-24 overflow-y-auto whitespace-pre-wrap">
                      {redactSecrets(String(item.evidence)).slice(0, 500)}
                    </pre>
                  </details>
                )}
              </div>
            );
          })}
        </div>
      )}
    </Card>
  );
}

export default function PentestDetailPage() {
  return (
    <AppShell>
      <PentestDetailInner />
    </AppShell>
  );
}

function PentestDetailInner() {
  const { id } = useParams();
  const router = useRouter();
  const [job, setJob] = useState<any>(null);
  const [output, setOutput] = useState<string[]>([]);
  const [loading, setLoading] = useState(true);
  const [dbFindings, setDbFindings] = useState<any[]>([]);
  const [resuming, setResuming] = useState(false);
  const [creatingTerminal, setCreatingTerminal] = useState(false);
  const [terminalError, setTerminalError] = useState<string | null>(null);
  const [openingHandoff, setOpeningHandoff] = useState<string | null>(null);
  const [liveStats, setLiveStats] = useState<any>(null);
  const [loot, setLoot] = useState<any>({ items: [], total: 0 });
  const [lootStats, setLootStats] = useState<any>({ total: 0, by_type: {} });
  const [lootFilter, setLootFilter] = useState("");
  const [lootLoading, setLootLoading] = useState(false);
  const [parsedIteration, setParsedIteration] = useState<{ current: number; max: number } | null>(null);
  const wsRef = useRef<WebSocket | null>(null);
  const outputRef = useRef<HTMLDivElement>(null);
  const lastFindingsCount = useRef<number>(0);
  const jobStatusRef = useRef<string | null>(null);
  const [bgPulseClass, setBgPulseClass] = useState<string>("");

  // Reset UI state when switching jobs so logs don't carry over
  useEffect(() => {
    setOutput([]);
    setDbFindings([]);
    setLiveStats(null);
    setLoot({ items: [], total: 0 });
    setLootStats({ total: 0, by_type: {} });
    setLootFilter("");
    setParsedIteration(null);
    lastFindingsCount.current = 0;
    setLoading(true);
    setTerminalError(null);
  }, [id]);

  useEffect(() => {
    jobStatusRef.current = job?.status ?? null;
  }, [job?.status]);

  // üé∞ Dopamine hit: play sound when new findings discovered
  function playFindingSound(severity?: string) {
    try {
      const ctx = new (window.AudioContext || (window as any).webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.connect(gain);
      gain.connect(ctx.destination);
      
      // Different tones for different severities
      if (severity === "critical") {
        osc.frequency.setValueAtTime(880, ctx.currentTime); // A5 - urgent
        osc.frequency.setValueAtTime(1046, ctx.currentTime + 0.1); // C6
        osc.frequency.setValueAtTime(880, ctx.currentTime + 0.2);
      } else if (severity === "high") {
        osc.frequency.setValueAtTime(659, ctx.currentTime); // E5
        osc.frequency.setValueAtTime(784, ctx.currentTime + 0.15); // G5
      } else {
        osc.frequency.setValueAtTime(523, ctx.currentTime); // C5 - pleasant ding
        osc.frequency.setValueAtTime(659, ctx.currentTime + 0.1); // E5
      }
      
      gain.gain.setValueAtTime(0.3, ctx.currentTime);
      gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
      
      osc.start(ctx.currentTime);
      osc.stop(ctx.currentTime + 0.3);
    } catch {}
  }
  
  // Parse iteration from log lines
  function parseIterationFromLine(line: string) {
    const match = line.match(/=== Iteration (\d+)\/(\d+)/i);
    if (match) {
      setParsedIteration({ current: parseInt(match[1]), max: parseInt(match[2]) });
    }
  }

  async function openTerminal() {
    if (!id) return;
    setCreatingTerminal(true);
    setTerminalError(null);
    try {
      const session = await api.post("/api/v1/terminal/sessions", { job_id: id });
      if (session?.id) {
        router.push(`/terminal/${session.id}`);
      } else {
        setTerminalError("Failed to create terminal session.");
      }
    } catch (e: any) {
      setTerminalError(e?.message || "Failed to create terminal session.");
    } finally {
      setCreatingTerminal(false);
    }
  }

  async function openHandoff(command: string, label?: string) {
    if (!id || !command) return;
    setOpeningHandoff(command);
    setTerminalError(null);
    try {
      const session = await api.post("/api/v1/terminal/sessions", {
        job_id: id,
        label: label || "Handoff Session",
        start_command: command,
      });
      if (session?.id) {
        router.push(`/terminal/${session.id}`);
      } else {
        setTerminalError("Failed to create handoff terminal session.");
      }
    } catch (e: any) {
      setTerminalError(e?.message || "Failed to create handoff terminal session.");
    } finally {
      setOpeningHandoff(null);
    }
  }

  const loadJob = useCallback(() => {
    if (!id) return;
    api
      .get(`/api/v1/jobs/${id}`)
      .then((data) => {
        setJob(data);
        // When job completes, also fetch findings from API
        if (data?.status === "completed" || data?.status === "failed") {
          api.get(`/api/v1/jobs/${id}/findings`).then(setDbFindings).catch(() => {});
        }
      })
      .catch(() => {})
      .finally(() => setLoading(false));
  }, [id]);

  const loadLoot = useCallback(() => {
    if (!id) return;
    setLootLoading(true);
    const params = new URLSearchParams();
    params.set("job_id", String(id));
    if (lootFilter) params.set("loot_type", lootFilter);
    const q = params.toString();
    Promise.all([
      api.get(`/api/v1/loot?${q}`),
      api.get(`/api/v1/loot/stats?job_id=${id}`),
      ])
      .then(([l, s]) => {
        setLoot(l);
        setLootStats(s);
      })
      .catch(() => {})
      .finally(() => setLootLoading(false));
  }, [id, lootFilter]);

  useEffect(() => {
    loadJob();
    const interval = setInterval(loadJob, 5000);
    return () => clearInterval(interval);
  }, [loadJob]);

  useEffect(() => {
    loadLoot();
  }, [loadLoot]);

  // üèÜ LIVE TROPHIES: Poll findings + loot from API every 15s while job is running
  useEffect(() => {
    if (!id || !job || job.status !== "running") return;
    const pollFindings = () => {
      api.get(`/api/v1/jobs/${id}/findings`).then((data: any) => {
        if (Array.isArray(data) && data.length > 0) {
          setDbFindings(data);
        } else if (data?.findings && Array.isArray(data.findings)) {
          setDbFindings(data.findings);
        }
      }).catch(() => {});
      // Also refresh loot
      loadLoot();
    };
    pollFindings(); // immediate first poll
    const interval = setInterval(pollFindings, 15000);
    return () => clearInterval(interval);
  }, [id, job?.status, loadLoot]);

  // üé∞ Dopamine hit: detect new findings and play sound + background pulse
  useEffect(() => {
    const currentCount = liveStats?.total_findings || job?.findings_count || loot?.items?.length || 0;
    if (currentCount > lastFindingsCount.current && lastFindingsCount.current > 0) {
      // New finding discovered!
      // Determine severity for sound and pulse
      let severity = "info";
      if (liveStats?.critical > 0 || job?.critical_count > 0) {
        severity = "critical";
      } else if (liveStats?.vulnerabilities > 0) {
        severity = "high";
      } else if (liveStats?.credentials > 0) {
        severity = "medium";
      }
      
      playFindingSound(severity);
      
      // üî¥ Trigger background pulse effect based on severity
      const pulseMap: Record<string, string> = {
        critical: "bg-pulse-critical",
        high: "bg-pulse-high",
        medium: "bg-pulse-medium",
        info: "bg-pulse-success",
      };
      setBgPulseClass(pulseMap[severity] || "bg-pulse-success");
      
      // Clear pulse class after animation completes (~1s)
      setTimeout(() => setBgPulseClass(""), 1000);
      
      // Browser notification if permitted
      if (Notification.permission === "granted") {
        new Notification("üéØ TazoSploit: New Finding!", {
          body: `Found something interesting (${currentCount} total)`,
          icon: "/favicon.ico",
        });
      }
    }
    lastFindingsCount.current = currentCount;
  }, [liveStats?.total_findings, job?.findings_count, loot?.items?.length, liveStats?.critical, liveStats?.vulnerabilities, liveStats?.credentials, job?.critical_count]);

  // Request notification permission on mount
  useEffect(() => {
    if (typeof Notification !== "undefined" && Notification.permission === "default") {
      Notification.requestPermission();
    }
  }, []);

  // Poll live stats for running jobs
  useEffect(() => {
    if (!id) return;
    let timer: ReturnType<typeof setInterval> | null = null;
    function fetchLiveStats() {
      api.get(`/api/v1/jobs/${id}/live-stats`).then(setLiveStats).catch(() => {});
    }
    fetchLiveStats();
    timer = setInterval(fetchLiveStats, 5000);
    return () => { if (timer) clearInterval(timer); };
  }, [id]);

  // WebSocket for live output
  useEffect(() => {
    if (!id) return;
    
    let ws: WebSocket | null = null;
    let reconnectTimer: ReturnType<typeof setTimeout> | null = null;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 10;
    
    function connect() {
      try {
        ws = new WebSocket(wsUrl(`/api/v1/ws/job/${id}`));
        wsRef.current = ws;
        
        ws.onopen = () => {
          reconnectAttempts = 0;
        };
        
        ws.onmessage = (e) => {
          try {
            const data = JSON.parse(e.data);
            if (data.line && !isNoisyLine(data.line)) {
              const ts = data.timestamp ? new Date(data.timestamp).toLocaleTimeString() : "";
              const prefix = ts ? `[${ts}] ` : "";
              const clean = redactSecrets(String(data.line));
              setOutput((prev) => [...prev.slice(-500), `${prefix}${clean}`]);
              // Parse iteration from output for real-time counter
              parseIterationFromLine(data.line);
            }
          } catch {}
        };
        
        ws.onerror = () => {};
        
        ws.onclose = () => {
          // Auto-reconnect for running jobs
          if (reconnectAttempts < maxReconnectAttempts) {
            reconnectAttempts++;
            reconnectTimer = setTimeout(connect, 2000 * Math.min(reconnectAttempts, 5));
          }
        };
      } catch {}
    }
    
    connect();
    
    // Polling fallback: fetch buffered logs if WebSocket isn't delivering
    let pollTimer: ReturnType<typeof setInterval> | null = null;
    let lastPollOffset = 0;
    
    pollTimer = setInterval(async () => {
      // Stop polling if job is completed/failed/cancelled
      const status = jobStatusRef.current;
      if (status && ["completed", "failed", "cancelled"].includes(status)) {
        if (pollTimer) clearInterval(pollTimer);
        return;
      }
      try {
        const { API_URL, getToken: gt } = await import("@/lib/api");
        const resp = await fetch(`${API_URL}/api/v1/jobs/${id}/output?offset=${lastPollOffset}`, {
          headers: { "Authorization": `Bearer ${gt() || ""}` }
        });
        if (resp.ok) {
          const data = await resp.json();
          if (data.lines && data.lines.length > 0) {
            setOutput((prev) => {
              const newLines = data.lines
                .filter((l: any) => l.line && !isNoisyLine(l.line))
                .map((l: any) => {
                  const ts = l.timestamp ? new Date(l.timestamp).toLocaleTimeString() : "";
                  const clean = redactSecrets(String(l.line));
                  // Parse iteration from line for real-time counter
                  parseIterationFromLine(l.line);
                  return ts ? `[${ts}] ${clean}` : clean;
                });
              return [...prev.slice(-500), ...newLines];
            });
            lastPollOffset += data.lines.length;
          }
        }
      } catch {}
    }, 3000);
    
    return () => {
      if (ws) ws.close();
      if (reconnectTimer) clearTimeout(reconnectTimer);
      if (pollTimer) clearInterval(pollTimer);
    };
  }, [id]);

  useEffect(() => {
    if (outputRef.current) {
      outputRef.current.scrollTop = outputRef.current.scrollHeight;
    }
  }, [output]);

  async function cancelJob() {
    await api.post(`/api/v1/jobs/${id}/cancel`, {});
    loadJob();
  }

  async function resumeJob() {
    setResuming(true);
    try {
      await api.post(`/api/v1/jobs/${id}/resume`, {});
      setOutput([]);
      loadJob();
    } catch (e: any) {
      console.error("Resume failed", e);
      alert(e?.message || "Failed to resume job");
    } finally {
      setResuming(false);
    }
  }

  if (loading) return <p>Loading...</p>;
  if (!job) return <p>Job not found</p>;

  // Extract data from result
  const result = job.result || {};
  const compFindings = result.comprehensive_findings || {};
  const credentials = compFindings.credentials || result.credentials || [];
  const vulnerabilities = compFindings.vulnerabilities || [];
  const databaseAccess = compFindings.database_access || [];
  // üèÜ LIVE TROPHIES: Prefer dbFindings (polled live from API) over result.findings (only at completion)
  const findings = (dbFindings && dbFindings.length > 0) ? dbFindings : (result.findings || []);
  const rawOutput = redactSecrets(String(result.raw_output || result.output || ""));
  const toolsUsed = result.tools_used || [];
  const reportArtifacts = result.report_artifacts || null;
  const { show: showReportWarning, missing: missingReportParts } = getReportArtifactsWarning(
    job.phase,
    job.status,
    reportArtifacts
  );
  const handoffSessions = result.session_handoff?.sessions || [];
  const showHandoff = job.enable_session_handoff && handoffSessions.length > 0;

  return (
    <div className={`space-y-6 ${bgPulseClass}`}>
        <div className="flex items-center gap-4">
          <Link href="/pentests" className="p-2 rounded-lg hover:bg-white/5">
            <ArrowLeft className="w-5 h-5" />
          </Link>
          <div className="flex-1">
            <h1 className="text-2xl font-bold">{job.name}</h1>
            <p className="text-sm text-[var(--text-dim)]">
              {job.phase} &middot; {(job.targets || []).join(", ")} &middot; {formatDate(job.created_at)}
            </p>
          </div>
          <span className={`text-lg font-semibold ${statusColor(job.status)}`}>‚óè {job.status}</span>
          {["running", "pending", "queued"].includes(job.status) && (
            <button
              onClick={cancelJob}
              className="flex items-center gap-2 px-3 py-2 rounded-lg bg-red-600/20 text-red-400 hover:bg-red-600/30 transition text-sm"
            >
              <StopCircle className="w-4 h-4" /> Cancel
            </button>
          )}
          <button
            onClick={openTerminal}
            disabled={creatingTerminal}
            className="flex items-center gap-2 px-3 py-2 rounded-lg bg-slate-700/30 text-slate-200 hover:bg-slate-700/50 transition text-sm disabled:opacity-50"
            title="Open interactive terminal in Kali"
          >
            <Terminal className="w-4 h-4" /> {creatingTerminal ? "Opening..." : "Open Terminal"}
          </button>
          {["completed", "failed", "cancelled", "timeout"].includes(job.status) && (
            <>
              <button
                onClick={resumeJob}
                disabled={resuming}
                className="flex items-center gap-2 px-3 py-2 rounded-lg bg-green-600/20 text-green-400 hover:bg-green-600/30 transition text-sm disabled:opacity-50"
                title="Resume from where it left off"
              >
                <PlayCircle className="w-4 h-4" /> {resuming ? "Resuming..." : "Resume"}
              </button>
              {job.status === "completed" && (
                <button
                  onClick={async () => {
                    try {
                      const blob = await api.getBlob(`/api/v1/dashboard/jobs/${id}/report?format=pdf`);
                      const url = URL.createObjectURL(blob);
                      const a = document.createElement("a");
                      a.href = url;
                      a.download = `TazoSploit_Report_${job.name.replace(/\s+/g, "_")}.pdf`;
                      a.click();
                      URL.revokeObjectURL(url);
                    } catch (e) { console.error("Report download failed", e); }
                  }}
                  className="flex items-center gap-2 px-3 py-2 rounded-lg bg-indigo-600/20 text-indigo-400 hover:bg-indigo-600/30 transition text-sm"
                >
                  <FileDown className="w-4 h-4" /> Download Report
                </button>
              )}
            </>
          )}
        </div>
        {terminalError && (
          <Card className="border-red-500/30">
            <div className="flex items-start gap-3">
              <AlertTriangle className="w-4 h-4 text-red-400 mt-0.5" />
              <div>
                <h3 className="text-sm font-medium text-red-300">Terminal error</h3>
                <p className="text-xs text-[var(--text-dim)]">{terminalError}</p>
              </div>
            </div>
          </Card>
        )}
        {showHandoff && (
          <Card>
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold">Session Handoff</h3>
                <p className="text-xs text-[var(--text-dim)]">
                  Suggested interactive commands captured after access was verified.
                </p>
              </div>
            </div>
            <div className="mt-3 space-y-2">
              {handoffSessions.map((s: any, idx: number) => (
                <div
                  key={`${s.command}-${idx}`}
                  className="flex items-center justify-between gap-3 rounded-lg border border-[var(--border)] bg-[var(--surface2)] px-3 py-2"
                >
                  <div className="min-w-0">
                    <p className="text-xs font-medium text-slate-200">{s.label || "Handoff Session"}</p>
                    <code className="block text-[10px] text-[var(--text-dim)] truncate">{s.command}</code>
                  </div>
                  <button
                    onClick={() => openHandoff(s.command, s.label)}
                    disabled={openingHandoff === s.command}
                    className="flex items-center gap-2 px-3 py-1.5 rounded-lg bg-slate-700/40 text-slate-100 hover:bg-slate-700/70 transition text-xs disabled:opacity-50"
                  >
                    <Terminal className="w-3.5 h-3.5" /> {openingHandoff === s.command ? "Opening..." : "Open Shell"}
                  </button>
                </div>
              ))}
            </div>
          </Card>
        )}

        {/* Progress bar */}
        {job.status === "running" && (
          <div className="w-full h-2 rounded bg-[var(--surface2)]">
            <div className="h-full rounded bg-indigo-500 transition-all" style={{ width: `${job.progress}%` }} />
          </div>
        )}

        {/* Report artifacts warning */}
        {showReportWarning && (
          <Card className="border-yellow-500/30">
            <div className="flex items-start gap-3">
              <AlertTriangle className="w-4 h-4 text-yellow-400 mt-0.5" />
              <div>
                <h3 className="text-sm font-medium text-yellow-300">Report artifacts missing</h3>
                <p className="text-xs text-[var(--text-dim)]">
                  The REPORT phase completed, but the structured report files are incomplete. Missing:{" "}
                  <span className="text-yellow-200">{missingReportParts.join(", ") || "report.md, report.json"}</span>.
                </p>
              </div>
            </div>
          </Card>
        )}

        {/* Stats */}
        <div className="grid grid-cols-2 sm:grid-cols-4 gap-4">
          <Card>
            <p className="text-xs text-[var(--text-dim)]">Findings</p>
            <p className="text-2xl font-bold">
              {job.findings_count || findings.length || liveStats?.total_findings || 0}
            </p>
            {liveStats && liveStats.total_findings > 0 && !job.findings_count && (
              <div className="flex gap-2 mt-1 text-[10px]">
                {liveStats.vulnerabilities > 0 && <span className="text-red-400">üîì {liveStats.vulnerabilities} vulns</span>}
                {liveStats.credentials > 0 && <span className="text-yellow-400">üîë {liveStats.credentials} creds</span>}
                {liveStats.access_gained > 0 && <span className="text-green-400">üö™ {liveStats.access_gained} access</span>}
              </div>
            )}
          </Card>
          <Card className="flex flex-col items-center justify-center py-2">
            <p className="text-xs text-[var(--text-dim)] mb-2">Iteration</p>
            <ProgressRing
              current={parsedIteration?.current || liveStats?.current_iteration || 0}
              max={parsedIteration?.max || liveStats?.max_iterations || job.max_iterations || 100}
              size={90}
              isRunning={job.status === "running"}
            />
          </Card>
          <Card>
            <p className="text-xs text-[var(--text-dim)]">Critical</p>
            <p className="text-2xl font-bold text-red-400">{job.critical_count || 0}</p>
          </Card>
          <Card>
            <p className="text-xs text-[var(--text-dim)]">Tokens Used</p>
            <p className="text-2xl font-bold">{job.tokens_used?.toLocaleString() || 0}</p>
          </Card>
        </div>

        {/* Run Controls ‚Äî collapsible to save space */}
        <Card>
          <details>
            <summary className="text-sm font-medium text-[var(--text-dim)] cursor-pointer hover:text-slate-200 transition select-none flex items-center gap-2">
              <span>‚öôÔ∏è Run Controls</span>
              <span className="text-[10px] px-2 py-0.5 rounded bg-[var(--surface2)] border border-[var(--border)]">
                {job.phase} ¬∑ {job.exploit_mode} ¬∑ {Math.round((job.timeout_seconds || 0) / 60)}min ¬∑ {job.max_iterations || 0} iters
              </span>
            </summary>
            <div className="grid grid-cols-2 md:grid-cols-4 gap-3 text-xs mt-3">
              <div>
                <p className="text-[var(--text-dim)]">Phase</p>
                <p className="font-semibold">{job.phase}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Target Type</p>
                <p className="font-semibold">{job.target_type}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Intensity</p>
                <p className="font-semibold">{job.intensity || "medium"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Timeout</p>
                <p className="font-semibold">{Math.round((job.timeout_seconds || 0) / 60)} min</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Exploit Mode</p>
                <p className="font-semibold">{job.exploit_mode}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Max Iterations</p>
                <p className="font-semibold">{job.max_iterations || 0}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Scope Expansion</p>
                <p className="font-semibold">{job.allow_scope_expansion ? "On" : "Off"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Persistence</p>
                <p className="font-semibold">{job.allow_persistence ? "On" : "Off"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Defense Evasion</p>
                <p className="font-semibold">{job.allow_defense_evasion ? "On" : "Off"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Session Handoff</p>
                <p className="font-semibold">{job.enable_session_handoff ? "On" : "Off"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Target Rotation</p>
                <p className="font-semibold">{job.enable_target_rotation ? "On" : "Off"}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Rotation Window</p>
                <p className="font-semibold">{job.target_focus_window ?? 6}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Max Actions/Target</p>
                <p className="font-semibold">{job.target_focus_limit ?? 30}</p>
              </div>
              <div>
                <p className="text-[var(--text-dim)]">Min Actions Before Pivot</p>
                <p className="font-semibold">{job.target_min_commands ?? 8}</p>
              </div>
            </div>
          </details>
        </Card>

        {/* üé∞ Dopamine Feed - Compact strip: sounds, streaks, achievements only (no duplicate findings) */}
        {job.status === "running" && (
          <Card className="relative overflow-hidden">
            <DopamineFeed
              findings={(findings || []).map((f: any, i: number) => ({
                id: f.id || `finding-${i}`,
                title: f.title || f.name || f.description?.slice(0, 50) || `Finding ${i + 1}`,
                severity: f.severity || "info",
                type: f.finding_type || f.type || "unknown",
                location: f.location || f.endpoint || f.target,
                description: f.description || "",
                evidence: f.evidence || f.proof_of_concept || "",
                timestamp: f.created_at || new Date().toISOString(),
                isNew: i < 3,
              }))}
              credentials={liveStats?.credentials || credentials.length || 0}
              iteration={parsedIteration?.current || liveStats?.current_iteration || 0}
              maxIterations={parsedIteration?.max || liveStats?.max_iterations || job.max_iterations || 5000}
              compact={true}
            />
          </Card>
        )}

        {/* üéØ Unified Discoveries ‚Äî Single source of truth for all findings */}
        <UnifiedDiscoveries
          findings={findings}
          loot={loot}
          lootStats={lootStats}
          lootFilter={lootFilter}
          setLootFilter={setLootFilter}
          lootLoading={lootLoading}
          loadLoot={loadLoot}
          credentials={credentials}
          vulnerabilities={vulnerabilities}
          databaseAccess={databaseAccess}
        />

        {/* Tools Used */}
        {toolsUsed.length > 0 && (
          <Card>
            <h3 className="text-sm font-medium text-[var(--text-dim)] mb-2">Tools Used</h3>
            <div className="flex flex-wrap gap-2">
              {toolsUsed.map((tool: string, i: number) => (
                <span key={i} className="text-xs px-2 py-1 rounded bg-indigo-600/20 text-indigo-300 border border-indigo-500/30">
                  {tool}
                </span>
              ))}
            </div>
          </Card>
        )}

        {/* Live output / Raw output */}
        <Card>
          <details open>
            <summary className="flex items-center justify-between cursor-pointer select-none mb-3">
              <h3 className="text-sm font-medium text-[var(--text-dim)] flex items-center gap-2">
                <Terminal className="w-4 h-4" /> {job.status === "running" ? "Live Output" : "Agent Output"}
              </h3>
              <button onClick={(e) => { e.preventDefault(); loadJob(); }} className="p-1 rounded hover:bg-white/5">
                <RefreshCw className="w-3 h-3" />
              </button>
            </summary>
          <div
            ref={outputRef}
            className="bg-black rounded-lg p-4 h-80 overflow-y-auto font-mono text-xs space-y-0.5"
          >
            {output.length > 0 ? (
              output.map((line, i) => {
                let colorClass = "text-green-400";
                const lower = line.toLowerCase();
                if (lower.includes("error") || lower.includes("failed") || lower.includes("exception") || lower.includes("stderr")) {
                  colorClass = "text-red-400";
                } else if (lower.includes("warning") || lower.includes("warn") || lower.includes("timeout")) {
                  colorClass = "text-yellow-400";
                } else if (lower.includes("=== iteration") || lower.includes("engagement complete")) {
                  colorClass = "text-cyan-300 font-bold";
                } else if (lower.includes("[info]") || lower.includes("starting") || lower.includes("success")) {
                  colorClass = "text-green-400";
                } else if (line.startsWith("[")) {
                  colorClass = "text-gray-400";
                }
                return <div key={i} className={colorClass}>{line}</div>;
              })
            ) : rawOutput ? (
              rawOutput.split("\n").map((line: string, i: number) => <div key={i} className="text-green-400">{line}</div>)
            ) : job.status === "running" || job.status === "queued" || job.status === "pending" ? (
              <p className="text-[var(--text-dim)] animate-pulse">
                ‚è≥ Agent is running... output will appear here in real-time
              </p>
            ) : (
              <p className="text-[var(--text-dim)]">No output captured.</p>
            )}
          </div>
          </details>
        </Card>

        {/* Error */}
        {job.error_message && (
          <Card className="border-red-500/30">
            <h3 className="text-sm font-medium text-red-400 mb-2">Error</h3>
            <pre className="text-xs text-red-300 whitespace-pre-wrap">{job.error_message}</pre>
          </Card>
        )}

        {/* Description */}
        {job.description && (
          <Card>
            <h3 className="text-sm font-medium text-[var(--text-dim)] mb-2">Description</h3>
            <p className="text-sm">{job.description}</p>
          </Card>
        )}
    </div>
  );
}
