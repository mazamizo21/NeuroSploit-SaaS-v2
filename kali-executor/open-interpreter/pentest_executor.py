"""
TazoSploit  v2 - Pentest Executor
Executes commands with full I/O capture and iterative LLM control
"""

import os
import json
import subprocess
import time
import logging
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict

from llm_client import PentestLLM, LLMClient
from advanced_agent import AdvancedAgent, ToolCategory, IOCapture

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger("tazosploit.executor")


@dataclass
class CommandExecution:
    """Full capture of command execution"""
    timestamp: str
    command: str
    exit_code: int
    stdout: str
    stderr: str
    duration_ms: int
    tool_detected: str
    blocked: bool = False
    block_reason: str = ""


class PentestExecutor:
    """
    Executes pentest commands with:
    - Full I/O capture
    - LLM-driven decision making
    - Automatic tool selection and retry
    - Evasion on detection
    """
    
    BLOCKED_COMMANDS = [
        "rm -rf /",
        "mkfs",
        "dd if=/dev/zero",
        ":(){:|:&};:",  # Fork bomb
    ]
    
    def __init__(self, target: str, log_dir: str = "/pentest/logs", max_iterations: int = 20):
        self.target = target
        self.log_dir = log_dir
        self.max_iterations = max_iterations
        
        os.makedirs(log_dir, exist_ok=True)
        
        self.llm = PentestLLM(target, log_dir)
        self.advanced_agent = AdvancedAgent(log_dir)
        
        self.executions: List[CommandExecution] = []
        self.findings: List[Dict] = []
        self.iteration = 0
        
        logger.info(f"Executor initialized for target: {target}")
    
    def run(self) -> Dict:
        """Main execution loop"""
        logger.info(f"Starting pentest against {self.target}")
        
        while self.iteration < self.max_iterations:
            self.iteration += 1
            logger.info(f"=== Iteration {self.iteration}/{self.max_iterations} ===")
            
            # Get next action from LLM
            try:
                response = self.llm.get_next_action()
                logger.debug(f"LLM response: {response[:200]}...")
            except Exception as e:
                logger.error(f"LLM error: {e}")
                break
            
            # Extract command
            command = self.llm.extract_command(response)
            
            if not command:
                # Check if LLM is done or needs more info
                if any(word in response.lower() for word in ["complete", "finished", "no more", "done"]):
                    logger.info("LLM indicates completion")
                    break
                else:
                    # Ask LLM to provide a command
                    self.llm.conversation.append({
                        "role": "user", 
                        "content": "Please provide the next command to execute in ```bash ``` format."
                    })
                    continue
            
            # Check if command is blocked
            if self._is_blocked(command):
                logger.warning(f"Blocked dangerous command: {command}")
                self.llm.add_command_result(command, "BLOCKED: This command is not allowed.", -1)
                continue
            
            # Execute command
            execution = self._execute_command(command)
            self.executions.append(execution)
            self._save_execution(execution)
            
            # Feed result back to LLM
            self.llm.add_command_result(command, execution.stdout + execution.stderr, execution.exit_code)
            
            # Check for findings in output
            self._analyze_for_findings(command, execution.stdout)
            
            # Small delay to avoid overwhelming
            time.sleep(0.5)
        
        return self._generate_report()
    
    def _is_blocked(self, command: str) -> bool:
        """Check if command is blocked"""
        for blocked in self.BLOCKED_COMMANDS:
            if blocked in command:
                return True
        return False
    
    def _execute_command(self, command: str, timeout: int = 300) -> CommandExecution:
        """Execute command with full capture"""
        logger.info(f"Executing: {command}")
        start_time = time.time()
        
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd="/pentest"
            )
            
            duration_ms = int((time.time() - start_time) * 1000)
            
            execution = CommandExecution(
                timestamp=datetime.utcnow().isoformat(),
                command=command,
                exit_code=result.returncode,
                stdout=result.stdout,
                stderr=result.stderr,
                duration_ms=duration_ms,
                tool_detected=self._detect_tool(command)
            )
            
        except subprocess.TimeoutExpired:
            execution = CommandExecution(
                timestamp=datetime.utcnow().isoformat(),
                command=command,
                exit_code=-1,
                stdout="",
                stderr=f"TIMEOUT: Command exceeded {timeout}s",
                duration_ms=timeout * 1000,
                tool_detected=self._detect_tool(command)
            )
            
        except Exception as e:
            execution = CommandExecution(
                timestamp=datetime.utcnow().isoformat(),
                command=command,
                exit_code=-1,
                stdout="",
                stderr=str(e),
                duration_ms=0,
                tool_detected=self._detect_tool(command)
            )
        
        logger.info(f"Exit code: {execution.exit_code}, Duration: {execution.duration_ms}ms")
        return execution
    
    def _detect_tool(self, command: str) -> str:
        """Detect which tool is being used"""
        tools = ["nmap", "nikto", "sqlmap", "hydra", "gobuster", "metasploit", 
                 "msfconsole", "nuclei", "masscan", "dirb", "wpscan", "curl", "wget"]
        for tool in tools:
            if tool in command.lower():
                return tool
        return "unknown"
    
    def _analyze_for_findings(self, command: str, output: str):
        """Analyze output for security findings"""
        finding_indicators = {
            "open port": "Open port discovered",
            "vulnerable": "Potential vulnerability",
            "injection": "SQL/Command injection",
            "password": "Credential found",
            "root": "Root access indicator",
            "admin": "Admin access indicator",
            "backdoor": "Backdoor detected",
            "exploit": "Exploit successful",
        }
        
        output_lower = output.lower()
        for indicator, finding_type in finding_indicators.items():
            if indicator in output_lower:
                self.findings.append({
                    "timestamp": datetime.utcnow().isoformat(),
                    "type": finding_type,
                    "command": command,
                    "indicator": indicator,
                    "output_snippet": output[:500]
                })
                logger.info(f"Finding detected: {finding_type}")
    
    def _save_execution(self, execution: CommandExecution):
        """Save execution to log file"""
        log_file = os.path.join(self.log_dir, "command_executions.jsonl")
        with open(log_file, 'a') as f:
            f.write(json.dumps(asdict(execution)) + '\n')
    
    def _generate_report(self) -> Dict:
        """Generate final report"""
        report = {
            "target": self.target,
            "started_at": self.executions[0].timestamp if self.executions else None,
            "completed_at": datetime.utcnow().isoformat(),
            "iterations": self.iteration,
            "commands_executed": len(self.executions),
            "findings_count": len(self.findings),
            "findings": self.findings,
            "llm_stats": self.llm.get_stats(),
            "executions": [asdict(e) for e in self.executions]
        }
        
        # Save report
        report_file = os.path.join(self.log_dir, f"report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json")
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        logger.info(f"Report saved: {report_file}")
        return report


def main():
    """Main entry point for testing"""
    import argparse
    
    parser = argparse.ArgumentParser(description="TazoSploit Pentest Executor")
    parser.add_argument("--target", required=True, help="Target to scan")
    parser.add_argument("--max-iterations", type=int, default=10, help="Max iterations")
    parser.add_argument("--log-dir", default="/pentest/logs", help="Log directory")
    
    args = parser.parse_args()
    
    executor = PentestExecutor(
        target=args.target,
        log_dir=args.log_dir,
        max_iterations=args.max_iterations
    )
    
    report = executor.run()
    
    print("\n" + "=" * 50)
    print("PENTEST COMPLETE")
    print("=" * 50)
    print(f"Target: {report['target']}")
    print(f"Commands executed: {report['commands_executed']}")
    print(f"Findings: {report['findings_count']}")
    print(f"LLM tokens used: {report['llm_stats']['total_tokens']}")


if __name__ == "__main__":
    main()
