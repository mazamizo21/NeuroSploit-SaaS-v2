#!/usr/bin/env python3
"""
TazoSploit SaaS v2 - Exploitation Executor
AI-driven exploitation with code generation, error capture, and iterative troubleshooting
"""

import os
import sys
import json
import subprocess
import time
import traceback
from datetime import datetime
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass, asdict

LOG_DIR = os.getenv("LOG_DIR", "/pentest/logs")
os.makedirs(LOG_DIR, exist_ok=True)

# Import LLM client
sys.path.insert(0, os.path.dirname(__file__))
from llm_client import LLMClient


@dataclass
class CodeExecution:
    """Captures code execution with full error details"""
    timestamp: str
    iteration: int
    code_type: str  # python, bash, exploit
    code: str
    stdout: str
    stderr: str
    exit_code: int
    error_type: Optional[str]
    error_message: Optional[str]
    duration_ms: int
    success: bool


class ExploitExecutor:
    """
    AI-driven exploitation executor that:
    1. Generates exploit code via LLM
    2. Executes code and captures errors
    3. Feeds errors back to LLM for troubleshooting
    4. Iterates until success or max attempts
    """
    
    EXPLOIT_SYSTEM_PROMPT = """You are an expert penetration tester and exploit developer.
You have access to a Kali Linux environment with all standard tools.

When writing exploits or scripts:
1. Use Python 3 for custom exploits
2. Wrap code in ```python or ```bash blocks
3. Include error handling in your code
4. If code fails, analyze the error and fix it
5. Try alternative approaches if one fails

Available tools: nmap, nikto, sqlmap, hydra, metasploit, python3, curl, nc

When you encounter an error:
- Analyze the error message carefully
- Identify the root cause
- Provide a FIXED version of the code
- Explain what you changed

Always respond with executable code when asked to exploit."""

    def __init__(self, target: str, log_dir: str = LOG_DIR):
        self.target = target
        self.log_dir = log_dir
        self.llm = LLMClient(log_dir)
        self.executions: List[CodeExecution] = []
        self.conversation: List[Dict] = []
        self.max_iterations = 10
        
        # Initialize conversation
        self.conversation = [
            {"role": "system", "content": self.EXPLOIT_SYSTEM_PROMPT}
        ]
        
        self._log(f"Exploit Executor initialized for target: {target}")
    
    def _log(self, msg: str, level: str = "INFO"):
        timestamp = datetime.utcnow().isoformat()
        log_line = f"[{timestamp}] [{level}] {msg}"
        print(log_line)
        with open(f"{self.log_dir}/exploit_executor.log", 'a') as f:
            f.write(log_line + '\n')
    
    def _extract_code(self, response: str) -> Tuple[Optional[str], Optional[str]]:
        """Extract code and type from LLM response"""
        import re
        
        # Python code
        match = re.search(r'```python\s*\n(.*?)\n```', response, re.DOTALL)
        if match:
            return match.group(1).strip(), "python"
        
        # Bash code
        match = re.search(r'```(?:bash|sh)\s*\n(.*?)\n```', response, re.DOTALL)
        if match:
            return match.group(1).strip(), "bash"
        
        # Generic code block
        match = re.search(r'```\s*\n(.*?)\n```', response, re.DOTALL)
        if match:
            code = match.group(1).strip()
            # Detect type
            if code.startswith('#!') or 'import ' in code or 'def ' in code:
                return code, "python"
            return code, "bash"
        
        return None, None
    
    def _execute_python(self, code: str, timeout: int = 60) -> CodeExecution:
        """Execute Python code and capture all output"""
        self._log(f"Executing Python code ({len(code)} chars)")
        
        # Write code to temp file
        code_file = f"{self.log_dir}/temp_exploit.py"
        with open(code_file, 'w') as f:
            f.write(code)
        
        start = time.time()
        error_type = None
        error_message = None
        
        try:
            result = subprocess.run(
                ["python3", code_file],
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd="/pentest"
            )
            duration = int((time.time() - start) * 1000)
            
            # Parse Python errors
            if result.returncode != 0:
                stderr = result.stderr
                if "Traceback" in stderr:
                    # Extract error type and message
                    lines = stderr.strip().split('\n')
                    for line in reversed(lines):
                        if ': ' in line and not line.startswith(' '):
                            parts = line.split(': ', 1)
                            error_type = parts[0]
                            error_message = parts[1] if len(parts) > 1 else ""
                            break
            
            return CodeExecution(
                timestamp=datetime.utcnow().isoformat(),
                iteration=len(self.executions) + 1,
                code_type="python",
                code=code,
                stdout=result.stdout,
                stderr=result.stderr,
                exit_code=result.returncode,
                error_type=error_type,
                error_message=error_message,
                duration_ms=duration,
                success=result.returncode == 0
            )
            
        except subprocess.TimeoutExpired:
            return CodeExecution(
                timestamp=datetime.utcnow().isoformat(),
                iteration=len(self.executions) + 1,
                code_type="python",
                code=code,
                stdout="",
                stderr=f"TIMEOUT: Code execution exceeded {timeout}s",
                exit_code=-1,
                error_type="TimeoutError",
                error_message=f"Execution exceeded {timeout} seconds",
                duration_ms=timeout * 1000,
                success=False
            )
        except Exception as e:
            return CodeExecution(
                timestamp=datetime.utcnow().isoformat(),
                iteration=len(self.executions) + 1,
                code_type="python",
                code=code,
                stdout="",
                stderr=traceback.format_exc(),
                exit_code=-1,
                error_type=type(e).__name__,
                error_message=str(e),
                duration_ms=int((time.time() - start) * 1000),
                success=False
            )
    
    def _execute_bash(self, code: str, timeout: int = 60) -> CodeExecution:
        """Execute bash code and capture all output"""
        self._log(f"Executing bash code ({len(code)} chars)")
        
        start = time.time()
        
        try:
            result = subprocess.run(
                code,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd="/pentest"
            )
            duration = int((time.time() - start) * 1000)
            
            return CodeExecution(
                timestamp=datetime.utcnow().isoformat(),
                iteration=len(self.executions) + 1,
                code_type="bash",
                code=code,
                stdout=result.stdout,
                stderr=result.stderr,
                exit_code=result.returncode,
                error_type="CommandError" if result.returncode != 0 else None,
                error_message=result.stderr[:500] if result.returncode != 0 else None,
                duration_ms=duration,
                success=result.returncode == 0
            )
            
        except subprocess.TimeoutExpired:
            return CodeExecution(
                timestamp=datetime.utcnow().isoformat(),
                iteration=len(self.executions) + 1,
                code_type="bash",
                code=code,
                stdout="",
                stderr=f"TIMEOUT: Command exceeded {timeout}s",
                exit_code=-1,
                error_type="TimeoutError",
                error_message=f"Execution exceeded {timeout} seconds",
                duration_ms=timeout * 1000,
                success=False
            )
    
    def _save_execution(self, execution: CodeExecution):
        """Save execution to log file"""
        self.executions.append(execution)
        with open(f"{self.log_dir}/exploit_executions.jsonl", 'a') as f:
            f.write(json.dumps(asdict(execution)) + '\n')
    
    def exploit(self, task: str) -> Dict:
        """
        Run exploitation loop:
        1. Ask LLM to generate exploit code
        2. Execute code
        3. If error, feed back to LLM and iterate
        4. Continue until success or max iterations
        """
        self._log(f"Starting exploitation: {task}")
        
        # Initial prompt
        self.conversation.append({
            "role": "user",
            "content": f"Target: {self.target}\n\nTask: {task}\n\nGenerate and execute the exploit code."
        })
        
        for i in range(self.max_iterations):
            self._log(f"=== Iteration {i+1}/{self.max_iterations} ===")
            
            # Get LLM response
            try:
                response = self.llm.chat(self.conversation)
                self.conversation.append({"role": "assistant", "content": response})
            except Exception as e:
                self._log(f"LLM error: {e}", "ERROR")
                break
            
            # Extract code
            code, code_type = self._extract_code(response)
            
            if not code:
                self._log("No code found in response")
                # Check if LLM thinks it's done
                if any(word in response.lower() for word in ["complete", "success", "exploited", "found"]):
                    self._log("LLM indicates completion")
                    break
                # Ask for code
                self.conversation.append({
                    "role": "user",
                    "content": "Please provide executable code in a ```python or ```bash block."
                })
                continue
            
            # Execute code
            if code_type == "python":
                execution = self._execute_python(code)
            else:
                execution = self._execute_bash(code)
            
            self._save_execution(execution)
            
            self._log(f"Execution: exit={execution.exit_code}, success={execution.success}")
            if execution.error_type:
                self._log(f"Error: {execution.error_type}: {execution.error_message}", "ERROR")
            
            # Check for success indicators in output
            if execution.success:
                output = execution.stdout.lower()
                if any(ind in output for ind in ["shell", "root", "exploited", "success", "vulnerable", "flag"]):
                    self._log("SUCCESS: Exploitation indicators found!")
                    break
            
            # Feed result back to LLM
            if execution.success:
                feedback = f"""Code executed successfully.

Output:
```
{execution.stdout[:2000]}
```

Analyze the output and continue with the next step, or confirm if exploitation was successful."""
            else:
                feedback = f"""Code execution FAILED.

Error Type: {execution.error_type}
Error Message: {execution.error_message}

Full stderr:
```
{execution.stderr[:2000]}
```

Please analyze this error, fix the code, and try again. Explain what went wrong and provide corrected code."""
            
            self.conversation.append({"role": "user", "content": feedback})
        
        # Generate report
        return self._generate_report()
    
    def _generate_report(self) -> Dict:
        """Generate exploitation report"""
        successful = [e for e in self.executions if e.success]
        failed = [e for e in self.executions if not e.success]
        
        report = {
            "target": self.target,
            "timestamp": datetime.utcnow().isoformat(),
            "total_iterations": len(self.executions),
            "successful_executions": len(successful),
            "failed_executions": len(failed),
            "error_types": list(set(e.error_type for e in failed if e.error_type)),
            "llm_stats": self.llm.get_stats(),
            "executions": [asdict(e) for e in self.executions]
        }
        
        # Save report
        report_file = f"{self.log_dir}/exploit_report_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2)
        
        self._log(f"Report saved: {report_file}")
        return report


def main():
    """Test exploitation against a target"""
    import argparse
    
    parser = argparse.ArgumentParser(description="TazoSploit Exploit Executor")
    parser.add_argument("--target", default="http://host.docker.internal:8888", help="Target URL")
    parser.add_argument("--task", default="sql_injection", help="Exploitation task")
    
    args = parser.parse_args()
    
    # Define exploitation tasks
    tasks = {
        "sql_injection": "Find and exploit SQL injection vulnerability. Try to extract database information.",
        "xss": "Find and exploit XSS vulnerability. Demonstrate with an alert box payload.",
        "command_injection": "Find and exploit command injection. Try to execute 'id' or 'whoami'.",
        "file_inclusion": "Find and exploit file inclusion vulnerability. Try to read /etc/passwd.",
        "brute_force": "Attempt to brute force the login page with common credentials."
    }
    
    task_desc = tasks.get(args.task, args.task)
    
    executor = ExploitExecutor(args.target)
    report = executor.exploit(task_desc)
    
    print("\n" + "=" * 60)
    print("EXPLOITATION REPORT")
    print("=" * 60)
    print(f"Target: {report['target']}")
    print(f"Iterations: {report['total_iterations']}")
    print(f"Successful: {report['successful_executions']}")
    print(f"Failed: {report['failed_executions']}")
    print(f"Errors encountered: {report['error_types']}")
    print(f"LLM tokens: {report['llm_stats']['total_tokens']}")
    print("=" * 60)


if __name__ == "__main__":
    main()
