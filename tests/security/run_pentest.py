#!/usr/bin/env python3
"""
TazoSploit  v2 - Automated Penetration Testing
Tests for common vulnerabilities
"""

import requests
import json
import sys
from datetime import datetime
from urllib.parse import quote

API_URL = "http://localhost:8000"

class PenetrationTest:
    def __init__(self):
        self.results = {
            "timestamp": datetime.utcnow().isoformat(),
            "vulnerabilities": [],
            "summary": {"critical": 0, "high": 0, "medium": 0, "low": 0, "info": 0}
        }
    
    def log_vuln(self, severity, title, description, evidence=""):
        vuln = {
            "severity": severity,
            "title": title,
            "description": description,
            "evidence": evidence
        }
        self.results["vulnerabilities"].append(vuln)
        self.results["summary"][severity] += 1
        
        icons = {"critical": "üî¥", "high": "üü†", "medium": "üü°", "low": "üîµ", "info": "‚ö™"}
        print(f"{icons.get(severity, '‚ö™')} [{severity.upper()}] {title}")
        if description:
            print(f"   ‚îî‚îÄ {description}")
    
    def log_pass(self, title):
        print(f"‚úÖ [SECURE] {title}")
    
    # =========================================================================
    # AUTHENTICATION TESTS
    # =========================================================================
    
    def test_auth_bypass(self):
        """Test for authentication bypass"""
        print("\n### Authentication Bypass Tests ###")
        
        # Test 1: Access without token
        protected = ["/api/v1/jobs", "/api/v1/tenants", "/api/v1/scopes"]
        for endpoint in protected:
            try:
                r = requests.get(f"{API_URL}{endpoint}", timeout=5)
                if r.status_code == 200:
                    self.log_vuln("critical", "Auth Bypass", f"{endpoint} accessible without auth")
                else:
                    self.log_pass(f"{endpoint} requires auth")
            except:
                pass
        
        # Test 2: Invalid token format
        try:
            r = requests.get(
                f"{API_URL}/api/v1/jobs",
                headers={"Authorization": "Bearer invalid.token.here"},
                timeout=5
            )
            if r.status_code == 200:
                self.log_vuln("critical", "Token Validation", "Invalid token accepted")
            else:
                self.log_pass("Invalid tokens rejected")
        except:
            pass
        
        # Test 3: Empty bearer token
        try:
            r = requests.get(
                f"{API_URL}/api/v1/jobs",
                headers={"Authorization": "Bearer "},
                timeout=5
            )
            if r.status_code == 200:
                self.log_vuln("critical", "Empty Token", "Empty bearer token accepted")
            else:
                self.log_pass("Empty tokens rejected")
        except:
            pass
    
    # =========================================================================
    # INJECTION TESTS
    # =========================================================================
    
    def test_sql_injection(self):
        """Test for SQL injection vulnerabilities"""
        print("\n### SQL Injection Tests ###")
        
        sqli_payloads = [
            "' OR '1'='1",
            "' OR '1'='1' --",
            "'; DROP TABLE users; --",
            "1 UNION SELECT NULL, NULL, NULL--",
            "admin'--",
            "1' AND '1'='1",
            "1; SELECT * FROM information_schema.tables--"
        ]
        
        endpoints = [
            "/api/v1/mitre/techniques?search={}",
            "/api/v1/mitre/techniques/{}",
        ]
        
        vulnerable = False
        for endpoint in endpoints:
            for payload in sqli_payloads:
                try:
                    url = f"{API_URL}{endpoint.format(quote(payload))}"
                    r = requests.get(url, timeout=5)
                    
                    # Check for SQL error messages
                    error_indicators = [
                        "sql", "syntax", "mysql", "postgresql", "sqlite",
                        "ora-", "db2", "odbc", "execute"
                    ]
                    
                    response_lower = r.text.lower()
                    for indicator in error_indicators:
                        if indicator in response_lower and r.status_code >= 500:
                            self.log_vuln(
                                "critical", 
                                "SQL Injection", 
                                f"SQL error exposed at {endpoint}",
                                f"Payload: {payload[:30]}..."
                            )
                            vulnerable = True
                            break
                    
                    if vulnerable:
                        break
                except:
                    pass
            
            if vulnerable:
                break
        
        if not vulnerable:
            self.log_pass("No SQL injection vulnerabilities detected")
    
    def test_command_injection(self):
        """Test for command injection"""
        print("\n### Command Injection Tests ###")
        
        cmd_payloads = [
            "; ls -la",
            "| cat /etc/passwd",
            "`whoami`",
            "$(id)",
            "& ping -c 1 127.0.0.1"
        ]
        
        vulnerable = False
        for payload in cmd_payloads:
            try:
                r = requests.get(
                    f"{API_URL}/api/v1/mitre/tools/{quote(payload)}/techniques",
                    timeout=5
                )
                
                # Check for command output in response
                cmd_indicators = ["uid=", "root:", "bin/", "etc/passwd", "total "]
                for indicator in cmd_indicators:
                    if indicator in r.text:
                        self.log_vuln(
                            "critical",
                            "Command Injection",
                            f"Command execution detected",
                            f"Payload: {payload}"
                        )
                        vulnerable = True
                        break
            except:
                pass
        
        if not vulnerable:
            self.log_pass("No command injection vulnerabilities detected")
    
    def test_path_traversal(self):
        """Test for path traversal"""
        print("\n### Path Traversal Tests ###")
        
        traversal_payloads = [
            "../../../etc/passwd",
            "....//....//....//etc/passwd",
            "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc/passwd",
            "..\\..\\..\\windows\\system32\\config\\sam"
        ]
        
        vulnerable = False
        for payload in traversal_payloads:
            try:
                r = requests.get(
                    f"{API_URL}/api/v1/mitre/techniques/{quote(payload)}",
                    timeout=5
                )
                
                if "root:" in r.text or "[boot loader]" in r.text:
                    self.log_vuln(
                        "critical",
                        "Path Traversal",
                        "File system access detected",
                        f"Payload: {payload}"
                    )
                    vulnerable = True
                    break
            except:
                pass
        
        if not vulnerable:
            self.log_pass("No path traversal vulnerabilities detected")
    
    def test_xss(self):
        """Test for XSS vulnerabilities"""
        print("\n### XSS Tests ###")
        
        xss_payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>",
            "javascript:alert('XSS')",
            "<body onload=alert('XSS')>",
            "'><script>alert(String.fromCharCode(88,83,83))</script>"
        ]
        
        vulnerable = False
        for payload in xss_payloads:
            try:
                r = requests.get(
                    f"{API_URL}/api/v1/mitre/techniques?search={quote(payload)}",
                    timeout=5
                )
                
                # Check if payload is reflected without encoding
                if payload in r.text and "text/html" in r.headers.get("Content-Type", ""):
                    self.log_vuln(
                        "high",
                        "Reflected XSS",
                        "XSS payload reflected in response",
                        f"Payload: {payload[:30]}..."
                    )
                    vulnerable = True
                    break
            except:
                pass
        
        if not vulnerable:
            self.log_pass("No XSS vulnerabilities detected (JSON responses)")
    
    # =========================================================================
    # AUTHORIZATION TESTS
    # =========================================================================
    
    def test_idor(self):
        """Test for Insecure Direct Object Reference"""
        print("\n### IDOR Tests ###")
        
        # Test accessing other tenant's resources
        test_uuids = [
            "00000000-0000-0000-0000-000000000001",
            "00000000-0000-0000-0000-000000000002",
            "11111111-1111-1111-1111-111111111111"
        ]
        
        vulnerable = False
        for uuid in test_uuids:
            try:
                # Try accessing job without auth
                r = requests.get(f"{API_URL}/api/v1/jobs/{uuid}", timeout=5)
                if r.status_code == 200:
                    data = r.json()
                    if data and "id" in str(data):
                        self.log_vuln(
                            "high",
                            "IDOR",
                            f"Accessed resource {uuid} without auth"
                        )
                        vulnerable = True
            except:
                pass
        
        if not vulnerable:
            self.log_pass("IDOR protection in place (auth required)")
    
    def test_mass_assignment(self):
        """Test for mass assignment vulnerabilities"""
        print("\n### Mass Assignment Tests ###")
        
        # Try to set admin/privileged fields
        payloads = [
            {"is_admin": True},
            {"role": "admin"},
            {"tenant_id": "other-tenant-id"},
            {"permissions": ["*"]},
            {"__class__": "admin"}
        ]
        
        # This would require actual endpoint testing with auth
        self.log_pass("Mass assignment - requires authenticated testing")
    
    # =========================================================================
    # INFORMATION DISCLOSURE
    # =========================================================================
    
    def test_info_disclosure(self):
        """Test for information disclosure"""
        print("\n### Information Disclosure Tests ###")
        
        # Test 1: Debug endpoints
        debug_endpoints = [
            "/debug", "/trace", "/_debug", "/api/debug",
            "/swagger.json", "/openapi.json", "/docs", "/redoc"
        ]
        
        for endpoint in debug_endpoints:
            try:
                r = requests.get(f"{API_URL}{endpoint}", timeout=5)
                if r.status_code == 200:
                    if endpoint in ["/docs", "/redoc", "/openapi.json"]:
                        self.log_vuln(
                            "info",
                            "API Documentation Exposed",
                            f"{endpoint} is publicly accessible"
                        )
                    else:
                        self.log_vuln(
                            "medium",
                            "Debug Endpoint",
                            f"{endpoint} accessible"
                        )
            except:
                pass
        
        # Test 2: Error messages
        try:
            r = requests.get(f"{API_URL}/api/v1/force/error/here", timeout=5)
            if "traceback" in r.text.lower() or "line " in r.text.lower():
                self.log_vuln("medium", "Stack Trace Disclosure", "Error exposes stack trace")
            else:
                self.log_pass("Error messages don't expose stack traces")
        except:
            pass
        
        # Test 3: Version disclosure
        try:
            r = requests.get(f"{API_URL}/health", timeout=5)
            data = r.json()
            if "version" in data:
                self.log_vuln(
                    "info",
                    "Version Disclosure",
                    f"Version {data.get('version')} disclosed in health endpoint"
                )
        except:
            pass
    
    # =========================================================================
    # DENIAL OF SERVICE
    # =========================================================================
    
    def test_dos(self):
        """Test for DoS vulnerabilities"""
        print("\n### DoS Tests ###")
        
        # Test 1: Large payload
        try:
            large_payload = {"data": "A" * 10000000}  # 10MB
            r = requests.post(
                f"{API_URL}/api/v1/jobs",
                json=large_payload,
                timeout=10
            )
            if r.status_code not in [413, 422, 400, 401]:
                self.log_vuln("medium", "Large Payload", "Server accepts very large payloads")
            else:
                self.log_pass("Large payloads rejected")
        except requests.exceptions.Timeout:
            self.log_vuln("medium", "Slow Processing", "Large payload caused timeout")
        except:
            self.log_pass("Large payload handling OK")
        
        # Test 2: Regex DoS (ReDoS)
        redos_payload = "a" * 50 + "!"
        try:
            r = requests.get(
                f"{API_URL}/api/v1/mitre/techniques?search={redos_payload}",
                timeout=5
            )
            self.log_pass("No ReDoS vulnerability detected")
        except requests.exceptions.Timeout:
            self.log_vuln("high", "ReDoS", "Regex denial of service possible")
        except:
            pass
    
    def run_all(self):
        """Run all penetration tests"""
        print("=" * 70)
        print("TazoSploit  v2 - Penetration Test")
        print("=" * 70)
        
        self.test_auth_bypass()
        self.test_sql_injection()
        self.test_command_injection()
        self.test_path_traversal()
        self.test_xss()
        self.test_idor()
        self.test_mass_assignment()
        self.test_info_disclosure()
        self.test_dos()
        
        print("\n" + "=" * 70)
        print("PENETRATION TEST SUMMARY")
        print("=" * 70)
        print(f"üî¥ Critical: {self.results['summary']['critical']}")
        print(f"üü† High:     {self.results['summary']['high']}")
        print(f"üü° Medium:   {self.results['summary']['medium']}")
        print(f"üîµ Low:      {self.results['summary']['low']}")
        print(f"‚ö™ Info:     {self.results['summary']['info']}")
        print()
        
        if self.results['summary']['critical'] > 0:
            print("üö® STATUS: CRITICAL VULNERABILITIES FOUND")
            return 2
        elif self.results['summary']['high'] > 0:
            print("‚ö†Ô∏è  STATUS: HIGH SEVERITY ISSUES FOUND")
            return 1
        else:
            print("üõ°Ô∏è  STATUS: NO CRITICAL/HIGH VULNERABILITIES")
            return 0

if __name__ == "__main__":
    pentest = PenetrationTest()
    sys.exit(pentest.run_all())
